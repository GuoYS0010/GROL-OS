
bin/GROL.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000000200000 <_start>:
	.global	_start

	.text
_start:
	# park harts with id != 0
	csrr	t0, mhartid		# read current hart id
  200000:	f14022f3          	csrr	t0,mhartid
	mv	tp, t0			# keep CPU's hartid in its tp for later usage.
  200004:	8216                	mv	tp,t0
	bnez	t0, park		# if we're not on the hart 0
  200006:	02029963          	bnez	t0,200038 <park>
					# we park the hart

	# Set all bytes in the BSS section to zero.
	la	a0, _bss_start
  20000a:	00006517          	auipc	a0,0x6
  20000e:	03650513          	addi	a0,a0,54 # 206040 <mymutex>
	la	a1, _bss_end
  200012:	0000a597          	auipc	a1,0xa
  200016:	05e58593          	addi	a1,a1,94 # 20a070 <_bss_end>
	bgeu	a0, a1, 2f
  20001a:	00b57763          	bgeu	a0,a1,200028 <_start+0x28>
1:
	sw	zero, (a0)
  20001e:	00052023          	sw	zero,0(a0)
	addi	a0, a0, 4
  200022:	0511                	addi	a0,a0,4
	bltu	a0, a1, 1b
  200024:	feb56de3          	bltu	a0,a1,20001e <_start+0x1e>
2:
	# Setup stacks, the stack grows from bottom to top, so we put the
	# stack pointer to the very end of the stack range.
	slli	t0, t0, 10		# shift left the hart id by 1024
  200028:	02aa                	slli	t0,t0,0xa
	la	sp, stacks + STACK_SIZE	# set the initial stack pointer
  20002a:	00000117          	auipc	sp,0x0
  20002e:	41610113          	addi	sp,sp,1046 # 200440 <stacks+0x400>
					# to the end of the first stack space
	add	sp, sp, t0		# move the current hart stack pointer
  200032:	9116                	add	sp,sp,t0
					# to its place in the stack space

	j	start_kernel		# hart 0 jump to c
  200034:	7090406f          	j	204f3c <start_kernel>

0000000000200038 <park>:

park:
	wfi
  200038:	10500073          	wfi
	j	park
  20003c:	bff5                	j	200038 <park>
  20003e:	0001                	nop

0000000000200040 <stacks>:
	...

0000000000202044 <trap_vector>:
.globl trap_vector
# the trap vector base address must always be aligned on a 4-byte boundary
.balign 4
trap_vector:
	# save context(registers).
	csrrw	t6, mscratch, t6	# swap t6 and mscratch
  202044:	340f9ff3          	csrrw	t6,mscratch,t6
	reg_save t6
  202048:	001fb023          	sd	ra,0(t6)
  20204c:	002fb423          	sd	sp,8(t6)
  202050:	025fb023          	sd	t0,32(t6)
  202054:	026fb423          	sd	t1,40(t6)
  202058:	027fb823          	sd	t2,48(t6)
  20205c:	028fbc23          	sd	s0,56(t6)
  202060:	049fb023          	sd	s1,64(t6)
  202064:	04afb423          	sd	a0,72(t6)
  202068:	04bfb823          	sd	a1,80(t6)
  20206c:	04cfbc23          	sd	a2,88(t6)
  202070:	06dfb023          	sd	a3,96(t6)
  202074:	06efb423          	sd	a4,104(t6)
  202078:	06ffb823          	sd	a5,112(t6)
  20207c:	070fbc23          	sd	a6,120(t6)
  202080:	091fb023          	sd	a7,128(t6)
  202084:	092fb423          	sd	s2,136(t6)
  202088:	093fb823          	sd	s3,144(t6)
  20208c:	094fbc23          	sd	s4,152(t6)
  202090:	0b5fb023          	sd	s5,160(t6)
  202094:	0b6fb423          	sd	s6,168(t6)
  202098:	0b7fb823          	sd	s7,176(t6)
  20209c:	0b8fbc23          	sd	s8,184(t6)
  2020a0:	0d9fb023          	sd	s9,192(t6)
  2020a4:	0dafb423          	sd	s10,200(t6)
  2020a8:	0dbfb823          	sd	s11,208(t6)
  2020ac:	0dcfbc23          	sd	t3,216(t6)
  2020b0:	0fdfb023          	sd	t4,224(t6)
  2020b4:	0fefb423          	sd	t5,232(t6)

	# Save the actual t6 register, which we swapped into
	# mscratch
	mv	t5, t6			# t5 points to the context of current task
  2020b8:	8f7e                	mv	t5,t6
	csrr	t6, mscratch		# read t6 back from mscratch
  2020ba:	34002ff3          	csrr	t6,mscratch
	STORE	t6, 30*SIZE_REG(t5)	# save t6 with t5 as base
  2020be:	0fff3823          	sd	t6,240(t5)

	csrr 	a0, mepc
  2020c2:	34102573          	csrr	a0,mepc
	STORE	a0, 31*SIZE_REG(t5) #save current mepc
  2020c6:	0eaf3c23          	sd	a0,248(t5)

	# Restore the context pointer into mscratch
	csrw	mscratch, t5
  2020ca:	340f1073          	csrw	mscratch,t5

	# call the C trap handler in trap.c
	csrr	a0, mepc
  2020ce:	34102573          	csrr	a0,mepc
	csrr	a1, mcause
  2020d2:	342025f3          	csrr	a1,mcause
	call	trap_handler
  2020d6:	63f000ef          	jal	ra,202f14 <trap_handler>

	# trap_handler will return the return address via a0.
	csrw	mepc, a0
  2020da:	34151073          	csrw	mepc,a0

	# restore context(registers).
	csrr	t6, mscratch
  2020de:	34002ff3          	csrr	t6,mscratch
	reg_restore t6
  2020e2:	000fb083          	ld	ra,0(t6)
  2020e6:	008fb103          	ld	sp,8(t6)
  2020ea:	020fb283          	ld	t0,32(t6)
  2020ee:	028fb303          	ld	t1,40(t6)
  2020f2:	030fb383          	ld	t2,48(t6)
  2020f6:	038fb403          	ld	s0,56(t6)
  2020fa:	040fb483          	ld	s1,64(t6)
  2020fe:	048fb503          	ld	a0,72(t6)
  202102:	050fb583          	ld	a1,80(t6)
  202106:	058fb603          	ld	a2,88(t6)
  20210a:	060fb683          	ld	a3,96(t6)
  20210e:	068fb703          	ld	a4,104(t6)
  202112:	070fb783          	ld	a5,112(t6)
  202116:	078fb803          	ld	a6,120(t6)
  20211a:	080fb883          	ld	a7,128(t6)
  20211e:	088fb903          	ld	s2,136(t6)
  202122:	090fb983          	ld	s3,144(t6)
  202126:	098fba03          	ld	s4,152(t6)
  20212a:	0a0fba83          	ld	s5,160(t6)
  20212e:	0a8fbb03          	ld	s6,168(t6)
  202132:	0b0fbb83          	ld	s7,176(t6)
  202136:	0b8fbc03          	ld	s8,184(t6)
  20213a:	0c0fbc83          	ld	s9,192(t6)
  20213e:	0c8fbd03          	ld	s10,200(t6)
  202142:	0d0fbd83          	ld	s11,208(t6)
  202146:	0d8fbe03          	ld	t3,216(t6)
  20214a:	0e0fbe83          	ld	t4,224(t6)
  20214e:	0e8fbf03          	ld	t5,232(t6)
  202152:	0f0fbf83          	ld	t6,240(t6)

	# return to whatever we were doing before trap.
	mret
  202156:	30200073          	mret
  20215a:	0001                	nop

000000000020215c <switch_to>:
#	csrr	t6, mscratch		# read t6 back from mscratch
#	STORE	t6, 30*SIZE_REG(t5)	# save t6 with t5 as base

# 1:
	# switch mscratch to point to the context of the next task
	csrw	mscratch, a0
  20215c:	34051073          	csrw	mscratch,a0


	LOAD	a1, 31*SIZE_REG(a0)
  202160:	7d6c                	ld	a1,248(a0)
	csrw	mepc, a1
  202162:	34159073          	csrw	mepc,a1
	#read mepc of context and set it


	# Restore all GP registers
	# Use t6 to point to the context of the new task
	mv	t6, a0
  202166:	8faa                	mv	t6,a0
	reg_restore t6
  202168:	000fb083          	ld	ra,0(t6)
  20216c:	008fb103          	ld	sp,8(t6)
  202170:	020fb283          	ld	t0,32(t6)
  202174:	028fb303          	ld	t1,40(t6)
  202178:	030fb383          	ld	t2,48(t6)
  20217c:	038fb403          	ld	s0,56(t6)
  202180:	040fb483          	ld	s1,64(t6)
  202184:	048fb503          	ld	a0,72(t6)
  202188:	050fb583          	ld	a1,80(t6)
  20218c:	058fb603          	ld	a2,88(t6)
  202190:	060fb683          	ld	a3,96(t6)
  202194:	068fb703          	ld	a4,104(t6)
  202198:	070fb783          	ld	a5,112(t6)
  20219c:	078fb803          	ld	a6,120(t6)
  2021a0:	080fb883          	ld	a7,128(t6)
  2021a4:	088fb903          	ld	s2,136(t6)
  2021a8:	090fb983          	ld	s3,144(t6)
  2021ac:	098fba03          	ld	s4,152(t6)
  2021b0:	0a0fba83          	ld	s5,160(t6)
  2021b4:	0a8fbb03          	ld	s6,168(t6)
  2021b8:	0b0fbb83          	ld	s7,176(t6)
  2021bc:	0b8fbc03          	ld	s8,184(t6)
  2021c0:	0c0fbc83          	ld	s9,192(t6)
  2021c4:	0c8fbd03          	ld	s10,200(t6)
  2021c8:	0d0fbd83          	ld	s11,208(t6)
  2021cc:	0d8fbe03          	ld	t3,216(t6)
  2021d0:	0e0fbe83          	ld	t4,224(t6)
  2021d4:	0e8fbf03          	ld	t5,232(t6)
  2021d8:	0f0fbf83          	ld	t6,240(t6)

	# Do actual context switching.
	mret
  2021dc:	30200073          	mret
  2021e0:	0000                	unimp
	...

00000000002021e4 <mutex_acquire>:
.global task_yield
.global printmutex
.global mutex_acquire
.balign 4
mutex_acquire:
    addi                sp, sp, -16
  2021e4:	1141                	addi	sp,sp,-16
    sd                  ra, 8(sp)
  2021e6:	e406                	sd	ra,8(sp)
    sd                  s0, 0(sp)
  2021e8:	e022                	sd	s0,0(sp)
    addi                s0, sp, 16
  2021ea:	0800                	addi	s0,sp,16
    //init
    li                  a5, 1
  2021ec:	4785                	li	a5,1

00000000002021ee <loop>:
loop:
    amoswap.w.aq        a5, a5, (a0)
  2021ee:	0cf527af          	amoswap.w.aq	a5,a5,(a0)
    beqz                a5, acquire_success 
  2021f2:	c791                	beqz	a5,2021fe <acquire_success>
    call                task_yield
  2021f4:	2bf010ef          	jal	ra,203cb2 <task_yield>
    call                printmutex
  2021f8:	00d000ef          	jal	ra,202a04 <printmutex>
    j                   loop
  2021fc:	bfcd                	j	2021ee <loop>

00000000002021fe <acquire_success>:
acquire_success:
    //finish
    ld                  s0, 0(sp)
  2021fe:	6402                	ld	s0,0(sp)
    ld                  ra, 8(sp)
  202200:	60a2                	ld	ra,8(sp)
    addi                sp, sp, 16
  202202:	0141                	addi	sp,sp,16
    ret
  202204:	8082                	ret
  202206:	0001                	nop

0000000000202208 <mutex_release>:


.global mutex_release
.balign 4
mutex_release:
    addi                sp, sp, -16
  202208:	1141                	addi	sp,sp,-16
    sd                  ra, 8(sp)
  20220a:	e406                	sd	ra,8(sp)
    sd                  s0, 0(sp)
  20220c:	e022                	sd	s0,0(sp)
    addi                s0, sp, 16
  20220e:	0800                	addi	s0,sp,16
    //init
    li                  a5, 0
  202210:	4781                	li	a5,0
    sw                  a5, 0(a0)
  202212:	c11c                	sw	a5,0(a0)
    call                task_yield
  202214:	29f010ef          	jal	ra,203cb2 <task_yield>
    //finish
    ld                  s0, 0(sp)
  202218:	6402                	ld	s0,0(sp)
    ld                  ra, 8(sp)
  20221a:	60a2                	ld	ra,8(sp)
    addi                sp, sp, 16
  20221c:	0141                	addi	sp,sp,16
    ret
  20221e:	8082                	ret
	...

0000000000202222 <mod10>:
#include "printf.h"
/*
 * ref: https://github.com/cccriscv/mini-riscv-os/blob/master/05-Preemptive/lib.c
 */
static int mod10(long n){
  202222:	7179                	addi	sp,sp,-48
  202224:	f422                	sd	s0,40(sp)
  202226:	1800                	addi	s0,sp,48
  202228:	fca43c23          	sd	a0,-40(s0)
	unsigned int upn = *((int*)&n + 1);
  20222c:	fd840793          	addi	a5,s0,-40
  202230:	0791                	addi	a5,a5,4
  202232:	439c                	lw	a5,0(a5)
  202234:	fef42623          	sw	a5,-20(s0)
	unsigned int downn = *(int*)&n ;
  202238:	fd840793          	addi	a5,s0,-40
  20223c:	439c                	lw	a5,0(a5)
  20223e:	fef42423          	sw	a5,-24(s0)
	return (((upn % 10) * 6 + downn % 10)) % 10;
  202242:	fec42703          	lw	a4,-20(s0)
  202246:	47a9                	li	a5,10
  202248:	02f777bb          	remuw	a5,a4,a5
  20224c:	2781                	sext.w	a5,a5
  20224e:	873e                	mv	a4,a5
  202250:	87ba                	mv	a5,a4
  202252:	0017979b          	slliw	a5,a5,0x1
  202256:	9fb9                	addw	a5,a5,a4
  202258:	0017979b          	slliw	a5,a5,0x1
  20225c:	0007871b          	sext.w	a4,a5
  202260:	fe842683          	lw	a3,-24(s0)
  202264:	47a9                	li	a5,10
  202266:	02f6f7bb          	remuw	a5,a3,a5
  20226a:	2781                	sext.w	a5,a5
  20226c:	9fb9                	addw	a5,a5,a4
  20226e:	2781                	sext.w	a5,a5
  202270:	873e                	mv	a4,a5
  202272:	47a9                	li	a5,10
  202274:	02f777bb          	remuw	a5,a4,a5
  202278:	2781                	sext.w	a5,a5
  20227a:	2781                	sext.w	a5,a5
}
  20227c:	853e                	mv	a0,a5
  20227e:	7422                	ld	s0,40(sp)
  202280:	6145                	addi	sp,sp,48
  202282:	8082                	ret

0000000000202284 <div10>:
(a*2^32 + b) mod 10 = a * 2^32 mod 10 + b mod 10
					= (a mod 10) * (2 ^ 32)mod 10 + b mod 10
					= 6(a mod 10) + b mod 10
*/

static long div10(long n){
  202284:	7179                	addi	sp,sp,-48
  202286:	f422                	sd	s0,40(sp)
  202288:	1800                	addi	s0,sp,48
  20228a:	fca43c23          	sd	a0,-40(s0)
	long a = 10;
  20228e:	47a9                	li	a5,10
  202290:	fef43423          	sd	a5,-24(s0)
	long ret;
	asm volatile (
  202294:	fd843783          	ld	a5,-40(s0)
  202298:	fe843703          	ld	a4,-24(s0)
  20229c:	02e7c7b3          	div	a5,a5,a4
  2022a0:	fef43023          	sd	a5,-32(s0)
		"div %[sum], %[add1], %[add2]" 
		:[sum]"=r"(ret)
		:[add1]"r"(n), [add2]"r"(a)
	);
	return ret;
  2022a4:	fe043783          	ld	a5,-32(s0)
}
  2022a8:	853e                	mv	a0,a5
  2022aa:	7422                	ld	s0,40(sp)
  2022ac:	6145                	addi	sp,sp,48
  2022ae:	8082                	ret

00000000002022b0 <_vsnprintf>:

static int _vsnprintf(char * out, size_t n, const char* s, va_list vl)
{
  2022b0:	7119                	addi	sp,sp,-128
  2022b2:	fc86                	sd	ra,120(sp)
  2022b4:	f8a2                	sd	s0,112(sp)
  2022b6:	0100                	addi	s0,sp,128
  2022b8:	f8a43c23          	sd	a0,-104(s0)
  2022bc:	f8b43823          	sd	a1,-112(s0)
  2022c0:	f8c43423          	sd	a2,-120(s0)
  2022c4:	f8d43023          	sd	a3,-128(s0)
	int format = 0;
  2022c8:	fe042623          	sw	zero,-20(s0)
	int longarg = 0;
  2022cc:	fe042423          	sw	zero,-24(s0)
	size_t pos = 0;
  2022d0:	fe043023          	sd	zero,-32(s0)
	for (; *s; s++) {
  2022d4:	ae4d                	j	202686 <_vsnprintf+0x3d6>
		if (format) {
  2022d6:	fec42783          	lw	a5,-20(s0)
  2022da:	2781                	sext.w	a5,a5
  2022dc:	34078863          	beqz	a5,20262c <_vsnprintf+0x37c>
			switch(*s) {
  2022e0:	f8843783          	ld	a5,-120(s0)
  2022e4:	0007c783          	lbu	a5,0(a5)
  2022e8:	2781                	sext.w	a5,a5
  2022ea:	f9d7869b          	addiw	a3,a5,-99
  2022ee:	0006871b          	sext.w	a4,a3
  2022f2:	47d5                	li	a5,21
  2022f4:	38e7e363          	bltu	a5,a4,20267a <_vsnprintf+0x3ca>
  2022f8:	02069793          	slli	a5,a3,0x20
  2022fc:	9381                	srli	a5,a5,0x20
  2022fe:	00279713          	slli	a4,a5,0x2
  202302:	00003797          	auipc	a5,0x3
  202306:	d6e78793          	addi	a5,a5,-658 # 205070 <BSS_END+0x8>
  20230a:	97ba                	add	a5,a5,a4
  20230c:	439c                	lw	a5,0(a5)
  20230e:	0007871b          	sext.w	a4,a5
  202312:	00003797          	auipc	a5,0x3
  202316:	d5e78793          	addi	a5,a5,-674 # 205070 <BSS_END+0x8>
  20231a:	97ba                	add	a5,a5,a4
  20231c:	8782                	jr	a5
			case 'l': {
				longarg = 1;
  20231e:	4785                	li	a5,1
  202320:	fef42423          	sw	a5,-24(s0)
				break;
  202324:	aea1                	j	20267c <_vsnprintf+0x3cc>
			}
			case 'p': {
				longarg = 1;
  202326:	4785                	li	a5,1
  202328:	fef42423          	sw	a5,-24(s0)
				if (out && pos < n) {
  20232c:	f9843783          	ld	a5,-104(s0)
  202330:	c385                	beqz	a5,202350 <_vsnprintf+0xa0>
  202332:	fe043703          	ld	a4,-32(s0)
  202336:	f9043783          	ld	a5,-112(s0)
  20233a:	00f77b63          	bgeu	a4,a5,202350 <_vsnprintf+0xa0>
					out[pos] = '0';
  20233e:	f9843703          	ld	a4,-104(s0)
  202342:	fe043783          	ld	a5,-32(s0)
  202346:	97ba                	add	a5,a5,a4
  202348:	03000713          	li	a4,48
  20234c:	00e78023          	sb	a4,0(a5)
				}
				pos++;
  202350:	fe043783          	ld	a5,-32(s0)
  202354:	0785                	addi	a5,a5,1
  202356:	fef43023          	sd	a5,-32(s0)
				if (out && pos < n) {
  20235a:	f9843783          	ld	a5,-104(s0)
  20235e:	c385                	beqz	a5,20237e <_vsnprintf+0xce>
  202360:	fe043703          	ld	a4,-32(s0)
  202364:	f9043783          	ld	a5,-112(s0)
  202368:	00f77b63          	bgeu	a4,a5,20237e <_vsnprintf+0xce>
					out[pos] = 'x';
  20236c:	f9843703          	ld	a4,-104(s0)
  202370:	fe043783          	ld	a5,-32(s0)
  202374:	97ba                	add	a5,a5,a4
  202376:	07800713          	li	a4,120
  20237a:	00e78023          	sb	a4,0(a5)
				}
				pos++;
  20237e:	fe043783          	ld	a5,-32(s0)
  202382:	0785                	addi	a5,a5,1
  202384:	fef43023          	sd	a5,-32(s0)
			}
			case 'x': {
				long num = longarg ? va_arg(vl, long) : va_arg(vl, int);
  202388:	fe842783          	lw	a5,-24(s0)
  20238c:	2781                	sext.w	a5,a5
  20238e:	cb89                	beqz	a5,2023a0 <_vsnprintf+0xf0>
  202390:	f8043783          	ld	a5,-128(s0)
  202394:	00878713          	addi	a4,a5,8
  202398:	f8e43023          	sd	a4,-128(s0)
  20239c:	639c                	ld	a5,0(a5)
  20239e:	a801                	j	2023ae <_vsnprintf+0xfe>
  2023a0:	f8043783          	ld	a5,-128(s0)
  2023a4:	00878713          	addi	a4,a5,8
  2023a8:	f8e43023          	sd	a4,-128(s0)
  2023ac:	439c                	lw	a5,0(a5)
  2023ae:	faf43423          	sd	a5,-88(s0)
				int hexdigits = 2*(longarg ? sizeof(long) : sizeof(int))-1;
  2023b2:	fe842783          	lw	a5,-24(s0)
  2023b6:	2781                	sext.w	a5,a5
  2023b8:	c399                	beqz	a5,2023be <_vsnprintf+0x10e>
  2023ba:	47bd                	li	a5,15
  2023bc:	a011                	j	2023c0 <_vsnprintf+0x110>
  2023be:	479d                	li	a5,7
  2023c0:	faf42223          	sw	a5,-92(s0)
				for(int i = hexdigits; i >= 0; i--) {
  2023c4:	fa442783          	lw	a5,-92(s0)
  2023c8:	fcf42e23          	sw	a5,-36(s0)
  2023cc:	a041                	j	20244c <_vsnprintf+0x19c>
					int d = (num >> (4*i)) & 0xF;
  2023ce:	fdc42783          	lw	a5,-36(s0)
  2023d2:	0027979b          	slliw	a5,a5,0x2
  2023d6:	2781                	sext.w	a5,a5
  2023d8:	fa843703          	ld	a4,-88(s0)
  2023dc:	40f757b3          	sra	a5,a4,a5
  2023e0:	2781                	sext.w	a5,a5
  2023e2:	8bbd                	andi	a5,a5,15
  2023e4:	faf42023          	sw	a5,-96(s0)
					if (out && pos < n) {
  2023e8:	f9843783          	ld	a5,-104(s0)
  2023ec:	c7b1                	beqz	a5,202438 <_vsnprintf+0x188>
  2023ee:	fe043703          	ld	a4,-32(s0)
  2023f2:	f9043783          	ld	a5,-112(s0)
  2023f6:	04f77163          	bgeu	a4,a5,202438 <_vsnprintf+0x188>
						out[pos] = (d < 10 ? '0'+d : 'a'+d-10);
  2023fa:	fa042783          	lw	a5,-96(s0)
  2023fe:	0007871b          	sext.w	a4,a5
  202402:	47a5                	li	a5,9
  202404:	00e7cb63          	blt	a5,a4,20241a <_vsnprintf+0x16a>
  202408:	fa042783          	lw	a5,-96(s0)
  20240c:	0ff7f793          	andi	a5,a5,255
  202410:	0307879b          	addiw	a5,a5,48
  202414:	0ff7f793          	andi	a5,a5,255
  202418:	a809                	j	20242a <_vsnprintf+0x17a>
  20241a:	fa042783          	lw	a5,-96(s0)
  20241e:	0ff7f793          	andi	a5,a5,255
  202422:	0577879b          	addiw	a5,a5,87
  202426:	0ff7f793          	andi	a5,a5,255
  20242a:	f9843683          	ld	a3,-104(s0)
  20242e:	fe043703          	ld	a4,-32(s0)
  202432:	9736                	add	a4,a4,a3
  202434:	00f70023          	sb	a5,0(a4)
					}
					pos++;
  202438:	fe043783          	ld	a5,-32(s0)
  20243c:	0785                	addi	a5,a5,1
  20243e:	fef43023          	sd	a5,-32(s0)
				for(int i = hexdigits; i >= 0; i--) {
  202442:	fdc42783          	lw	a5,-36(s0)
  202446:	37fd                	addiw	a5,a5,-1
  202448:	fcf42e23          	sw	a5,-36(s0)
  20244c:	fdc42783          	lw	a5,-36(s0)
  202450:	2781                	sext.w	a5,a5
  202452:	f607dee3          	bgez	a5,2023ce <_vsnprintf+0x11e>
				}
				longarg = 0;
  202456:	fe042423          	sw	zero,-24(s0)
				format = 0;
  20245a:	fe042623          	sw	zero,-20(s0)
				break;
  20245e:	ac39                	j	20267c <_vsnprintf+0x3cc>
			}
			case 'd': {
				long num = longarg ? va_arg(vl, long) : va_arg(vl, int);
  202460:	fe842783          	lw	a5,-24(s0)
  202464:	2781                	sext.w	a5,a5
  202466:	cb89                	beqz	a5,202478 <_vsnprintf+0x1c8>
  202468:	f8043783          	ld	a5,-128(s0)
  20246c:	00878713          	addi	a4,a5,8
  202470:	f8e43023          	sd	a4,-128(s0)
  202474:	639c                	ld	a5,0(a5)
  202476:	a801                	j	202486 <_vsnprintf+0x1d6>
  202478:	f8043783          	ld	a5,-128(s0)
  20247c:	00878713          	addi	a4,a5,8
  202480:	f8e43023          	sd	a4,-128(s0)
  202484:	439c                	lw	a5,0(a5)
  202486:	fcf43823          	sd	a5,-48(s0)
				if (num < 0) {
  20248a:	fd043783          	ld	a5,-48(s0)
  20248e:	0207df63          	bgez	a5,2024cc <_vsnprintf+0x21c>
					num = -num;
  202492:	fd043783          	ld	a5,-48(s0)
  202496:	40f007b3          	neg	a5,a5
  20249a:	fcf43823          	sd	a5,-48(s0)
					if (out && pos < n) {
  20249e:	f9843783          	ld	a5,-104(s0)
  2024a2:	c385                	beqz	a5,2024c2 <_vsnprintf+0x212>
  2024a4:	fe043703          	ld	a4,-32(s0)
  2024a8:	f9043783          	ld	a5,-112(s0)
  2024ac:	00f77b63          	bgeu	a4,a5,2024c2 <_vsnprintf+0x212>
						out[pos] = '-';
  2024b0:	f9843703          	ld	a4,-104(s0)
  2024b4:	fe043783          	ld	a5,-32(s0)
  2024b8:	97ba                	add	a5,a5,a4
  2024ba:	02d00713          	li	a4,45
  2024be:	00e78023          	sb	a4,0(a5)
					}
					pos++;
  2024c2:	fe043783          	ld	a5,-32(s0)
  2024c6:	0785                	addi	a5,a5,1
  2024c8:	fef43023          	sd	a5,-32(s0)
				}
				long digits = 1;
  2024cc:	4785                	li	a5,1
  2024ce:	fcf43423          	sd	a5,-56(s0)
				for (long nn = num; nn /= 10; digits++);
  2024d2:	fd043783          	ld	a5,-48(s0)
  2024d6:	fcf43023          	sd	a5,-64(s0)
  2024da:	a031                	j	2024e6 <_vsnprintf+0x236>
  2024dc:	fc843783          	ld	a5,-56(s0)
  2024e0:	0785                	addi	a5,a5,1
  2024e2:	fcf43423          	sd	a5,-56(s0)
  2024e6:	fc043503          	ld	a0,-64(s0)
  2024ea:	d9bff0ef          	jal	ra,202284 <div10>
  2024ee:	fca43023          	sd	a0,-64(s0)
  2024f2:	fc043783          	ld	a5,-64(s0)
  2024f6:	f3fd                	bnez	a5,2024dc <_vsnprintf+0x22c>
				for (int i = digits-1; i >= 0; i--) {
  2024f8:	fc843783          	ld	a5,-56(s0)
  2024fc:	2781                	sext.w	a5,a5
  2024fe:	37fd                	addiw	a5,a5,-1
  202500:	2781                	sext.w	a5,a5
  202502:	faf42e23          	sw	a5,-68(s0)
  202506:	a8a9                	j	202560 <_vsnprintf+0x2b0>
					if (out && pos + i < n) {
  202508:	f9843783          	ld	a5,-104(s0)
  20250c:	cf9d                	beqz	a5,20254a <_vsnprintf+0x29a>
  20250e:	fbc42703          	lw	a4,-68(s0)
  202512:	fe043783          	ld	a5,-32(s0)
  202516:	97ba                	add	a5,a5,a4
  202518:	f9043703          	ld	a4,-112(s0)
  20251c:	02e7f763          	bgeu	a5,a4,20254a <_vsnprintf+0x29a>
						out[pos + i] = '0' + num % 10;
  202520:	fd043503          	ld	a0,-48(s0)
  202524:	cffff0ef          	jal	ra,202222 <mod10>
  202528:	87aa                	mv	a5,a0
  20252a:	0ff7f713          	andi	a4,a5,255
  20252e:	fbc42683          	lw	a3,-68(s0)
  202532:	fe043783          	ld	a5,-32(s0)
  202536:	97b6                	add	a5,a5,a3
  202538:	f9843683          	ld	a3,-104(s0)
  20253c:	97b6                	add	a5,a5,a3
  20253e:	0307071b          	addiw	a4,a4,48
  202542:	0ff77713          	andi	a4,a4,255
  202546:	00e78023          	sb	a4,0(a5)
					}
					num /= 10;
  20254a:	fd043503          	ld	a0,-48(s0)
  20254e:	d37ff0ef          	jal	ra,202284 <div10>
  202552:	fca43823          	sd	a0,-48(s0)
				for (int i = digits-1; i >= 0; i--) {
  202556:	fbc42783          	lw	a5,-68(s0)
  20255a:	37fd                	addiw	a5,a5,-1
  20255c:	faf42e23          	sw	a5,-68(s0)
  202560:	fbc42783          	lw	a5,-68(s0)
  202564:	2781                	sext.w	a5,a5
  202566:	fa07d1e3          	bgez	a5,202508 <_vsnprintf+0x258>
				}
				pos += digits;
  20256a:	fc843783          	ld	a5,-56(s0)
  20256e:	fe043703          	ld	a4,-32(s0)
  202572:	97ba                	add	a5,a5,a4
  202574:	fef43023          	sd	a5,-32(s0)
				longarg = 0;
  202578:	fe042423          	sw	zero,-24(s0)
				format = 0;
  20257c:	fe042623          	sw	zero,-20(s0)
				break;
  202580:	a8f5                	j	20267c <_vsnprintf+0x3cc>
			}
			case 's': {
				const char* s2 = va_arg(vl, const char*);
  202582:	f8043783          	ld	a5,-128(s0)
  202586:	00878713          	addi	a4,a5,8
  20258a:	f8e43023          	sd	a4,-128(s0)
  20258e:	639c                	ld	a5,0(a5)
  202590:	faf43823          	sd	a5,-80(s0)
				while (*s2) {
  202594:	a83d                	j	2025d2 <_vsnprintf+0x322>
					if (out && pos < n) {
  202596:	f9843783          	ld	a5,-104(s0)
  20259a:	c395                	beqz	a5,2025be <_vsnprintf+0x30e>
  20259c:	fe043703          	ld	a4,-32(s0)
  2025a0:	f9043783          	ld	a5,-112(s0)
  2025a4:	00f77d63          	bgeu	a4,a5,2025be <_vsnprintf+0x30e>
						out[pos] = *s2;
  2025a8:	f9843703          	ld	a4,-104(s0)
  2025ac:	fe043783          	ld	a5,-32(s0)
  2025b0:	97ba                	add	a5,a5,a4
  2025b2:	fb043703          	ld	a4,-80(s0)
  2025b6:	00074703          	lbu	a4,0(a4)
  2025ba:	00e78023          	sb	a4,0(a5)
					}
					pos++;
  2025be:	fe043783          	ld	a5,-32(s0)
  2025c2:	0785                	addi	a5,a5,1
  2025c4:	fef43023          	sd	a5,-32(s0)
					s2++;
  2025c8:	fb043783          	ld	a5,-80(s0)
  2025cc:	0785                	addi	a5,a5,1
  2025ce:	faf43823          	sd	a5,-80(s0)
				while (*s2) {
  2025d2:	fb043783          	ld	a5,-80(s0)
  2025d6:	0007c783          	lbu	a5,0(a5)
  2025da:	ffd5                	bnez	a5,202596 <_vsnprintf+0x2e6>
				}
				longarg = 0;
  2025dc:	fe042423          	sw	zero,-24(s0)
				format = 0;
  2025e0:	fe042623          	sw	zero,-20(s0)
				break;
  2025e4:	a861                	j	20267c <_vsnprintf+0x3cc>
			}
			case 'c': {
				if (out && pos < n) {
  2025e6:	f9843783          	ld	a5,-104(s0)
  2025ea:	c79d                	beqz	a5,202618 <_vsnprintf+0x368>
  2025ec:	fe043703          	ld	a4,-32(s0)
  2025f0:	f9043783          	ld	a5,-112(s0)
  2025f4:	02f77263          	bgeu	a4,a5,202618 <_vsnprintf+0x368>
					out[pos] = (char)va_arg(vl,int);
  2025f8:	f8043783          	ld	a5,-128(s0)
  2025fc:	00878713          	addi	a4,a5,8
  202600:	f8e43023          	sd	a4,-128(s0)
  202604:	4394                	lw	a3,0(a5)
  202606:	f9843703          	ld	a4,-104(s0)
  20260a:	fe043783          	ld	a5,-32(s0)
  20260e:	97ba                	add	a5,a5,a4
  202610:	0ff6f713          	andi	a4,a3,255
  202614:	00e78023          	sb	a4,0(a5)
				}
				pos++;
  202618:	fe043783          	ld	a5,-32(s0)
  20261c:	0785                	addi	a5,a5,1
  20261e:	fef43023          	sd	a5,-32(s0)
				longarg = 0;
  202622:	fe042423          	sw	zero,-24(s0)
				format = 0;
  202626:	fe042623          	sw	zero,-20(s0)
				break;
  20262a:	a889                	j	20267c <_vsnprintf+0x3cc>
			}
			default:
				break;
			}
		} else if (*s == '%') {
  20262c:	f8843783          	ld	a5,-120(s0)
  202630:	0007c783          	lbu	a5,0(a5)
  202634:	873e                	mv	a4,a5
  202636:	02500793          	li	a5,37
  20263a:	00f71663          	bne	a4,a5,202646 <_vsnprintf+0x396>
			format = 1;
  20263e:	4785                	li	a5,1
  202640:	fef42623          	sw	a5,-20(s0)
  202644:	a825                	j	20267c <_vsnprintf+0x3cc>
		} else {
			if (out && pos < n) {
  202646:	f9843783          	ld	a5,-104(s0)
  20264a:	c395                	beqz	a5,20266e <_vsnprintf+0x3be>
  20264c:	fe043703          	ld	a4,-32(s0)
  202650:	f9043783          	ld	a5,-112(s0)
  202654:	00f77d63          	bgeu	a4,a5,20266e <_vsnprintf+0x3be>
				out[pos] = *s;
  202658:	f9843703          	ld	a4,-104(s0)
  20265c:	fe043783          	ld	a5,-32(s0)
  202660:	97ba                	add	a5,a5,a4
  202662:	f8843703          	ld	a4,-120(s0)
  202666:	00074703          	lbu	a4,0(a4)
  20266a:	00e78023          	sb	a4,0(a5)
			}
			pos++;
  20266e:	fe043783          	ld	a5,-32(s0)
  202672:	0785                	addi	a5,a5,1
  202674:	fef43023          	sd	a5,-32(s0)
  202678:	a011                	j	20267c <_vsnprintf+0x3cc>
				break;
  20267a:	0001                	nop
	for (; *s; s++) {
  20267c:	f8843783          	ld	a5,-120(s0)
  202680:	0785                	addi	a5,a5,1
  202682:	f8f43423          	sd	a5,-120(s0)
  202686:	f8843783          	ld	a5,-120(s0)
  20268a:	0007c783          	lbu	a5,0(a5)
  20268e:	c40794e3          	bnez	a5,2022d6 <_vsnprintf+0x26>
		}
    	}
	if (out && pos < n) {
  202692:	f9843783          	ld	a5,-104(s0)
  202696:	cf99                	beqz	a5,2026b4 <_vsnprintf+0x404>
  202698:	fe043703          	ld	a4,-32(s0)
  20269c:	f9043783          	ld	a5,-112(s0)
  2026a0:	00f77a63          	bgeu	a4,a5,2026b4 <_vsnprintf+0x404>
		out[pos] = 0;
  2026a4:	f9843703          	ld	a4,-104(s0)
  2026a8:	fe043783          	ld	a5,-32(s0)
  2026ac:	97ba                	add	a5,a5,a4
  2026ae:	00078023          	sb	zero,0(a5)
  2026b2:	a839                	j	2026d0 <_vsnprintf+0x420>
	} else if (out && n) {
  2026b4:	f9843783          	ld	a5,-104(s0)
  2026b8:	cf81                	beqz	a5,2026d0 <_vsnprintf+0x420>
  2026ba:	f9043783          	ld	a5,-112(s0)
  2026be:	cb89                	beqz	a5,2026d0 <_vsnprintf+0x420>
		out[n-1] = 0;
  2026c0:	f9043783          	ld	a5,-112(s0)
  2026c4:	17fd                	addi	a5,a5,-1
  2026c6:	f9843703          	ld	a4,-104(s0)
  2026ca:	97ba                	add	a5,a5,a4
  2026cc:	00078023          	sb	zero,0(a5)
	}
	return pos;
  2026d0:	fe043783          	ld	a5,-32(s0)
  2026d4:	2781                	sext.w	a5,a5
}
  2026d6:	853e                	mv	a0,a5
  2026d8:	70e6                	ld	ra,120(sp)
  2026da:	7446                	ld	s0,112(sp)
  2026dc:	6109                	addi	sp,sp,128
  2026de:	8082                	ret

00000000002026e0 <_vprintf>:

static char out_buf[1000]; // buffer for _vprintf()

static int _vprintf(const char* s, va_list vl)
{
  2026e0:	7179                	addi	sp,sp,-48
  2026e2:	f406                	sd	ra,40(sp)
  2026e4:	f022                	sd	s0,32(sp)
  2026e6:	1800                	addi	s0,sp,48
  2026e8:	fca43c23          	sd	a0,-40(s0)
  2026ec:	fcb43823          	sd	a1,-48(s0)
	int res = _vsnprintf(NULL, -1, s, vl);
  2026f0:	fd043683          	ld	a3,-48(s0)
  2026f4:	fd843603          	ld	a2,-40(s0)
  2026f8:	55fd                	li	a1,-1
  2026fa:	4501                	li	a0,0
  2026fc:	bb5ff0ef          	jal	ra,2022b0 <_vsnprintf>
  202700:	87aa                	mv	a5,a0
  202702:	fef42623          	sw	a5,-20(s0)
	if (res+1 >= sizeof(out_buf)) {
  202706:	fec42783          	lw	a5,-20(s0)
  20270a:	2785                	addiw	a5,a5,1
  20270c:	2781                	sext.w	a5,a5
  20270e:	2781                	sext.w	a5,a5
  202710:	873e                	mv	a4,a5
  202712:	3e700793          	li	a5,999
  202716:	00e7f963          	bgeu	a5,a4,202728 <_vprintf+0x48>
		uart_puts("error: output string size overflow\n\r");
  20271a:	00003517          	auipc	a0,0x3
  20271e:	9ae50513          	addi	a0,a0,-1618 # 2050c8 <BSS_END+0x60>
  202722:	241000ef          	jal	ra,203162 <uart_puts>
		while(1) {}
  202726:	a001                	j	202726 <_vprintf+0x46>
	}
	_vsnprintf(out_buf, res + 1, s, vl);
  202728:	fec42783          	lw	a5,-20(s0)
  20272c:	2785                	addiw	a5,a5,1
  20272e:	2781                	sext.w	a5,a5
  202730:	fd043683          	ld	a3,-48(s0)
  202734:	fd843603          	ld	a2,-40(s0)
  202738:	85be                	mv	a1,a5
  20273a:	00004517          	auipc	a0,0x4
  20273e:	90e50513          	addi	a0,a0,-1778 # 206048 <out_buf>
  202742:	b6fff0ef          	jal	ra,2022b0 <_vsnprintf>
	uart_puts(out_buf);
  202746:	00004517          	auipc	a0,0x4
  20274a:	90250513          	addi	a0,a0,-1790 # 206048 <out_buf>
  20274e:	215000ef          	jal	ra,203162 <uart_puts>
	return res;
  202752:	fec42783          	lw	a5,-20(s0)
}
  202756:	853e                	mv	a0,a5
  202758:	70a2                	ld	ra,40(sp)
  20275a:	7402                	ld	s0,32(sp)
  20275c:	6145                	addi	sp,sp,48
  20275e:	8082                	ret

0000000000202760 <printf>:

int printf(const char* s, ...)
{
  202760:	7159                	addi	sp,sp,-112
  202762:	f406                	sd	ra,40(sp)
  202764:	f022                	sd	s0,32(sp)
  202766:	1800                	addi	s0,sp,48
  202768:	fca43c23          	sd	a0,-40(s0)
  20276c:	e40c                	sd	a1,8(s0)
  20276e:	e810                	sd	a2,16(s0)
  202770:	ec14                	sd	a3,24(s0)
  202772:	f018                	sd	a4,32(s0)
  202774:	f41c                	sd	a5,40(s0)
  202776:	03043823          	sd	a6,48(s0)
  20277a:	03143c23          	sd	a7,56(s0)
	int res = 0;
  20277e:	fe042623          	sw	zero,-20(s0)
	va_list vl;
	va_start(vl, s);
  202782:	04040793          	addi	a5,s0,64
  202786:	fc878793          	addi	a5,a5,-56
  20278a:	fef43023          	sd	a5,-32(s0)
	res = _vprintf(s, vl);
  20278e:	fe043783          	ld	a5,-32(s0)
  202792:	85be                	mv	a1,a5
  202794:	fd843503          	ld	a0,-40(s0)
  202798:	f49ff0ef          	jal	ra,2026e0 <_vprintf>
  20279c:	87aa                	mv	a5,a0
  20279e:	fef42623          	sw	a5,-20(s0)
	va_end(vl);
	return res;
  2027a2:	fec42783          	lw	a5,-20(s0)
}
  2027a6:	853e                	mv	a0,a5
  2027a8:	70a2                	ld	ra,40(sp)
  2027aa:	7402                	ld	s0,32(sp)
  2027ac:	6165                	addi	sp,sp,112
  2027ae:	8082                	ret

00000000002027b0 <panic>:

void panic(char *s)
{
  2027b0:	1101                	addi	sp,sp,-32
  2027b2:	ec06                	sd	ra,24(sp)
  2027b4:	e822                	sd	s0,16(sp)
  2027b6:	1000                	addi	s0,sp,32
  2027b8:	fea43423          	sd	a0,-24(s0)
	printf("panic: ");
  2027bc:	00003517          	auipc	a0,0x3
  2027c0:	93450513          	addi	a0,a0,-1740 # 2050f0 <BSS_END+0x88>
  2027c4:	f9dff0ef          	jal	ra,202760 <printf>
	printf(s);
  2027c8:	fe843503          	ld	a0,-24(s0)
  2027cc:	f95ff0ef          	jal	ra,202760 <printf>
	printf("\n\r");
  2027d0:	00003517          	auipc	a0,0x3
  2027d4:	92850513          	addi	a0,a0,-1752 # 2050f8 <BSS_END+0x90>
  2027d8:	f89ff0ef          	jal	ra,202760 <printf>
	while(1){};
  2027dc:	a001                	j	2027dc <panic+0x2c>

00000000002027de <w_mscratch>:
#include "types.h"

/* 
 *  register operation of multi-task.
 */
static void w_mscratch(reg_t x){
  2027de:	1101                	addi	sp,sp,-32
  2027e0:	ec22                	sd	s0,24(sp)
  2027e2:	1000                	addi	s0,sp,32
  2027e4:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  2027e8:	fe843783          	ld	a5,-24(s0)
  2027ec:	34079073          	csrw	mscratch,a5
}
  2027f0:	0001                	nop
  2027f2:	6462                	ld	s0,24(sp)
  2027f4:	6105                	addi	sp,sp,32
  2027f6:	8082                	ret

00000000002027f8 <r_mscratch>:

static reg_t r_mscratch(){
  2027f8:	1101                	addi	sp,sp,-32
  2027fa:	ec22                	sd	s0,24(sp)
  2027fc:	1000                	addi	s0,sp,32
	reg_t ret;
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  2027fe:	340027f3          	csrr	a5,mscratch
  202802:	fef43423          	sd	a5,-24(s0)
	return ret;
  202806:	fe843783          	ld	a5,-24(s0)
}
  20280a:	853e                	mv	a0,a5
  20280c:	6462                	ld	s0,24(sp)
  20280e:	6105                	addi	sp,sp,32
  202810:	8082                	ret

0000000000202812 <r_mhartid>:
}
//tp register stand for the index of the current hart.
//similar with r_mhartid below.but i dont know whats the difference


static inline reg_t r_mhartid(){
  202812:	1101                	addi	sp,sp,-32
  202814:	ec22                	sd	s0,24(sp)
  202816:	1000                	addi	s0,sp,32
	reg_t x;
	asm volatile("csrr %0, mhartid" : "=r" (x) );
  202818:	f14027f3          	csrr	a5,mhartid
  20281c:	fef43423          	sd	a5,-24(s0)
	return x;
  202820:	fe843783          	ld	a5,-24(s0)
}
  202824:	853e                	mv	a0,a5
  202826:	6462                	ld	s0,24(sp)
  202828:	6105                	addi	sp,sp,32
  20282a:	8082                	ret

000000000020282c <r_time>:
{
	reg_t x;
	asm volatile("csrr %0, mcause" : "=r" (x) );
	return x;
}
static inline reg_t r_time(){
  20282c:	1101                	addi	sp,sp,-32
  20282e:	ec22                	sd	s0,24(sp)
  202830:	1000                	addi	s0,sp,32
	reg_t ret;
	asm volatile("csrr %0, time" : "=r" (ret)); 
  202832:	c01027f3          	rdtime	a5
  202836:	fef43423          	sd	a5,-24(s0)
	return ret;
  20283a:	fe843783          	ld	a5,-24(s0)
}
  20283e:	853e                	mv	a0,a5
  202840:	6462                	ld	s0,24(sp)
  202842:	6105                	addi	sp,sp,32
  202844:	8082                	ret

0000000000202846 <r_mtimecmp>:
static inline void w_msip(int hartid, int x){
	*(uint32_t*)CLINT_MSIP(hartid) = x;
}

static inline reg_t r_mtimecmp(){
  202846:	1101                	addi	sp,sp,-32
  202848:	ec06                	sd	ra,24(sp)
  20284a:	e822                	sd	s0,16(sp)
  20284c:	1000                	addi	s0,sp,32
	reg_t hartid = r_mhartid();
  20284e:	fc5ff0ef          	jal	ra,202812 <r_mhartid>
  202852:	fea43423          	sd	a0,-24(s0)
	return (((uint64_t)*(uint32_t*)CLINT_MTIMECMPH(hartid)) << 32) + ((uint64_t)*(uint32_t*)CLINT_MTIMECMPL(hartid));
  202856:	fe843703          	ld	a4,-24(s0)
  20285a:	03ff77b7          	lui	a5,0x3ff7
  20285e:	0785                	addi	a5,a5,1
  202860:	07ae                	slli	a5,a5,0xb
  202862:	97ba                	add	a5,a5,a4
  202864:	078e                	slli	a5,a5,0x3
  202866:	0791                	addi	a5,a5,4
  202868:	439c                	lw	a5,0(a5)
  20286a:	1782                	slli	a5,a5,0x20
  20286c:	9381                	srli	a5,a5,0x20
  20286e:	02079713          	slli	a4,a5,0x20
  202872:	fe843683          	ld	a3,-24(s0)
  202876:	03ff77b7          	lui	a5,0x3ff7
  20287a:	0785                	addi	a5,a5,1
  20287c:	07ae                	slli	a5,a5,0xb
  20287e:	97b6                	add	a5,a5,a3
  202880:	078e                	slli	a5,a5,0x3
  202882:	439c                	lw	a5,0(a5)
  202884:	1782                	slli	a5,a5,0x20
  202886:	9381                	srli	a5,a5,0x20
  202888:	97ba                	add	a5,a5,a4
}
  20288a:	853e                	mv	a0,a5
  20288c:	60e2                	ld	ra,24(sp)
  20288e:	6442                	ld	s0,16(sp)
  202890:	6105                	addi	sp,sp,32
  202892:	8082                	ret

0000000000202894 <get_time>:

void timer_handler();

void newpriority();

static uint64_t get_time(){
  202894:	1141                	addi	sp,sp,-16
  202896:	e422                	sd	s0,8(sp)
  202898:	0800                	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  20289a:	00004797          	auipc	a5,0x4
  20289e:	b9678793          	addi	a5,a5,-1130 # 206430 <_tick>
  2028a2:	6398                	ld	a4,0(a5)
  2028a4:	03c00793          	li	a5,60
  2028a8:	02f757b3          	divu	a5,a4,a5
}
  2028ac:	853e                	mv	a0,a5
  2028ae:	6422                	ld	s0,8(sp)
  2028b0:	0141                	addi	sp,sp,16
  2028b2:	8082                	ret

00000000002028b4 <get_time_str>:

static void get_time_str(char* time){
  2028b4:	7139                	addi	sp,sp,-64
  2028b6:	fc22                	sd	s0,56(sp)
  2028b8:	0080                	addi	s0,sp,64
  2028ba:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  2028be:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  2028c2:	00004797          	auipc	a5,0x4
  2028c6:	b6e78793          	addi	a5,a5,-1170 # 206430 <_tick>
  2028ca:	6398                	ld	a4,0(a5)
  2028cc:	03c00793          	li	a5,60
  2028d0:	02f757b3          	divu	a5,a4,a5
  2028d4:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  2028d8:	fe043703          	ld	a4,-32(s0)
  2028dc:	6785                	lui	a5,0x1
  2028de:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2028e2:	02f757b3          	divu	a5,a4,a5
  2028e6:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  2028ea:	fdf44703          	lbu	a4,-33(s0)
  2028ee:	06400793          	li	a5,100
  2028f2:	02f777bb          	remuw	a5,a4,a5
  2028f6:	0ff7f793          	andi	a5,a5,255
  2028fa:	873e                	mv	a4,a5
  2028fc:	47a9                	li	a5,10
  2028fe:	02f757bb          	divuw	a5,a4,a5
  202902:	0ff7f793          	andi	a5,a5,255
  202906:	0307879b          	addiw	a5,a5,48
  20290a:	0ff7f713          	andi	a4,a5,255
  20290e:	fc843783          	ld	a5,-56(s0)
  202912:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  202916:	fdf44703          	lbu	a4,-33(s0)
  20291a:	47a9                	li	a5,10
  20291c:	02f777bb          	remuw	a5,a4,a5
  202920:	0ff7f713          	andi	a4,a5,255
  202924:	fc843783          	ld	a5,-56(s0)
  202928:	0785                	addi	a5,a5,1
  20292a:	0307071b          	addiw	a4,a4,48
  20292e:	0ff77713          	andi	a4,a4,255
  202932:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  202936:	fc843783          	ld	a5,-56(s0)
  20293a:	0789                	addi	a5,a5,2
  20293c:	03a00713          	li	a4,58
  202940:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  202944:	fe043703          	ld	a4,-32(s0)
  202948:	6785                	lui	a5,0x1
  20294a:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  20294e:	02f77733          	remu	a4,a4,a5
  202952:	03c00793          	li	a5,60
  202956:	02f757b3          	divu	a5,a4,a5
  20295a:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  20295e:	fdf44703          	lbu	a4,-33(s0)
  202962:	47a9                	li	a5,10
  202964:	02f757bb          	divuw	a5,a4,a5
  202968:	0ff7f713          	andi	a4,a5,255
  20296c:	fc843783          	ld	a5,-56(s0)
  202970:	078d                	addi	a5,a5,3
  202972:	0307071b          	addiw	a4,a4,48
  202976:	0ff77713          	andi	a4,a4,255
  20297a:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  20297e:	fdf44703          	lbu	a4,-33(s0)
  202982:	47a9                	li	a5,10
  202984:	02f777bb          	remuw	a5,a4,a5
  202988:	0ff7f713          	andi	a4,a5,255
  20298c:	fc843783          	ld	a5,-56(s0)
  202990:	0791                	addi	a5,a5,4
  202992:	0307071b          	addiw	a4,a4,48
  202996:	0ff77713          	andi	a4,a4,255
  20299a:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  20299e:	fc843783          	ld	a5,-56(s0)
  2029a2:	0795                	addi	a5,a5,5
  2029a4:	03a00713          	li	a4,58
  2029a8:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  2029ac:	fe043703          	ld	a4,-32(s0)
  2029b0:	03c00793          	li	a5,60
  2029b4:	02f777b3          	remu	a5,a4,a5
  2029b8:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  2029bc:	fdf44703          	lbu	a4,-33(s0)
  2029c0:	47a9                	li	a5,10
  2029c2:	02f757bb          	divuw	a5,a4,a5
  2029c6:	0ff7f713          	andi	a4,a5,255
  2029ca:	fc843783          	ld	a5,-56(s0)
  2029ce:	0799                	addi	a5,a5,6
  2029d0:	0307071b          	addiw	a4,a4,48
  2029d4:	0ff77713          	andi	a4,a4,255
  2029d8:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  2029dc:	fdf44703          	lbu	a4,-33(s0)
  2029e0:	47a9                	li	a5,10
  2029e2:	02f777bb          	remuw	a5,a4,a5
  2029e6:	0ff7f713          	andi	a4,a5,255
  2029ea:	fc843783          	ld	a5,-56(s0)
  2029ee:	079d                	addi	a5,a5,7
  2029f0:	0307071b          	addiw	a4,a4,48
  2029f4:	0ff77713          	andi	a4,a4,255
  2029f8:	00e78023          	sb	a4,0(a5)

}
  2029fc:	0001                	nop
  2029fe:	7462                	ld	s0,56(sp)
  202a00:	6121                	addi	sp,sp,64
  202a02:	8082                	ret

0000000000202a04 <printmutex>:
#include "user.h"

#define DELAY 1000
struct mutex mymutex = {MUTEX_IS_FREE_FLAG};

void printmutex(struct mutex *m){
  202a04:	1101                	addi	sp,sp,-32
  202a06:	ec06                	sd	ra,24(sp)
  202a08:	e822                	sd	s0,16(sp)
  202a0a:	1000                	addi	s0,sp,32
  202a0c:	fea43423          	sd	a0,-24(s0)
	printf("mutex is release dadada:%d\n\r", m->flag);
  202a10:	fe843783          	ld	a5,-24(s0)
  202a14:	439c                	lw	a5,0(a5)
  202a16:	85be                	mv	a1,a5
  202a18:	00002517          	auipc	a0,0x2
  202a1c:	6e850513          	addi	a0,a0,1768 # 205100 <BSS_END+0x98>
  202a20:	d41ff0ef          	jal	ra,202760 <printf>
}
  202a24:	0001                	nop
  202a26:	60e2                	ld	ra,24(sp)
  202a28:	6442                	ld	s0,16(sp)
  202a2a:	6105                	addi	sp,sp,32
  202a2c:	8082                	ret

0000000000202a2e <user_task1>:
void user_task1(void* param)
{
  202a2e:	7179                	addi	sp,sp,-48
  202a30:	f406                	sd	ra,40(sp)
  202a32:	f022                	sd	s0,32(sp)
  202a34:	1800                	addi	s0,sp,48
  202a36:	fca43c23          	sd	a0,-40(s0)
	printf("\033[32mTask 1: Created!\033[0m\n\r");
  202a3a:	00002517          	auipc	a0,0x2
  202a3e:	6e650513          	addi	a0,a0,1766 # 205120 <BSS_END+0xb8>
  202a42:	d1fff0ef          	jal	ra,202760 <printf>
	while (1) {
		mutex_acquire(&mymutex);
  202a46:	00003517          	auipc	a0,0x3
  202a4a:	5fa50513          	addi	a0,a0,1530 # 206040 <mymutex>
  202a4e:	f96ff0ef          	jal	ra,2021e4 <mutex_acquire>
		printf("mutex is get:%d\n\r", mymutex.flag);
  202a52:	00003797          	auipc	a5,0x3
  202a56:	5ee78793          	addi	a5,a5,1518 # 206040 <mymutex>
  202a5a:	439c                	lw	a5,0(a5)
  202a5c:	85be                	mv	a1,a5
  202a5e:	00002517          	auipc	a0,0x2
  202a62:	6e250513          	addi	a0,a0,1762 # 205140 <BSS_END+0xd8>
  202a66:	cfbff0ef          	jal	ra,202760 <printf>
		for (int i=0; i < 5; i++){
  202a6a:	fe042623          	sw	zero,-20(s0)
  202a6e:	a825                	j	202aa6 <user_task1+0x78>
			reg_t mytime;
			get_MTIME(mytime);
  202a70:	c01027f3          	rdtime	a5
  202a74:	fef43023          	sd	a5,-32(s0)
			printf("\033[32mTask 1: Running...\033[0m\n\r");
  202a78:	00002517          	auipc	a0,0x2
  202a7c:	6e050513          	addi	a0,a0,1760 # 205158 <BSS_END+0xf0>
  202a80:	ce1ff0ef          	jal	ra,202760 <printf>
			printf("\033[32mCurrent time is:%d\033[0m\n\r", mytime);
  202a84:	fe043583          	ld	a1,-32(s0)
  202a88:	00002517          	auipc	a0,0x2
  202a8c:	6f050513          	addi	a0,a0,1776 # 205178 <BSS_END+0x110>
  202a90:	cd1ff0ef          	jal	ra,202760 <printf>
			task_delay(DELAY);
  202a94:	3e800513          	li	a0,1000
  202a98:	234010ef          	jal	ra,203ccc <task_delay>
		for (int i=0; i < 5; i++){
  202a9c:	fec42783          	lw	a5,-20(s0)
  202aa0:	2785                	addiw	a5,a5,1
  202aa2:	fef42623          	sw	a5,-20(s0)
  202aa6:	fec42783          	lw	a5,-20(s0)
  202aaa:	0007871b          	sext.w	a4,a5
  202aae:	4791                	li	a5,4
  202ab0:	fce7d0e3          	bge	a5,a4,202a70 <user_task1+0x42>
			printf("\033[K");
			printf("\033[1A");
			printf("\033[K");
			#endif
		}
		mutex_release(&mymutex);
  202ab4:	00003517          	auipc	a0,0x3
  202ab8:	58c50513          	addi	a0,a0,1420 # 206040 <mymutex>
  202abc:	f4cff0ef          	jal	ra,202208 <mutex_release>
		printf("mutex is released:%d\n\r", mymutex.flag);
  202ac0:	00003797          	auipc	a5,0x3
  202ac4:	58078793          	addi	a5,a5,1408 # 206040 <mymutex>
  202ac8:	439c                	lw	a5,0(a5)
  202aca:	85be                	mv	a1,a5
  202acc:	00002517          	auipc	a0,0x2
  202ad0:	6cc50513          	addi	a0,a0,1740 # 205198 <BSS_END+0x130>
  202ad4:	c8dff0ef          	jal	ra,202760 <printf>
		mutex_acquire(&mymutex);
  202ad8:	b7bd                	j	202a46 <user_task1+0x18>

0000000000202ada <user_task2>:
	}
}

void user_task2(void* param)
{
  202ada:	7179                	addi	sp,sp,-48
  202adc:	f406                	sd	ra,40(sp)
  202ade:	f022                	sd	s0,32(sp)
  202ae0:	1800                	addi	s0,sp,48
  202ae2:	fca43c23          	sd	a0,-40(s0)
	printf("\033[32mTask 2: Created!\033[0m\n\r");
  202ae6:	00002517          	auipc	a0,0x2
  202aea:	6ca50513          	addi	a0,a0,1738 # 2051b0 <BSS_END+0x148>
  202aee:	c73ff0ef          	jal	ra,202760 <printf>
	while (1) {
		mutex_acquire(&mymutex);
  202af2:	00003517          	auipc	a0,0x3
  202af6:	54e50513          	addi	a0,a0,1358 # 206040 <mymutex>
  202afa:	eeaff0ef          	jal	ra,2021e4 <mutex_acquire>
		printf("mutex is get:%d\n\r", mymutex.flag);
  202afe:	00003797          	auipc	a5,0x3
  202b02:	54278793          	addi	a5,a5,1346 # 206040 <mymutex>
  202b06:	439c                	lw	a5,0(a5)
  202b08:	85be                	mv	a1,a5
  202b0a:	00002517          	auipc	a0,0x2
  202b0e:	63650513          	addi	a0,a0,1590 # 205140 <BSS_END+0xd8>
  202b12:	c4fff0ef          	jal	ra,202760 <printf>
		for (int i=0; i < 5; i++){
  202b16:	fe042623          	sw	zero,-20(s0)
  202b1a:	a825                	j	202b52 <user_task2+0x78>
			printf("\033[32mTask 2: Running...\033[0m\n\r");
  202b1c:	00002517          	auipc	a0,0x2
  202b20:	6b450513          	addi	a0,a0,1716 # 2051d0 <BSS_END+0x168>
  202b24:	c3dff0ef          	jal	ra,202760 <printf>
			printf("\033[32mMy cmp is:%p\033[0m\n\r", *(uint64_t*)CLINT_MTIMECMP(0));
  202b28:	03ff77b7          	lui	a5,0x3ff7
  202b2c:	0785                	addi	a5,a5,1
  202b2e:	07ba                	slli	a5,a5,0xe
  202b30:	639c                	ld	a5,0(a5)
  202b32:	85be                	mv	a1,a5
  202b34:	00002517          	auipc	a0,0x2
  202b38:	6bc50513          	addi	a0,a0,1724 # 2051f0 <BSS_END+0x188>
  202b3c:	c25ff0ef          	jal	ra,202760 <printf>
			task_delay(DELAY);
  202b40:	3e800513          	li	a0,1000
  202b44:	188010ef          	jal	ra,203ccc <task_delay>
		for (int i=0; i < 5; i++){
  202b48:	fec42783          	lw	a5,-20(s0)
  202b4c:	2785                	addiw	a5,a5,1
  202b4e:	fef42623          	sw	a5,-20(s0)
  202b52:	fec42783          	lw	a5,-20(s0)
  202b56:	0007871b          	sext.w	a4,a5
  202b5a:	4791                	li	a5,4
  202b5c:	fce7d0e3          	bge	a5,a4,202b1c <user_task2+0x42>
			printf("\033[K");
			printf("\033[1A");
			printf("\033[K");
			#endif
		}
		mutex_release(&mymutex);
  202b60:	00003517          	auipc	a0,0x3
  202b64:	4e050513          	addi	a0,a0,1248 # 206040 <mymutex>
  202b68:	ea0ff0ef          	jal	ra,202208 <mutex_release>
		printf("mutex is released:%d\n\r", mymutex.flag);
  202b6c:	00003797          	auipc	a5,0x3
  202b70:	4d478793          	addi	a5,a5,1236 # 206040 <mymutex>
  202b74:	439c                	lw	a5,0(a5)
  202b76:	85be                	mv	a1,a5
  202b78:	00002517          	auipc	a0,0x2
  202b7c:	62050513          	addi	a0,a0,1568 # 205198 <BSS_END+0x130>
  202b80:	be1ff0ef          	jal	ra,202760 <printf>
		mutex_acquire(&mymutex);
  202b84:	b7bd                	j	202af2 <user_task2+0x18>

0000000000202b86 <user_task3>:
	}
}
void user_task3(void* param)
{
  202b86:	1101                	addi	sp,sp,-32
  202b88:	ec06                	sd	ra,24(sp)
  202b8a:	e822                	sd	s0,16(sp)
  202b8c:	1000                	addi	s0,sp,32
  202b8e:	fea43423          	sd	a0,-24(s0)
	printf("\033[32mTask 3: Created!\033[0m\n\r");
  202b92:	00002517          	auipc	a0,0x2
  202b96:	67650513          	addi	a0,a0,1654 # 205208 <BSS_END+0x1a0>
  202b9a:	bc7ff0ef          	jal	ra,202760 <printf>
	while (1) {
		printf("\033[32mTask 3: Running...\033[0m\n\r");
  202b9e:	00002517          	auipc	a0,0x2
  202ba2:	68a50513          	addi	a0,a0,1674 # 205228 <BSS_END+0x1c0>
  202ba6:	bbbff0ef          	jal	ra,202760 <printf>
		printf("\033[32mCurrent time is:%p\033[0m\n\r", r_time());
  202baa:	c83ff0ef          	jal	ra,20282c <r_time>
  202bae:	87aa                	mv	a5,a0
  202bb0:	85be                	mv	a1,a5
  202bb2:	00002517          	auipc	a0,0x2
  202bb6:	69650513          	addi	a0,a0,1686 # 205248 <BSS_END+0x1e0>
  202bba:	ba7ff0ef          	jal	ra,202760 <printf>
		printf("\033[32mMy cmp is:%p\033[0m\n\r", r_mtimecmp());
  202bbe:	c89ff0ef          	jal	ra,202846 <r_mtimecmp>
  202bc2:	87aa                	mv	a5,a0
  202bc4:	85be                	mv	a1,a5
  202bc6:	00002517          	auipc	a0,0x2
  202bca:	62a50513          	addi	a0,a0,1578 # 2051f0 <BSS_END+0x188>
  202bce:	b93ff0ef          	jal	ra,202760 <printf>
		task_delay(DELAY);
  202bd2:	3e800513          	li	a0,1000
  202bd6:	0f6010ef          	jal	ra,203ccc <task_delay>
		printf("\033[32mTask 3: Running...\033[0m\n\r");
  202bda:	b7d1                	j	202b9e <user_task3+0x18>

0000000000202bdc <user_task4>:
		#endif
	}
}

void user_task4(void* param)
{
  202bdc:	1101                	addi	sp,sp,-32
  202bde:	ec06                	sd	ra,24(sp)
  202be0:	e822                	sd	s0,16(sp)
  202be2:	1000                	addi	s0,sp,32
  202be4:	fea43423          	sd	a0,-24(s0)
	printf("\033[32mTask 4: Created!\033[0m\n\r");
  202be8:	00002517          	auipc	a0,0x2
  202bec:	68050513          	addi	a0,a0,1664 # 205268 <BSS_END+0x200>
  202bf0:	b71ff0ef          	jal	ra,202760 <printf>
	printf("\033[32mTask 4: Running...\033[0m\n\r");
  202bf4:	00002517          	auipc	a0,0x2
  202bf8:	69450513          	addi	a0,a0,1684 # 205288 <BSS_END+0x220>
  202bfc:	b65ff0ef          	jal	ra,202760 <printf>
	printf("\033[32mMy output is:%p\033[0m\n\r", param);
  202c00:	fe843583          	ld	a1,-24(s0)
  202c04:	00002517          	auipc	a0,0x2
  202c08:	6a450513          	addi	a0,a0,1700 # 2052a8 <BSS_END+0x240>
  202c0c:	b55ff0ef          	jal	ra,202760 <printf>
	task_delay(DELAY);
  202c10:	3e800513          	li	a0,1000
  202c14:	0b8010ef          	jal	ra,203ccc <task_delay>
	#endif
	#ifndef MYPRINT
	print_taskkilled();
	delete_taskkilled();
	#endif
	printf("\033[31mTask 4: Killed!\033[0m\n\r");
  202c18:	00002517          	auipc	a0,0x2
  202c1c:	6b050513          	addi	a0,a0,1712 # 2052c8 <BSS_END+0x260>
  202c20:	b41ff0ef          	jal	ra,202760 <printf>
	task_exit();
  202c24:	6bf000ef          	jal	ra,203ae2 <task_exit>
}
  202c28:	0001                	nop
  202c2a:	60e2                	ld	ra,24(sp)
  202c2c:	6442                	ld	s0,16(sp)
  202c2e:	6105                	addi	sp,sp,32
  202c30:	8082                	ret

0000000000202c32 <os_main>:

/* NOTICE: DON'T LOOP INFINITELY IN main() */
void os_main(void)
{
  202c32:	1141                	addi	sp,sp,-16
  202c34:	e406                	sd	ra,8(sp)
  202c36:	e022                	sd	s0,0(sp)
  202c38:	0800                	addi	s0,sp,16
	task_create(user_task1, (void*)0x123456789abcdef, 2);
  202c3a:	00002797          	auipc	a5,0x2
  202c3e:	6ae78793          	addi	a5,a5,1710 # 2052e8 <BSS_END+0x280>
  202c42:	639c                	ld	a5,0(a5)
  202c44:	4609                	li	a2,2
  202c46:	85be                	mv	a1,a5
  202c48:	00000517          	auipc	a0,0x0
  202c4c:	de650513          	addi	a0,a0,-538 # 202a2e <user_task1>
  202c50:	6cf000ef          	jal	ra,203b1e <task_create>
	task_create(user_task2, (void*)0xfedcba9876543210, 2);
  202c54:	00002797          	auipc	a5,0x2
  202c58:	69c78793          	addi	a5,a5,1692 # 2052f0 <BSS_END+0x288>
  202c5c:	639c                	ld	a5,0(a5)
  202c5e:	4609                	li	a2,2
  202c60:	85be                	mv	a1,a5
  202c62:	00000517          	auipc	a0,0x0
  202c66:	e7850513          	addi	a0,a0,-392 # 202ada <user_task2>
  202c6a:	6b5000ef          	jal	ra,203b1e <task_create>
	task_create(user_task3, (void*)0xdeadbeefbeefdead, 2);
  202c6e:	00002797          	auipc	a5,0x2
  202c72:	68a78793          	addi	a5,a5,1674 # 2052f8 <BSS_END+0x290>
  202c76:	639c                	ld	a5,0(a5)
  202c78:	4609                	li	a2,2
  202c7a:	85be                	mv	a1,a5
  202c7c:	00000517          	auipc	a0,0x0
  202c80:	f0a50513          	addi	a0,a0,-246 # 202b86 <user_task3>
  202c84:	69b000ef          	jal	ra,203b1e <task_create>
	task_create(user_task4, (void*)0xdeadbeefbeefdead, 1);
  202c88:	00002797          	auipc	a5,0x2
  202c8c:	67078793          	addi	a5,a5,1648 # 2052f8 <BSS_END+0x290>
  202c90:	639c                	ld	a5,0(a5)
  202c92:	4605                	li	a2,1
  202c94:	85be                	mv	a1,a5
  202c96:	00000517          	auipc	a0,0x0
  202c9a:	f4650513          	addi	a0,a0,-186 # 202bdc <user_task4>
  202c9e:	681000ef          	jal	ra,203b1e <task_create>
}
  202ca2:	0001                	nop
  202ca4:	60a2                	ld	ra,8(sp)
  202ca6:	6402                	ld	s0,0(sp)
  202ca8:	0141                	addi	sp,sp,16
  202caa:	8082                	ret

0000000000202cac <w_mscratch>:
static void w_mscratch(reg_t x){
  202cac:	1101                	addi	sp,sp,-32
  202cae:	ec22                	sd	s0,24(sp)
  202cb0:	1000                	addi	s0,sp,32
  202cb2:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  202cb6:	fe843783          	ld	a5,-24(s0)
  202cba:	34079073          	csrw	mscratch,a5
}
  202cbe:	0001                	nop
  202cc0:	6462                	ld	s0,24(sp)
  202cc2:	6105                	addi	sp,sp,32
  202cc4:	8082                	ret

0000000000202cc6 <r_mscratch>:
static reg_t r_mscratch(){
  202cc6:	1101                	addi	sp,sp,-32
  202cc8:	ec22                	sd	s0,24(sp)
  202cca:	1000                	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  202ccc:	340027f3          	csrr	a5,mscratch
  202cd0:	fef43423          	sd	a5,-24(s0)
	return ret;
  202cd4:	fe843783          	ld	a5,-24(s0)
}
  202cd8:	853e                	mv	a0,a5
  202cda:	6462                	ld	s0,24(sp)
  202cdc:	6105                	addi	sp,sp,32
  202cde:	8082                	ret

0000000000202ce0 <r_mtval>:
static inline reg_t r_mtval(){
  202ce0:	1101                	addi	sp,sp,-32
  202ce2:	ec22                	sd	s0,24(sp)
  202ce4:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mtval" : "=r" (ret));
  202ce6:	343027f3          	csrr	a5,mtval
  202cea:	fef43423          	sd	a5,-24(s0)
	return ret;
  202cee:	fe843783          	ld	a5,-24(s0)
}
  202cf2:	853e                	mv	a0,a5
  202cf4:	6462                	ld	s0,24(sp)
  202cf6:	6105                	addi	sp,sp,32
  202cf8:	8082                	ret

0000000000202cfa <w_mtvec>:
static inline void w_mtvec(reg_t x){
  202cfa:	1101                	addi	sp,sp,-32
  202cfc:	ec22                	sd	s0,24(sp)
  202cfe:	1000                	addi	s0,sp,32
  202d00:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw   mtvec, %0" :  :"r" (x):);
  202d04:	fe843783          	ld	a5,-24(s0)
  202d08:	30579073          	csrw	mtvec,a5
}
  202d0c:	0001                	nop
  202d0e:	6462                	ld	s0,24(sp)
  202d10:	6105                	addi	sp,sp,32
  202d12:	8082                	ret

0000000000202d14 <get_time>:
static uint64_t get_time(){
  202d14:	1141                	addi	sp,sp,-16
  202d16:	e422                	sd	s0,8(sp)
  202d18:	0800                	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  202d1a:	00003797          	auipc	a5,0x3
  202d1e:	73678793          	addi	a5,a5,1846 # 206450 <_tick>
  202d22:	6398                	ld	a4,0(a5)
  202d24:	03c00793          	li	a5,60
  202d28:	02f757b3          	divu	a5,a4,a5
}
  202d2c:	853e                	mv	a0,a5
  202d2e:	6422                	ld	s0,8(sp)
  202d30:	0141                	addi	sp,sp,16
  202d32:	8082                	ret

0000000000202d34 <get_time_str>:
static void get_time_str(char* time){
  202d34:	7139                	addi	sp,sp,-64
  202d36:	fc22                	sd	s0,56(sp)
  202d38:	0080                	addi	s0,sp,64
  202d3a:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  202d3e:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  202d42:	00003797          	auipc	a5,0x3
  202d46:	70e78793          	addi	a5,a5,1806 # 206450 <_tick>
  202d4a:	6398                	ld	a4,0(a5)
  202d4c:	03c00793          	li	a5,60
  202d50:	02f757b3          	divu	a5,a4,a5
  202d54:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  202d58:	fe043703          	ld	a4,-32(s0)
  202d5c:	6785                	lui	a5,0x1
  202d5e:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  202d62:	02f757b3          	divu	a5,a4,a5
  202d66:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  202d6a:	fdf44703          	lbu	a4,-33(s0)
  202d6e:	06400793          	li	a5,100
  202d72:	02f777bb          	remuw	a5,a4,a5
  202d76:	0ff7f793          	andi	a5,a5,255
  202d7a:	873e                	mv	a4,a5
  202d7c:	47a9                	li	a5,10
  202d7e:	02f757bb          	divuw	a5,a4,a5
  202d82:	0ff7f793          	andi	a5,a5,255
  202d86:	0307879b          	addiw	a5,a5,48
  202d8a:	0ff7f713          	andi	a4,a5,255
  202d8e:	fc843783          	ld	a5,-56(s0)
  202d92:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  202d96:	fdf44703          	lbu	a4,-33(s0)
  202d9a:	47a9                	li	a5,10
  202d9c:	02f777bb          	remuw	a5,a4,a5
  202da0:	0ff7f713          	andi	a4,a5,255
  202da4:	fc843783          	ld	a5,-56(s0)
  202da8:	0785                	addi	a5,a5,1
  202daa:	0307071b          	addiw	a4,a4,48
  202dae:	0ff77713          	andi	a4,a4,255
  202db2:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  202db6:	fc843783          	ld	a5,-56(s0)
  202dba:	0789                	addi	a5,a5,2
  202dbc:	03a00713          	li	a4,58
  202dc0:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  202dc4:	fe043703          	ld	a4,-32(s0)
  202dc8:	6785                	lui	a5,0x1
  202dca:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  202dce:	02f77733          	remu	a4,a4,a5
  202dd2:	03c00793          	li	a5,60
  202dd6:	02f757b3          	divu	a5,a4,a5
  202dda:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  202dde:	fdf44703          	lbu	a4,-33(s0)
  202de2:	47a9                	li	a5,10
  202de4:	02f757bb          	divuw	a5,a4,a5
  202de8:	0ff7f713          	andi	a4,a5,255
  202dec:	fc843783          	ld	a5,-56(s0)
  202df0:	078d                	addi	a5,a5,3
  202df2:	0307071b          	addiw	a4,a4,48
  202df6:	0ff77713          	andi	a4,a4,255
  202dfa:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  202dfe:	fdf44703          	lbu	a4,-33(s0)
  202e02:	47a9                	li	a5,10
  202e04:	02f777bb          	remuw	a5,a4,a5
  202e08:	0ff7f713          	andi	a4,a5,255
  202e0c:	fc843783          	ld	a5,-56(s0)
  202e10:	0791                	addi	a5,a5,4
  202e12:	0307071b          	addiw	a4,a4,48
  202e16:	0ff77713          	andi	a4,a4,255
  202e1a:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  202e1e:	fc843783          	ld	a5,-56(s0)
  202e22:	0795                	addi	a5,a5,5
  202e24:	03a00713          	li	a4,58
  202e28:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  202e2c:	fe043703          	ld	a4,-32(s0)
  202e30:	03c00793          	li	a5,60
  202e34:	02f777b3          	remu	a5,a4,a5
  202e38:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  202e3c:	fdf44703          	lbu	a4,-33(s0)
  202e40:	47a9                	li	a5,10
  202e42:	02f757bb          	divuw	a5,a4,a5
  202e46:	0ff7f713          	andi	a4,a5,255
  202e4a:	fc843783          	ld	a5,-56(s0)
  202e4e:	0799                	addi	a5,a5,6
  202e50:	0307071b          	addiw	a4,a4,48
  202e54:	0ff77713          	andi	a4,a4,255
  202e58:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  202e5c:	fdf44703          	lbu	a4,-33(s0)
  202e60:	47a9                	li	a5,10
  202e62:	02f777bb          	remuw	a5,a4,a5
  202e66:	0ff7f713          	andi	a4,a5,255
  202e6a:	fc843783          	ld	a5,-56(s0)
  202e6e:	079d                	addi	a5,a5,7
  202e70:	0307071b          	addiw	a4,a4,48
  202e74:	0ff77713          	andi	a4,a4,255
  202e78:	00e78023          	sb	a4,0(a5)
}
  202e7c:	0001                	nop
  202e7e:	7462                	ld	s0,56(sp)
  202e80:	6121                	addi	sp,sp,64
  202e82:	8082                	ret

0000000000202e84 <trap_init>:
#include "plic.h"
extern void trap_vector(void);

void trap_init()
{
  202e84:	1141                	addi	sp,sp,-16
  202e86:	e406                	sd	ra,8(sp)
  202e88:	e022                	sd	s0,0(sp)
  202e8a:	0800                	addi	s0,sp,16
	/*
	 * set the trap-vector base-address for machine-mode
	 */
	w_mtvec((reg_t)trap_vector);
  202e8c:	fffff797          	auipc	a5,0xfffff
  202e90:	1b878793          	addi	a5,a5,440 # 202044 <trap_vector>
  202e94:	853e                	mv	a0,a5
  202e96:	e65ff0ef          	jal	ra,202cfa <w_mtvec>
}
  202e9a:	0001                	nop
  202e9c:	60a2                	ld	ra,8(sp)
  202e9e:	6402                	ld	s0,0(sp)
  202ea0:	0141                	addi	sp,sp,16
  202ea2:	8082                	ret

0000000000202ea4 <external_interrupt_handler>:

void external_interrupt_handler()
{
  202ea4:	1101                	addi	sp,sp,-32
  202ea6:	ec06                	sd	ra,24(sp)
  202ea8:	e822                	sd	s0,16(sp)
  202eaa:	1000                	addi	s0,sp,32
	int irq = plic_claim();
  202eac:	68a000ef          	jal	ra,203536 <plic_claim>
  202eb0:	87aa                	mv	a5,a0
  202eb2:	fef42623          	sw	a5,-20(s0)

	if (irq == UART0_IRQ){
  202eb6:	fec42783          	lw	a5,-20(s0)
  202eba:	0007871b          	sext.w	a4,a5
  202ebe:	02400793          	li	a5,36
  202ec2:	00f71e63          	bne	a4,a5,202ede <external_interrupt_handler+0x3a>
		#ifdef MYPRINT
		printf("uart0 interrupt irq = %d\n\r", irq);
  202ec6:	fec42783          	lw	a5,-20(s0)
  202eca:	85be                	mv	a1,a5
  202ecc:	00002517          	auipc	a0,0x2
  202ed0:	43450513          	addi	a0,a0,1076 # 205300 <BSS_END+0x298>
  202ed4:	88dff0ef          	jal	ra,202760 <printf>
		#endif
      	uart_isr();
  202ed8:	2f6000ef          	jal	ra,2031ce <uart_isr>
  202edc:	a831                	j	202ef8 <external_interrupt_handler+0x54>
	} else if (irq) {
  202ede:	fec42783          	lw	a5,-20(s0)
  202ee2:	2781                	sext.w	a5,a5
  202ee4:	cb91                	beqz	a5,202ef8 <external_interrupt_handler+0x54>
		#ifdef MYPRINT
		printf("unexpected interrupt irq = %d\n\r", irq);
  202ee6:	fec42783          	lw	a5,-20(s0)
  202eea:	85be                	mv	a1,a5
  202eec:	00002517          	auipc	a0,0x2
  202ef0:	43450513          	addi	a0,a0,1076 # 205320 <BSS_END+0x2b8>
  202ef4:	86dff0ef          	jal	ra,202760 <printf>
		#endif
	}
	
	if (irq) {
  202ef8:	fec42783          	lw	a5,-20(s0)
  202efc:	2781                	sext.w	a5,a5
  202efe:	c791                	beqz	a5,202f0a <external_interrupt_handler+0x66>
		plic_complete(irq);
  202f00:	fec42783          	lw	a5,-20(s0)
  202f04:	853e                	mv	a0,a5
  202f06:	66c000ef          	jal	ra,203572 <plic_complete>
	}
}
  202f0a:	0001                	nop
  202f0c:	60e2                	ld	ra,24(sp)
  202f0e:	6442                	ld	s0,16(sp)
  202f10:	6105                	addi	sp,sp,32
  202f12:	8082                	ret

0000000000202f14 <trap_handler>:

reg_t trap_handler(reg_t epc, reg_t cause)
{
  202f14:	7179                	addi	sp,sp,-48
  202f16:	f406                	sd	ra,40(sp)
  202f18:	f022                	sd	s0,32(sp)
  202f1a:	1800                	addi	s0,sp,48
  202f1c:	fca43c23          	sd	a0,-40(s0)
  202f20:	fcb43823          	sd	a1,-48(s0)
	reg_t return_pc = epc;
  202f24:	fd843783          	ld	a5,-40(s0)
  202f28:	fef43423          	sd	a5,-24(s0)
	reg_t cause_code = cause & MCAUSE_MASK_ECODE;
  202f2c:	fd043703          	ld	a4,-48(s0)
  202f30:	800007b7          	lui	a5,0x80000
  202f34:	fff7c793          	not	a5,a5
  202f38:	8ff9                	and	a5,a5,a4
  202f3a:	fef43023          	sd	a5,-32(s0)
	// #ifdef MYPRINT
	// printf("TRAP! cause:%p\n\r", cause);
	// #endif
	if (cause & MCAUSE_MASK_INTERRUPT) {
  202f3e:	fd043783          	ld	a5,-48(s0)
  202f42:	0607d063          	bgez	a5,202fa2 <trap_handler+0x8e>
		/* Asynchronous trap - interrupt */
		switch (cause_code) {
  202f46:	fe043703          	ld	a4,-32(s0)
  202f4a:	479d                	li	a5,7
  202f4c:	02f70563          	beq	a4,a5,202f76 <trap_handler+0x62>
  202f50:	fe043703          	ld	a4,-32(s0)
  202f54:	47ad                	li	a5,11
  202f56:	02f70363          	beq	a4,a5,202f7c <trap_handler+0x68>
  202f5a:	fe043703          	ld	a4,-32(s0)
  202f5e:	478d                	li	a5,3
  202f60:	02f71763          	bne	a4,a5,202f8e <trap_handler+0x7a>
		case 3:
			#ifdef MYPRINT
			printf("software interruption!\n\r");
  202f64:	00002517          	auipc	a0,0x2
  202f68:	3dc50513          	addi	a0,a0,988 # 205340 <BSS_END+0x2d8>
  202f6c:	ff4ff0ef          	jal	ra,202760 <printf>
			#endif
			software_handler();
  202f70:	73a010ef          	jal	ra,2046aa <software_handler>
			break;
  202f74:	a0bd                	j	202fe2 <trap_handler+0xce>
		case 7:
			timer_handler();
  202f76:	6be010ef          	jal	ra,204634 <timer_handler>
			break;
  202f7a:	a0a5                	j	202fe2 <trap_handler+0xce>
		case 11:
			#ifdef MYPRINT
			printf("external interruption!\n\r");
  202f7c:	00002517          	auipc	a0,0x2
  202f80:	3e450513          	addi	a0,a0,996 # 205360 <BSS_END+0x2f8>
  202f84:	fdcff0ef          	jal	ra,202760 <printf>
			#endif
			external_interrupt_handler();
  202f88:	f1dff0ef          	jal	ra,202ea4 <external_interrupt_handler>
			break;
  202f8c:	a899                	j	202fe2 <trap_handler+0xce>
		default:
			printf("Unknown async exception! Code = %ld\n\r", cause_code);
  202f8e:	fe043583          	ld	a1,-32(s0)
  202f92:	00002517          	auipc	a0,0x2
  202f96:	3ee50513          	addi	a0,a0,1006 # 205380 <BSS_END+0x318>
  202f9a:	fc6ff0ef          	jal	ra,202760 <printf>
			break;
  202f9e:	0001                	nop
  202fa0:	a089                	j	202fe2 <trap_handler+0xce>
		}
	} else {
		/* Synchronous trap - exception */
		printf("Sync exceptions! Code = %ld\n\r", cause_code);
  202fa2:	fe043583          	ld	a1,-32(s0)
  202fa6:	00002517          	auipc	a0,0x2
  202faa:	40250513          	addi	a0,a0,1026 # 2053a8 <BSS_END+0x340>
  202fae:	fb2ff0ef          	jal	ra,202760 <printf>
		printf("mtval = %p\n\r", r_mtval());
  202fb2:	d2fff0ef          	jal	ra,202ce0 <r_mtval>
  202fb6:	87aa                	mv	a5,a0
  202fb8:	85be                	mv	a1,a5
  202fba:	00002517          	auipc	a0,0x2
  202fbe:	40e50513          	addi	a0,a0,1038 # 2053c8 <BSS_END+0x360>
  202fc2:	f9eff0ef          	jal	ra,202760 <printf>
		printf("mepc = %p\n\r", epc);
  202fc6:	fd843583          	ld	a1,-40(s0)
  202fca:	00002517          	auipc	a0,0x2
  202fce:	40e50513          	addi	a0,a0,1038 # 2053d8 <BSS_END+0x370>
  202fd2:	f8eff0ef          	jal	ra,202760 <printf>
		panic("OOPS! What can I do!");
  202fd6:	00002517          	auipc	a0,0x2
  202fda:	41250513          	addi	a0,a0,1042 # 2053e8 <BSS_END+0x380>
  202fde:	fd2ff0ef          	jal	ra,2027b0 <panic>
		//return_pc += 4;
	}

	return return_pc;
  202fe2:	fe843783          	ld	a5,-24(s0)
}
  202fe6:	853e                	mv	a0,a5
  202fe8:	70a2                	ld	ra,40(sp)
  202fea:	7402                	ld	s0,32(sp)
  202fec:	6145                	addi	sp,sp,48
  202fee:	8082                	ret

0000000000202ff0 <trap_test>:

void trap_test()
{
  202ff0:	1141                	addi	sp,sp,-16
  202ff2:	e406                	sd	ra,8(sp)
  202ff4:	e022                	sd	s0,0(sp)
  202ff6:	0800                	addi	s0,sp,16
	/*
	 * Synchronous exception code = 7
	 * Store/AMO access fault
	 */
	*(int *)0x12345678 = 100;
  202ff8:	123457b7          	lui	a5,0x12345
  202ffc:	67878793          	addi	a5,a5,1656 # 12345678 <_memory_end+0x2345679>
  203000:	06400713          	li	a4,100
  203004:	c398                	sw	a4,0(a5)
	 * Synchronous exception code = 5
	 * Load access fault
	 */
	//int a = *(int *)0x00000000;

	printf("Yeah! I'm return back from trap!\n\r");
  203006:	00002517          	auipc	a0,0x2
  20300a:	3fa50513          	addi	a0,a0,1018 # 205400 <BSS_END+0x398>
  20300e:	f52ff0ef          	jal	ra,202760 <printf>
}
  203012:	0001                	nop
  203014:	60a2                	ld	ra,8(sp)
  203016:	6402                	ld	s0,0(sp)
  203018:	0141                	addi	sp,sp,16
  20301a:	8082                	ret

000000000020301c <get_uart_usr>:
//the last 4 bit means the type of uart interrupt

#define uart_read_reg(reg) (*(UART_REG(reg)))
#define uart_write_reg(reg, v) (*(UART_REG(reg)) = (v))

uint32_t get_uart_usr(void){
  20301c:	1141                	addi	sp,sp,-16
  20301e:	e422                	sd	s0,8(sp)
  203020:	0800                	addi	s0,sp,16
	return uart_read_reg(USR);
  203022:	00002797          	auipc	a5,0x2
  203026:	46678793          	addi	a5,a5,1126 # 205488 <BSS_END+0x420>
  20302a:	639c                	ld	a5,0(a5)
  20302c:	439c                	lw	a5,0(a5)
  20302e:	2781                	sext.w	a5,a5
}
  203030:	853e                	mv	a0,a5
  203032:	6422                	ld	s0,8(sp)
  203034:	0141                	addi	sp,sp,16
  203036:	8082                	ret

0000000000203038 <uart_init>:
void uart_init()
{
  203038:	1101                	addi	sp,sp,-32
  20303a:	ec06                	sd	ra,24(sp)
  20303c:	e822                	sd	s0,16(sp)
  20303e:	1000                	addi	s0,sp,32
	/* disable interrupts. */
	uart_write_reg(IER, 0x00);
  203040:	00002797          	auipc	a5,0x2
  203044:	45078793          	addi	a5,a5,1104 # 205490 <BSS_END+0x428>
  203048:	639c                	ld	a5,0(a5)
  20304a:	0007a023          	sw	zero,0(a5)
	 * We use 38.4K when 1.8432 MHZ crystal, so the corresponding value is 3.
	 * And due to the divisor register is two bytes (16 bits), so we need to
	 * split the value of 3(0x0003) into two bytes, DLL stores the low byte,
	 * DLM stores the high byte.
	 */
	uint8_t lcr = uart_read_reg(LCR);
  20304e:	00002797          	auipc	a5,0x2
  203052:	44a78793          	addi	a5,a5,1098 # 205498 <BSS_END+0x430>
  203056:	639c                	ld	a5,0(a5)
  203058:	439c                	lw	a5,0(a5)
  20305a:	2781                	sext.w	a5,a5
  20305c:	fef407a3          	sb	a5,-17(s0)
	uart_write_reg(LCR, lcr | (1 << 7));
  203060:	fef44783          	lbu	a5,-17(s0)
  203064:	f807e793          	ori	a5,a5,-128
  203068:	0ff7f713          	andi	a4,a5,255
  20306c:	00002797          	auipc	a5,0x2
  203070:	42c78793          	addi	a5,a5,1068 # 205498 <BSS_END+0x430>
  203074:	639c                	ld	a5,0(a5)
  203076:	2701                	sext.w	a4,a4
  203078:	c398                	sw	a4,0(a5)
	uart_write_reg(DLL, 0x03);
  20307a:	03ffa7b7          	lui	a5,0x3ffa
  20307e:	c0578793          	addi	a5,a5,-1019 # 3ff9c05 <_bss_end+0x3defb95>
  203082:	07ba                	slli	a5,a5,0xe
  203084:	470d                	li	a4,3
  203086:	c398                	sw	a4,0(a5)
	uart_write_reg(DLM, 0x00);
  203088:	00002797          	auipc	a5,0x2
  20308c:	40878793          	addi	a5,a5,1032 # 205490 <BSS_END+0x428>
  203090:	639c                	ld	a5,0(a5)
  203092:	0007a023          	sw	zero,0(a5)
	 * - number of stop bits：1 bit when word length is 8 bits
	 * - no parity
	 * - no break control
	 * - disabled baud latch
	 */
	lcr = 0;
  203096:	fe0407a3          	sb	zero,-17(s0)
	uart_write_reg(LCR, lcr | (3 << 0));
  20309a:	fef44783          	lbu	a5,-17(s0)
  20309e:	0037e793          	ori	a5,a5,3
  2030a2:	0ff7f713          	andi	a4,a5,255
  2030a6:	00002797          	auipc	a5,0x2
  2030aa:	3f278793          	addi	a5,a5,1010 # 205498 <BSS_END+0x430>
  2030ae:	639c                	ld	a5,0(a5)
  2030b0:	2701                	sext.w	a4,a4
  2030b2:	c398                	sw	a4,0(a5)

	/*
	 * enable receive interrupts.
	 */
	uint8_t ier = uart_read_reg(IER);
  2030b4:	00002797          	auipc	a5,0x2
  2030b8:	3dc78793          	addi	a5,a5,988 # 205490 <BSS_END+0x428>
  2030bc:	639c                	ld	a5,0(a5)
  2030be:	439c                	lw	a5,0(a5)
  2030c0:	2781                	sext.w	a5,a5
  2030c2:	fef40723          	sb	a5,-18(s0)
	while (uart_read_reg(LCR) & (1 << 7));
  2030c6:	0001                	nop
  2030c8:	00002797          	auipc	a5,0x2
  2030cc:	3d078793          	addi	a5,a5,976 # 205498 <BSS_END+0x430>
  2030d0:	639c                	ld	a5,0(a5)
  2030d2:	439c                	lw	a5,0(a5)
  2030d4:	2781                	sext.w	a5,a5
  2030d6:	0807f793          	andi	a5,a5,128
  2030da:	2781                	sext.w	a5,a5
  2030dc:	f7f5                	bnez	a5,2030c8 <uart_init+0x90>
	uart_write_reg(IER, ier | (1 << 0));
  2030de:	fee44783          	lbu	a5,-18(s0)
  2030e2:	0017e793          	ori	a5,a5,1
  2030e6:	0ff7f713          	andi	a4,a5,255
  2030ea:	00002797          	auipc	a5,0x2
  2030ee:	3a678793          	addi	a5,a5,934 # 205490 <BSS_END+0x428>
  2030f2:	639c                	ld	a5,0(a5)
  2030f4:	2701                	sext.w	a4,a4
  2030f6:	c398                	sw	a4,0(a5)
	#ifdef MYPRINT
	printf("UART0 IER = %d\n\r", uart_read_reg(IER));
  2030f8:	00002797          	auipc	a5,0x2
  2030fc:	39878793          	addi	a5,a5,920 # 205490 <BSS_END+0x428>
  203100:	639c                	ld	a5,0(a5)
  203102:	439c                	lw	a5,0(a5)
  203104:	2781                	sext.w	a5,a5
  203106:	85be                	mv	a1,a5
  203108:	00002517          	auipc	a0,0x2
  20310c:	32050513          	addi	a0,a0,800 # 205428 <BSS_END+0x3c0>
  203110:	e50ff0ef          	jal	ra,202760 <printf>
	#endif
}
  203114:	0001                	nop
  203116:	60e2                	ld	ra,24(sp)
  203118:	6442                	ld	s0,16(sp)
  20311a:	6105                	addi	sp,sp,32
  20311c:	8082                	ret

000000000020311e <uart_putc>:

int uart_putc(char ch)
{
  20311e:	1101                	addi	sp,sp,-32
  203120:	ec22                	sd	s0,24(sp)
  203122:	1000                	addi	s0,sp,32
  203124:	87aa                	mv	a5,a0
  203126:	fef407a3          	sb	a5,-17(s0)
	while ((uart_read_reg(LSR) & LSR_TX_IDLE) == 0);
  20312a:	0001                	nop
  20312c:	00002797          	auipc	a5,0x2
  203130:	37478793          	addi	a5,a5,884 # 2054a0 <BSS_END+0x438>
  203134:	639c                	ld	a5,0(a5)
  203136:	439c                	lw	a5,0(a5)
  203138:	2781                	sext.w	a5,a5
  20313a:	0407f793          	andi	a5,a5,64
  20313e:	2781                	sext.w	a5,a5
  203140:	d7f5                	beqz	a5,20312c <uart_putc+0xe>
	return uart_write_reg(THR, ch);
  203142:	03ffa7b7          	lui	a5,0x3ffa
  203146:	c0578793          	addi	a5,a5,-1019 # 3ff9c05 <_bss_end+0x3defb95>
  20314a:	00e79713          	slli	a4,a5,0xe
  20314e:	fef44783          	lbu	a5,-17(s0)
  203152:	2781                	sext.w	a5,a5
  203154:	2781                	sext.w	a5,a5
  203156:	c31c                	sw	a5,0(a4)
  203158:	2781                	sext.w	a5,a5
}
  20315a:	853e                	mv	a0,a5
  20315c:	6462                	ld	s0,24(sp)
  20315e:	6105                	addi	sp,sp,32
  203160:	8082                	ret

0000000000203162 <uart_puts>:

void uart_puts(char *s)
{
  203162:	1101                	addi	sp,sp,-32
  203164:	ec06                	sd	ra,24(sp)
  203166:	e822                	sd	s0,16(sp)
  203168:	1000                	addi	s0,sp,32
  20316a:	fea43423          	sd	a0,-24(s0)
	while (*s) {
  20316e:	a821                	j	203186 <uart_puts+0x24>
		uart_putc(*s++);
  203170:	fe843783          	ld	a5,-24(s0)
  203174:	00178713          	addi	a4,a5,1
  203178:	fee43423          	sd	a4,-24(s0)
  20317c:	0007c783          	lbu	a5,0(a5)
  203180:	853e                	mv	a0,a5
  203182:	f9dff0ef          	jal	ra,20311e <uart_putc>
	while (*s) {
  203186:	fe843783          	ld	a5,-24(s0)
  20318a:	0007c783          	lbu	a5,0(a5)
  20318e:	f3ed                	bnez	a5,203170 <uart_puts+0xe>
	}
}
  203190:	0001                	nop
  203192:	60e2                	ld	ra,24(sp)
  203194:	6442                	ld	s0,16(sp)
  203196:	6105                	addi	sp,sp,32
  203198:	8082                	ret

000000000020319a <uart_getc>:

int uart_getc(void)
{
  20319a:	1141                	addi	sp,sp,-16
  20319c:	e422                	sd	s0,8(sp)
  20319e:	0800                	addi	s0,sp,16
	while (0 == (uart_read_reg(LSR) & LSR_RX_READY))
  2031a0:	0001                	nop
  2031a2:	00002797          	auipc	a5,0x2
  2031a6:	2fe78793          	addi	a5,a5,766 # 2054a0 <BSS_END+0x438>
  2031aa:	639c                	ld	a5,0(a5)
  2031ac:	439c                	lw	a5,0(a5)
  2031ae:	2781                	sext.w	a5,a5
  2031b0:	8b85                	andi	a5,a5,1
  2031b2:	2781                	sext.w	a5,a5
  2031b4:	d7fd                	beqz	a5,2031a2 <uart_getc+0x8>
		;
	return uart_read_reg(RHR);
  2031b6:	03ffa7b7          	lui	a5,0x3ffa
  2031ba:	c0578793          	addi	a5,a5,-1019 # 3ff9c05 <_bss_end+0x3defb95>
  2031be:	07ba                	slli	a5,a5,0xe
  2031c0:	439c                	lw	a5,0(a5)
  2031c2:	2781                	sext.w	a5,a5
  2031c4:	2781                	sext.w	a5,a5
}
  2031c6:	853e                	mv	a0,a5
  2031c8:	6422                	ld	s0,8(sp)
  2031ca:	0141                	addi	sp,sp,16
  2031cc:	8082                	ret

00000000002031ce <uart_isr>:

/*
 * handle a uart interrupt, raised because input has arrived, called from trap.c.
 */
void uart_isr(void)
{
  2031ce:	1101                	addi	sp,sp,-32
  2031d0:	ec06                	sd	ra,24(sp)
  2031d2:	e822                	sd	s0,16(sp)
  2031d4:	1000                	addi	s0,sp,32
	/* add a new line just to look better */
	uint32_t usr =  uart_read_reg(USR);
  2031d6:	00002797          	auipc	a5,0x2
  2031da:	2b278793          	addi	a5,a5,690 # 205488 <BSS_END+0x420>
  2031de:	639c                	ld	a5,0(a5)
  2031e0:	439c                	lw	a5,0(a5)
  2031e2:	fef42623          	sw	a5,-20(s0)
	uint32_t isr = uart_read_reg(ISR);
  2031e6:	00002797          	auipc	a5,0x2
  2031ea:	2c278793          	addi	a5,a5,706 # 2054a8 <BSS_END+0x440>
  2031ee:	639c                	ld	a5,0(a5)
  2031f0:	439c                	lw	a5,0(a5)
  2031f2:	fef42423          	sw	a5,-24(s0)
	#ifdef MYPRINT
	printf("IID = %d\n\r", isr & ISR_IID);
  2031f6:	fe842783          	lw	a5,-24(s0)
  2031fa:	8bbd                	andi	a5,a5,15
  2031fc:	2781                	sext.w	a5,a5
  2031fe:	85be                	mv	a1,a5
  203200:	00002517          	auipc	a0,0x2
  203204:	24050513          	addi	a0,a0,576 # 205440 <BSS_END+0x3d8>
  203208:	d58ff0ef          	jal	ra,202760 <printf>
	printf("FAR = %d\n\r", uart_read_reg(FAR));
  20320c:	00002797          	auipc	a5,0x2
  203210:	2a478793          	addi	a5,a5,676 # 2054b0 <BSS_END+0x448>
  203214:	639c                	ld	a5,0(a5)
  203216:	439c                	lw	a5,0(a5)
  203218:	2781                	sext.w	a5,a5
  20321a:	85be                	mv	a1,a5
  20321c:	00002517          	auipc	a0,0x2
  203220:	23450513          	addi	a0,a0,564 # 205450 <BSS_END+0x3e8>
  203224:	d3cff0ef          	jal	ra,202760 <printf>
	printf("USR = %d\n\r", usr);
  203228:	fec42783          	lw	a5,-20(s0)
  20322c:	85be                	mv	a1,a5
  20322e:	00002517          	auipc	a0,0x2
  203232:	23250513          	addi	a0,a0,562 # 205460 <BSS_END+0x3f8>
  203236:	d2aff0ef          	jal	ra,202760 <printf>
	printf("CPR = %d\n\r", uart_read_reg(CPR));
  20323a:	00002797          	auipc	a5,0x2
  20323e:	27e78793          	addi	a5,a5,638 # 2054b8 <BSS_END+0x450>
  203242:	639c                	ld	a5,0(a5)
  203244:	439c                	lw	a5,0(a5)
  203246:	2781                	sext.w	a5,a5
  203248:	85be                	mv	a1,a5
  20324a:	00002517          	auipc	a0,0x2
  20324e:	22650513          	addi	a0,a0,550 # 205470 <BSS_END+0x408>
  203252:	d0eff0ef          	jal	ra,202760 <printf>
	#endif
	#ifndef MYPRINT
	printf("\033[K");
	#endif
	if ((isr & ISR_IID) == 1) return;
  203256:	fe842783          	lw	a5,-24(s0)
  20325a:	8bbd                	andi	a5,a5,15
  20325c:	2781                	sext.w	a5,a5
  20325e:	873e                	mv	a4,a5
  203260:	4785                	li	a5,1
  203262:	02f70163          	beq	a4,a5,203284 <uart_isr+0xb6>
	addGoishBuffer((char)uart_getc());
  203266:	f35ff0ef          	jal	ra,20319a <uart_getc>
  20326a:	87aa                	mv	a5,a0
  20326c:	0ff7f793          	andi	a5,a5,255
  203270:	853e                	mv	a0,a5
  203272:	5b5000ef          	jal	ra,204026 <addGoishBuffer>
	#ifdef MYPRINT
	printf("\n");
  203276:	00002517          	auipc	a0,0x2
  20327a:	20a50513          	addi	a0,a0,522 # 205480 <BSS_END+0x418>
  20327e:	ce2ff0ef          	jal	ra,202760 <printf>
  203282:	a011                	j	203286 <uart_isr+0xb8>
	if ((isr & ISR_IID) == 1) return;
  203284:	0001                	nop
	#endif
}
  203286:	60e2                	ld	ra,24(sp)
  203288:	6442                	ld	s0,16(sp)
  20328a:	6105                	addi	sp,sp,32
  20328c:	8082                	ret

000000000020328e <w_mscratch>:
static void w_mscratch(reg_t x){
  20328e:	1101                	addi	sp,sp,-32
  203290:	ec22                	sd	s0,24(sp)
  203292:	1000                	addi	s0,sp,32
  203294:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  203298:	fe843783          	ld	a5,-24(s0)
  20329c:	34079073          	csrw	mscratch,a5
}
  2032a0:	0001                	nop
  2032a2:	6462                	ld	s0,24(sp)
  2032a4:	6105                	addi	sp,sp,32
  2032a6:	8082                	ret

00000000002032a8 <r_mscratch>:
static reg_t r_mscratch(){
  2032a8:	1101                	addi	sp,sp,-32
  2032aa:	ec22                	sd	s0,24(sp)
  2032ac:	1000                	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  2032ae:	340027f3          	csrr	a5,mscratch
  2032b2:	fef43423          	sd	a5,-24(s0)
	return ret;
  2032b6:	fe843783          	ld	a5,-24(s0)
}
  2032ba:	853e                	mv	a0,a5
  2032bc:	6462                	ld	s0,24(sp)
  2032be:	6105                	addi	sp,sp,32
  2032c0:	8082                	ret

00000000002032c2 <r_tp>:
static inline reg_t r_tp(){
  2032c2:	1101                	addi	sp,sp,-32
  2032c4:	ec22                	sd	s0,24(sp)
  2032c6:	1000                	addi	s0,sp,32
    asm volatile("mv %0, tp" :"=r" (ret));
  2032c8:	8792                	mv	a5,tp
  2032ca:	fef43423          	sd	a5,-24(s0)
    return ret;
  2032ce:	fe843783          	ld	a5,-24(s0)
}
  2032d2:	853e                	mv	a0,a5
  2032d4:	6462                	ld	s0,24(sp)
  2032d6:	6105                	addi	sp,sp,32
  2032d8:	8082                	ret

00000000002032da <r_mstatus>:
static inline reg_t r_mstatus(){
  2032da:	1101                	addi	sp,sp,-32
  2032dc:	ec22                	sd	s0,24(sp)
  2032de:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
  2032e0:	300027f3          	csrr	a5,mstatus
  2032e4:	fef43423          	sd	a5,-24(s0)
	return x;
  2032e8:	fe843783          	ld	a5,-24(s0)
}
  2032ec:	853e                	mv	a0,a5
  2032ee:	6462                	ld	s0,24(sp)
  2032f0:	6105                	addi	sp,sp,32
  2032f2:	8082                	ret

00000000002032f4 <w_mstatus>:
static inline void w_mstatus(reg_t x){
  2032f4:	1101                	addi	sp,sp,-32
  2032f6:	ec22                	sd	s0,24(sp)
  2032f8:	1000                	addi	s0,sp,32
  2032fa:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
  2032fe:	fe843783          	ld	a5,-24(s0)
  203302:	30079073          	csrw	mstatus,a5
}
  203306:	0001                	nop
  203308:	6462                	ld	s0,24(sp)
  20330a:	6105                	addi	sp,sp,32
  20330c:	8082                	ret

000000000020330e <r_mie>:
{
  20330e:	1101                	addi	sp,sp,-32
  203310:	ec22                	sd	s0,24(sp)
  203312:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  203314:	304027f3          	csrr	a5,mie
  203318:	fef43423          	sd	a5,-24(s0)
	return x;
  20331c:	fe843783          	ld	a5,-24(s0)
}
  203320:	853e                	mv	a0,a5
  203322:	6462                	ld	s0,24(sp)
  203324:	6105                	addi	sp,sp,32
  203326:	8082                	ret

0000000000203328 <w_mie>:
{
  203328:	1101                	addi	sp,sp,-32
  20332a:	ec22                	sd	s0,24(sp)
  20332c:	1000                	addi	s0,sp,32
  20332e:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
  203332:	fe843783          	ld	a5,-24(s0)
  203336:	30479073          	csrw	mie,a5
}
  20333a:	0001                	nop
  20333c:	6462                	ld	s0,24(sp)
  20333e:	6105                	addi	sp,sp,32
  203340:	8082                	ret

0000000000203342 <get_time>:
static uint64_t get_time(){
  203342:	1141                	addi	sp,sp,-16
  203344:	e422                	sd	s0,8(sp)
  203346:	0800                	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  203348:	00003797          	auipc	a5,0x3
  20334c:	12878793          	addi	a5,a5,296 # 206470 <_tick>
  203350:	6398                	ld	a4,0(a5)
  203352:	03c00793          	li	a5,60
  203356:	02f757b3          	divu	a5,a4,a5
}
  20335a:	853e                	mv	a0,a5
  20335c:	6422                	ld	s0,8(sp)
  20335e:	0141                	addi	sp,sp,16
  203360:	8082                	ret

0000000000203362 <get_time_str>:
static void get_time_str(char* time){
  203362:	7139                	addi	sp,sp,-64
  203364:	fc22                	sd	s0,56(sp)
  203366:	0080                	addi	s0,sp,64
  203368:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  20336c:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  203370:	00003797          	auipc	a5,0x3
  203374:	10078793          	addi	a5,a5,256 # 206470 <_tick>
  203378:	6398                	ld	a4,0(a5)
  20337a:	03c00793          	li	a5,60
  20337e:	02f757b3          	divu	a5,a4,a5
  203382:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  203386:	fe043703          	ld	a4,-32(s0)
  20338a:	6785                	lui	a5,0x1
  20338c:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  203390:	02f757b3          	divu	a5,a4,a5
  203394:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  203398:	fdf44703          	lbu	a4,-33(s0)
  20339c:	06400793          	li	a5,100
  2033a0:	02f777bb          	remuw	a5,a4,a5
  2033a4:	0ff7f793          	andi	a5,a5,255
  2033a8:	873e                	mv	a4,a5
  2033aa:	47a9                	li	a5,10
  2033ac:	02f757bb          	divuw	a5,a4,a5
  2033b0:	0ff7f793          	andi	a5,a5,255
  2033b4:	0307879b          	addiw	a5,a5,48
  2033b8:	0ff7f713          	andi	a4,a5,255
  2033bc:	fc843783          	ld	a5,-56(s0)
  2033c0:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  2033c4:	fdf44703          	lbu	a4,-33(s0)
  2033c8:	47a9                	li	a5,10
  2033ca:	02f777bb          	remuw	a5,a4,a5
  2033ce:	0ff7f713          	andi	a4,a5,255
  2033d2:	fc843783          	ld	a5,-56(s0)
  2033d6:	0785                	addi	a5,a5,1
  2033d8:	0307071b          	addiw	a4,a4,48
  2033dc:	0ff77713          	andi	a4,a4,255
  2033e0:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  2033e4:	fc843783          	ld	a5,-56(s0)
  2033e8:	0789                	addi	a5,a5,2
  2033ea:	03a00713          	li	a4,58
  2033ee:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  2033f2:	fe043703          	ld	a4,-32(s0)
  2033f6:	6785                	lui	a5,0x1
  2033f8:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2033fc:	02f77733          	remu	a4,a4,a5
  203400:	03c00793          	li	a5,60
  203404:	02f757b3          	divu	a5,a4,a5
  203408:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  20340c:	fdf44703          	lbu	a4,-33(s0)
  203410:	47a9                	li	a5,10
  203412:	02f757bb          	divuw	a5,a4,a5
  203416:	0ff7f713          	andi	a4,a5,255
  20341a:	fc843783          	ld	a5,-56(s0)
  20341e:	078d                	addi	a5,a5,3
  203420:	0307071b          	addiw	a4,a4,48
  203424:	0ff77713          	andi	a4,a4,255
  203428:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  20342c:	fdf44703          	lbu	a4,-33(s0)
  203430:	47a9                	li	a5,10
  203432:	02f777bb          	remuw	a5,a4,a5
  203436:	0ff7f713          	andi	a4,a5,255
  20343a:	fc843783          	ld	a5,-56(s0)
  20343e:	0791                	addi	a5,a5,4
  203440:	0307071b          	addiw	a4,a4,48
  203444:	0ff77713          	andi	a4,a4,255
  203448:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  20344c:	fc843783          	ld	a5,-56(s0)
  203450:	0795                	addi	a5,a5,5
  203452:	03a00713          	li	a4,58
  203456:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  20345a:	fe043703          	ld	a4,-32(s0)
  20345e:	03c00793          	li	a5,60
  203462:	02f777b3          	remu	a5,a4,a5
  203466:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  20346a:	fdf44703          	lbu	a4,-33(s0)
  20346e:	47a9                	li	a5,10
  203470:	02f757bb          	divuw	a5,a4,a5
  203474:	0ff7f713          	andi	a4,a5,255
  203478:	fc843783          	ld	a5,-56(s0)
  20347c:	0799                	addi	a5,a5,6
  20347e:	0307071b          	addiw	a4,a4,48
  203482:	0ff77713          	andi	a4,a4,255
  203486:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  20348a:	fdf44703          	lbu	a4,-33(s0)
  20348e:	47a9                	li	a5,10
  203490:	02f777bb          	remuw	a5,a4,a5
  203494:	0ff7f713          	andi	a4,a5,255
  203498:	fc843783          	ld	a5,-56(s0)
  20349c:	079d                	addi	a5,a5,7
  20349e:	0307071b          	addiw	a4,a4,48
  2034a2:	0ff77713          	andi	a4,a4,255
  2034a6:	00e78023          	sb	a4,0(a5)
}
  2034aa:	0001                	nop
  2034ac:	7462                	ld	s0,56(sp)
  2034ae:	6121                	addi	sp,sp,64
  2034b0:	8082                	ret

00000000002034b2 <plic_init>:
#include "plic.h"

void plic_init(void)
{
  2034b2:	1101                	addi	sp,sp,-32
  2034b4:	ec06                	sd	ra,24(sp)
  2034b6:	e822                	sd	s0,16(sp)
  2034b8:	1000                	addi	s0,sp,32
	int hart = r_tp();
  2034ba:	e09ff0ef          	jal	ra,2032c2 <r_tp>
  2034be:	87aa                	mv	a5,a0
  2034c0:	fef42623          	sw	a5,-20(s0)
	 * Priority 1 is the lowest active priority, and priority 7 is the highest. 
	 * Ties between global interrupts of the same priority are broken by 
	 * the Interrupt ID; interrupts with the lowest ID have the highest 
	 * effective priority.
	 */
	*(uint32_t*)PLIC_PRIORITY(UART0_IRQ) = 1;
  2034c4:	01ffb7b7          	lui	a5,0x1ffb
  2034c8:	07be                	slli	a5,a5,0xf
  2034ca:	09078793          	addi	a5,a5,144 # 1ffb090 <_bss_end+0x1df1020>
  2034ce:	4705                	li	a4,1
  2034d0:	c398                	sw	a4,0(a5)
	 * Enable UART0
	 *
	 * Each global interrupt can be enabled by setting the corresponding 
	 * bit in the enables registers.
	 */
	*(uint32_t*)PLIC_MENABLE(hart, UART0_IRQ)= (1 << (UART0_IRQ % 32));
  2034d2:	fec42783          	lw	a5,-20(s0)
  2034d6:	0087979b          	slliw	a5,a5,0x8
  2034da:	2781                	sext.w	a5,a5
  2034dc:	873e                	mv	a4,a5
  2034de:	00002797          	auipc	a5,0x2
  2034e2:	fe278793          	addi	a5,a5,-30 # 2054c0 <BSS_END+0x458>
  2034e6:	639c                	ld	a5,0(a5)
  2034e8:	97ba                	add	a5,a5,a4
  2034ea:	873e                	mv	a4,a5
  2034ec:	47c1                	li	a5,16
  2034ee:	c31c                	sw	a5,0(a4)
	 * Maximum threshold is 7.
	 * For example, a threshold value of zero permits all interrupts with
	 * non-zero priority, whereas a value of 7 masks all interrupts.
	 * Notice, the threshold is global for PLIC, not for each interrupt source.
	 */
	*(uint32_t*)PLIC_MTHRESHOLD(hart) = 0;
  2034f0:	fec42783          	lw	a5,-20(s0)
  2034f4:	00d7979b          	slliw	a5,a5,0xd
  2034f8:	2781                	sext.w	a5,a5
  2034fa:	873e                	mv	a4,a5
  2034fc:	7fec17b7          	lui	a5,0x7fec1
  203500:	07a6                	slli	a5,a5,0x9
  203502:	97ba                	add	a5,a5,a4
  203504:	0007a023          	sw	zero,0(a5) # 7fec1000 <_memory_end+0x6fec1001>

	/* enable machine-mode external interrupts. */
	w_mie(r_mie() | MIE_MEIE);
  203508:	e07ff0ef          	jal	ra,20330e <r_mie>
  20350c:	872a                	mv	a4,a0
  20350e:	6785                	lui	a5,0x1
  203510:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE+0x400>
  203514:	8fd9                	or	a5,a5,a4
  203516:	853e                	mv	a0,a5
  203518:	e11ff0ef          	jal	ra,203328 <w_mie>

                 
	/* enable machine-mode global interrupts. */
	w_mstatus(r_mstatus() | MSTATUS_MIE);
  20351c:	dbfff0ef          	jal	ra,2032da <r_mstatus>
  203520:	87aa                	mv	a5,a0
  203522:	0087e793          	ori	a5,a5,8
  203526:	853e                	mv	a0,a5
  203528:	dcdff0ef          	jal	ra,2032f4 <w_mstatus>
	
}
  20352c:	0001                	nop
  20352e:	60e2                	ld	ra,24(sp)
  203530:	6442                	ld	s0,16(sp)
  203532:	6105                	addi	sp,sp,32
  203534:	8082                	ret

0000000000203536 <plic_claim>:
 * RETURN VALUE:
 *	the ID of the highest-priority pending interrupt or zero if there 
 *	is no pending interrupt.
 */
int plic_claim(void)
{
  203536:	1101                	addi	sp,sp,-32
  203538:	ec06                	sd	ra,24(sp)
  20353a:	e822                	sd	s0,16(sp)
  20353c:	1000                	addi	s0,sp,32
	int hart = r_tp();
  20353e:	d85ff0ef          	jal	ra,2032c2 <r_tp>
  203542:	87aa                	mv	a5,a0
  203544:	fef42623          	sw	a5,-20(s0)
	int irq = *(uint32_t*)PLIC_MCLAIM(hart);
  203548:	fec42783          	lw	a5,-20(s0)
  20354c:	00d7979b          	slliw	a5,a5,0xd
  203550:	2781                	sext.w	a5,a5
  203552:	873e                	mv	a4,a5
  203554:	7fec17b7          	lui	a5,0x7fec1
  203558:	07a6                	slli	a5,a5,0x9
  20355a:	0791                	addi	a5,a5,4
  20355c:	97ba                	add	a5,a5,a4
  20355e:	439c                	lw	a5,0(a5)
  203560:	fef42423          	sw	a5,-24(s0)
	return irq;
  203564:	fe842783          	lw	a5,-24(s0)
}
  203568:	853e                	mv	a0,a5
  20356a:	60e2                	ld	ra,24(sp)
  20356c:	6442                	ld	s0,16(sp)
  20356e:	6105                	addi	sp,sp,32
  203570:	8082                	ret

0000000000203572 <plic_complete>:
 *	interrupt source that is currently enabled for the target, the completion
 *	is silently ignored.
 * RETURN VALUE: none
 */
void plic_complete(int irq)
{
  203572:	7179                	addi	sp,sp,-48
  203574:	f406                	sd	ra,40(sp)
  203576:	f022                	sd	s0,32(sp)
  203578:	1800                	addi	s0,sp,48
  20357a:	87aa                	mv	a5,a0
  20357c:	fcf42e23          	sw	a5,-36(s0)
	int hart = r_tp();
  203580:	d43ff0ef          	jal	ra,2032c2 <r_tp>
  203584:	87aa                	mv	a5,a0
  203586:	fef42623          	sw	a5,-20(s0)
	*(uint32_t*)PLIC_MCOMPLETE(hart) = irq;
  20358a:	fec42783          	lw	a5,-20(s0)
  20358e:	00d7979b          	slliw	a5,a5,0xd
  203592:	2781                	sext.w	a5,a5
  203594:	873e                	mv	a4,a5
  203596:	7fec17b7          	lui	a5,0x7fec1
  20359a:	07a6                	slli	a5,a5,0x9
  20359c:	0791                	addi	a5,a5,4
  20359e:	97ba                	add	a5,a5,a4
  2035a0:	873e                	mv	a4,a5
  2035a2:	fdc42783          	lw	a5,-36(s0)
  2035a6:	c31c                	sw	a5,0(a4)
}
  2035a8:	0001                	nop
  2035aa:	70a2                	ld	ra,40(sp)
  2035ac:	7402                	ld	s0,32(sp)
  2035ae:	6145                	addi	sp,sp,48
  2035b0:	8082                	ret

00000000002035b2 <print_printftest>:
#include "graphprint.h"

void print_printftest(){
  2035b2:	1141                	addi	sp,sp,-16
  2035b4:	e406                	sd	ra,8(sp)
  2035b6:	e022                	sd	s0,0(sp)
  2035b8:	0800                	addi	s0,sp,16
	printf("#########################################################\n\r");
  2035ba:	00002517          	auipc	a0,0x2
  2035be:	f0e50513          	addi	a0,a0,-242 # 2054c8 <BSS_END+0x460>
  2035c2:	99eff0ef          	jal	ra,202760 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  2035c6:	00002517          	auipc	a0,0x2
  2035ca:	f4250513          	addi	a0,a0,-190 # 205508 <BSS_END+0x4a0>
  2035ce:	992ff0ef          	jal	ra,202760 <printf>
	printf("##     this is a printf test:%p        ##\n\r",0xfedcba9876543210);
  2035d2:	00002797          	auipc	a5,0x2
  2035d6:	25e78793          	addi	a5,a5,606 # 205830 <BSS_END+0x7c8>
  2035da:	639c                	ld	a5,0(a5)
  2035dc:	85be                	mv	a1,a5
  2035de:	00002517          	auipc	a0,0x2
  2035e2:	f6a50513          	addi	a0,a0,-150 # 205548 <BSS_END+0x4e0>
  2035e6:	97aff0ef          	jal	ra,202760 <printf>
	printf("##         fedcba9876543210 means right output         ##\n\r");
  2035ea:	00002517          	auipc	a0,0x2
  2035ee:	f8e50513          	addi	a0,a0,-114 # 205578 <BSS_END+0x510>
  2035f2:	96eff0ef          	jal	ra,202760 <printf>
	printf("#########################################################\n\r");
  2035f6:	00002517          	auipc	a0,0x2
  2035fa:	ed250513          	addi	a0,a0,-302 # 2054c8 <BSS_END+0x460>
  2035fe:	962ff0ef          	jal	ra,202760 <printf>
}
  203602:	0001                	nop
  203604:	60a2                	ld	ra,8(sp)
  203606:	6402                	ld	s0,0(sp)
  203608:	0141                	addi	sp,sp,16
  20360a:	8082                	ret

000000000020360c <print_WhoAmI>:

void print_WhoAmI(){
  20360c:	1141                	addi	sp,sp,-16
  20360e:	e406                	sd	ra,8(sp)
  203610:	e022                	sd	s0,0(sp)
  203612:	0800                	addi	s0,sp,16
	printf("\n\r");
  203614:	00002517          	auipc	a0,0x2
  203618:	fa450513          	addi	a0,a0,-92 # 2055b8 <BSS_END+0x550>
  20361c:	944ff0ef          	jal	ra,202760 <printf>
	printf("\033[5m#########################################################\n\r");
  203620:	00002517          	auipc	a0,0x2
  203624:	fa050513          	addi	a0,a0,-96 # 2055c0 <BSS_END+0x558>
  203628:	938ff0ef          	jal	ra,202760 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  20362c:	00002517          	auipc	a0,0x2
  203630:	edc50513          	addi	a0,a0,-292 # 205508 <BSS_END+0x4a0>
  203634:	92cff0ef          	jal	ra,202760 <printf>
	printf("##                   %s                         ##\n\r", GROL_OS_VERSION);
  203638:	00002597          	auipc	a1,0x2
  20363c:	fc858593          	addi	a1,a1,-56 # 205600 <BSS_END+0x598>
  203640:	00002517          	auipc	a0,0x2
  203644:	fd050513          	addi	a0,a0,-48 # 205610 <BSS_END+0x5a8>
  203648:	918ff0ef          	jal	ra,202760 <printf>
	printf("#########################################################\033[0m\r");
  20364c:	00002517          	auipc	a0,0x2
  203650:	ffc50513          	addi	a0,a0,-4 # 205648 <BSS_END+0x5e0>
  203654:	90cff0ef          	jal	ra,202760 <printf>
	printf("\033[1A");
	printf("\033[1A");
	printf("\033[1A");
	printf("\033[1A");
	#endif
}
  203658:	0001                	nop
  20365a:	60a2                	ld	ra,8(sp)
  20365c:	6402                	ld	s0,0(sp)
  20365e:	0141                	addi	sp,sp,16
  203660:	8082                	ret

0000000000203662 <print_heapinit>:

void print_heapinit(){
  203662:	1141                	addi	sp,sp,-16
  203664:	e406                	sd	ra,8(sp)
  203666:	e022                	sd	s0,0(sp)
  203668:	0800                	addi	s0,sp,16
	printf("#########################################################\n\r");
  20366a:	00002517          	auipc	a0,0x2
  20366e:	e5e50513          	addi	a0,a0,-418 # 2054c8 <BSS_END+0x460>
  203672:	8eeff0ef          	jal	ra,202760 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  203676:	00002517          	auipc	a0,0x2
  20367a:	e9250513          	addi	a0,a0,-366 # 205508 <BSS_END+0x4a0>
  20367e:	8e2ff0ef          	jal	ra,202760 <printf>
	printf("##                HEAP INIT SUCCESS...                 ##\n\r");
  203682:	00002517          	auipc	a0,0x2
  203686:	00650513          	addi	a0,a0,6 # 205688 <BSS_END+0x620>
  20368a:	8d6ff0ef          	jal	ra,202760 <printf>
	printf("#########################################################\n\r");
  20368e:	00002517          	auipc	a0,0x2
  203692:	e3a50513          	addi	a0,a0,-454 # 2054c8 <BSS_END+0x460>
  203696:	8caff0ef          	jal	ra,202760 <printf>
}
  20369a:	0001                	nop
  20369c:	60a2                	ld	ra,8(sp)
  20369e:	6402                	ld	s0,0(sp)
  2036a0:	0141                	addi	sp,sp,16
  2036a2:	8082                	ret

00000000002036a4 <print_multitasktest>:

void print_multitasktest(){
  2036a4:	1141                	addi	sp,sp,-16
  2036a6:	e406                	sd	ra,8(sp)
  2036a8:	e022                	sd	s0,0(sp)
  2036aa:	0800                	addi	s0,sp,16
	printf("#########################################################\n\r");
  2036ac:	00002517          	auipc	a0,0x2
  2036b0:	e1c50513          	addi	a0,a0,-484 # 2054c8 <BSS_END+0x460>
  2036b4:	8acff0ef          	jal	ra,202760 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  2036b8:	00002517          	auipc	a0,0x2
  2036bc:	e5050513          	addi	a0,a0,-432 # 205508 <BSS_END+0x4a0>
  2036c0:	8a0ff0ef          	jal	ra,202760 <printf>
	printf("##              2  cooperative task test...            ##\n\r");
  2036c4:	00002517          	auipc	a0,0x2
  2036c8:	00450513          	addi	a0,a0,4 # 2056c8 <BSS_END+0x660>
  2036cc:	894ff0ef          	jal	ra,202760 <printf>
	printf("#########################################################\n\r");
  2036d0:	00002517          	auipc	a0,0x2
  2036d4:	df850513          	addi	a0,a0,-520 # 2054c8 <BSS_END+0x460>
  2036d8:	888ff0ef          	jal	ra,202760 <printf>
}
  2036dc:	0001                	nop
  2036de:	60a2                	ld	ra,8(sp)
  2036e0:	6402                	ld	s0,0(sp)
  2036e2:	0141                	addi	sp,sp,16
  2036e4:	8082                	ret

00000000002036e6 <print_taskkilled>:
void print_taskkilled(){
  2036e6:	1141                	addi	sp,sp,-16
  2036e8:	e406                	sd	ra,8(sp)
  2036ea:	e022                	sd	s0,0(sp)
  2036ec:	0800                	addi	s0,sp,16
	printf("\033[31m#########################################################\033[0m\n\r");
  2036ee:	00002517          	auipc	a0,0x2
  2036f2:	01a50513          	addi	a0,a0,26 # 205708 <BSS_END+0x6a0>
  2036f6:	86aff0ef          	jal	ra,202760 <printf>
	printf("\033[31m##                    GROL_OS                          ##\033[0m\n\r");
  2036fa:	00002517          	auipc	a0,0x2
  2036fe:	05650513          	addi	a0,a0,86 # 205750 <BSS_END+0x6e8>
  203702:	85eff0ef          	jal	ra,202760 <printf>
	printf("\033[31m##              AHAHAH  I AM KILLED.........           ##\033[0m\n\r");
  203706:	00002517          	auipc	a0,0x2
  20370a:	09250513          	addi	a0,a0,146 # 205798 <BSS_END+0x730>
  20370e:	852ff0ef          	jal	ra,202760 <printf>
	printf("\033[31m#########################################################\033[0m\n\r");
  203712:	00002517          	auipc	a0,0x2
  203716:	ff650513          	addi	a0,a0,-10 # 205708 <BSS_END+0x6a0>
  20371a:	846ff0ef          	jal	ra,202760 <printf>
}
  20371e:	0001                	nop
  203720:	60a2                	ld	ra,8(sp)
  203722:	6402                	ld	s0,0(sp)
  203724:	0141                	addi	sp,sp,16
  203726:	8082                	ret

0000000000203728 <delete_taskkilled>:
void delete_taskkilled(){
  203728:	1141                	addi	sp,sp,-16
  20372a:	e406                	sd	ra,8(sp)
  20372c:	e022                	sd	s0,0(sp)
  20372e:	0800                	addi	s0,sp,16
	printf("\033[1A");
  203730:	00002517          	auipc	a0,0x2
  203734:	0b050513          	addi	a0,a0,176 # 2057e0 <BSS_END+0x778>
  203738:	828ff0ef          	jal	ra,202760 <printf>
	printf("\033[K");
  20373c:	00002517          	auipc	a0,0x2
  203740:	0ac50513          	addi	a0,a0,172 # 2057e8 <BSS_END+0x780>
  203744:	81cff0ef          	jal	ra,202760 <printf>
	printf("\033[1A");
  203748:	00002517          	auipc	a0,0x2
  20374c:	09850513          	addi	a0,a0,152 # 2057e0 <BSS_END+0x778>
  203750:	810ff0ef          	jal	ra,202760 <printf>
	printf("\033[K");
  203754:	00002517          	auipc	a0,0x2
  203758:	09450513          	addi	a0,a0,148 # 2057e8 <BSS_END+0x780>
  20375c:	804ff0ef          	jal	ra,202760 <printf>
	printf("\033[1A");
  203760:	00002517          	auipc	a0,0x2
  203764:	08050513          	addi	a0,a0,128 # 2057e0 <BSS_END+0x778>
  203768:	ff9fe0ef          	jal	ra,202760 <printf>
	printf("\033[K");
  20376c:	00002517          	auipc	a0,0x2
  203770:	07c50513          	addi	a0,a0,124 # 2057e8 <BSS_END+0x780>
  203774:	fedfe0ef          	jal	ra,202760 <printf>
	printf("\033[1A");
  203778:	00002517          	auipc	a0,0x2
  20377c:	06850513          	addi	a0,a0,104 # 2057e0 <BSS_END+0x778>
  203780:	fe1fe0ef          	jal	ra,202760 <printf>
	printf("\033[K");
  203784:	00002517          	auipc	a0,0x2
  203788:	06450513          	addi	a0,a0,100 # 2057e8 <BSS_END+0x780>
  20378c:	fd5fe0ef          	jal	ra,202760 <printf>
}
  203790:	0001                	nop
  203792:	60a2                	ld	ra,8(sp)
  203794:	6402                	ld	s0,0(sp)
  203796:	0141                	addi	sp,sp,16
  203798:	8082                	ret

000000000020379a <print_taskcontroller_created>:
void print_taskcontroller_created(){
  20379a:	1141                	addi	sp,sp,-16
  20379c:	e406                	sd	ra,8(sp)
  20379e:	e022                	sd	s0,0(sp)
  2037a0:	0800                	addi	s0,sp,16
	printf("#########################################################\n\r");
  2037a2:	00002517          	auipc	a0,0x2
  2037a6:	d2650513          	addi	a0,a0,-730 # 2054c8 <BSS_END+0x460>
  2037aa:	fb7fe0ef          	jal	ra,202760 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  2037ae:	00002517          	auipc	a0,0x2
  2037b2:	d5a50513          	addi	a0,a0,-678 # 205508 <BSS_END+0x4a0>
  2037b6:	fabfe0ef          	jal	ra,202760 <printf>
	printf("##              TASK CONTROLLER CREATED                ##\n\r");
  2037ba:	00002517          	auipc	a0,0x2
  2037be:	03650513          	addi	a0,a0,54 # 2057f0 <BSS_END+0x788>
  2037c2:	f9ffe0ef          	jal	ra,202760 <printf>
	printf("#########################################################\n\r");
  2037c6:	00002517          	auipc	a0,0x2
  2037ca:	d0250513          	addi	a0,a0,-766 # 2054c8 <BSS_END+0x460>
  2037ce:	f93fe0ef          	jal	ra,202760 <printf>
  2037d2:	0001                	nop
  2037d4:	60a2                	ld	ra,8(sp)
  2037d6:	6402                	ld	s0,0(sp)
  2037d8:	0141                	addi	sp,sp,16
  2037da:	8082                	ret

00000000002037dc <w_mscratch>:
static void w_mscratch(reg_t x){
  2037dc:	1101                	addi	sp,sp,-32
  2037de:	ec22                	sd	s0,24(sp)
  2037e0:	1000                	addi	s0,sp,32
  2037e2:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  2037e6:	fe843783          	ld	a5,-24(s0)
  2037ea:	34079073          	csrw	mscratch,a5
}
  2037ee:	0001                	nop
  2037f0:	6462                	ld	s0,24(sp)
  2037f2:	6105                	addi	sp,sp,32
  2037f4:	8082                	ret

00000000002037f6 <r_mscratch>:
static reg_t r_mscratch(){
  2037f6:	1101                	addi	sp,sp,-32
  2037f8:	ec22                	sd	s0,24(sp)
  2037fa:	1000                	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  2037fc:	340027f3          	csrr	a5,mscratch
  203800:	fef43423          	sd	a5,-24(s0)
	return ret;
  203804:	fe843783          	ld	a5,-24(s0)
}
  203808:	853e                	mv	a0,a5
  20380a:	6462                	ld	s0,24(sp)
  20380c:	6105                	addi	sp,sp,32
  20380e:	8082                	ret

0000000000203810 <r_mie>:
{
  203810:	1101                	addi	sp,sp,-32
  203812:	ec22                	sd	s0,24(sp)
  203814:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  203816:	304027f3          	csrr	a5,mie
  20381a:	fef43423          	sd	a5,-24(s0)
	return x;
  20381e:	fe843783          	ld	a5,-24(s0)
}
  203822:	853e                	mv	a0,a5
  203824:	6462                	ld	s0,24(sp)
  203826:	6105                	addi	sp,sp,32
  203828:	8082                	ret

000000000020382a <w_mie>:
{
  20382a:	1101                	addi	sp,sp,-32
  20382c:	ec22                	sd	s0,24(sp)
  20382e:	1000                	addi	s0,sp,32
  203830:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
  203834:	fe843783          	ld	a5,-24(s0)
  203838:	30479073          	csrw	mie,a5
}
  20383c:	0001                	nop
  20383e:	6462                	ld	s0,24(sp)
  203840:	6105                	addi	sp,sp,32
  203842:	8082                	ret

0000000000203844 <get_time>:
static uint64_t get_time(){
  203844:	1141                	addi	sp,sp,-16
  203846:	e422                	sd	s0,8(sp)
  203848:	0800                	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  20384a:	00003797          	auipc	a5,0x3
  20384e:	c4678793          	addi	a5,a5,-954 # 206490 <_tick>
  203852:	6398                	ld	a4,0(a5)
  203854:	03c00793          	li	a5,60
  203858:	02f757b3          	divu	a5,a4,a5
}
  20385c:	853e                	mv	a0,a5
  20385e:	6422                	ld	s0,8(sp)
  203860:	0141                	addi	sp,sp,16
  203862:	8082                	ret

0000000000203864 <get_time_str>:
static void get_time_str(char* time){
  203864:	7139                	addi	sp,sp,-64
  203866:	fc22                	sd	s0,56(sp)
  203868:	0080                	addi	s0,sp,64
  20386a:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  20386e:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  203872:	00003797          	auipc	a5,0x3
  203876:	c1e78793          	addi	a5,a5,-994 # 206490 <_tick>
  20387a:	6398                	ld	a4,0(a5)
  20387c:	03c00793          	li	a5,60
  203880:	02f757b3          	divu	a5,a4,a5
  203884:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  203888:	fe043703          	ld	a4,-32(s0)
  20388c:	6785                	lui	a5,0x1
  20388e:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  203892:	02f757b3          	divu	a5,a4,a5
  203896:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  20389a:	fdf44703          	lbu	a4,-33(s0)
  20389e:	06400793          	li	a5,100
  2038a2:	02f777bb          	remuw	a5,a4,a5
  2038a6:	0ff7f793          	andi	a5,a5,255
  2038aa:	873e                	mv	a4,a5
  2038ac:	47a9                	li	a5,10
  2038ae:	02f757bb          	divuw	a5,a4,a5
  2038b2:	0ff7f793          	andi	a5,a5,255
  2038b6:	0307879b          	addiw	a5,a5,48
  2038ba:	0ff7f713          	andi	a4,a5,255
  2038be:	fc843783          	ld	a5,-56(s0)
  2038c2:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  2038c6:	fdf44703          	lbu	a4,-33(s0)
  2038ca:	47a9                	li	a5,10
  2038cc:	02f777bb          	remuw	a5,a4,a5
  2038d0:	0ff7f713          	andi	a4,a5,255
  2038d4:	fc843783          	ld	a5,-56(s0)
  2038d8:	0785                	addi	a5,a5,1
  2038da:	0307071b          	addiw	a4,a4,48
  2038de:	0ff77713          	andi	a4,a4,255
  2038e2:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  2038e6:	fc843783          	ld	a5,-56(s0)
  2038ea:	0789                	addi	a5,a5,2
  2038ec:	03a00713          	li	a4,58
  2038f0:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  2038f4:	fe043703          	ld	a4,-32(s0)
  2038f8:	6785                	lui	a5,0x1
  2038fa:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2038fe:	02f77733          	remu	a4,a4,a5
  203902:	03c00793          	li	a5,60
  203906:	02f757b3          	divu	a5,a4,a5
  20390a:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  20390e:	fdf44703          	lbu	a4,-33(s0)
  203912:	47a9                	li	a5,10
  203914:	02f757bb          	divuw	a5,a4,a5
  203918:	0ff7f713          	andi	a4,a5,255
  20391c:	fc843783          	ld	a5,-56(s0)
  203920:	078d                	addi	a5,a5,3
  203922:	0307071b          	addiw	a4,a4,48
  203926:	0ff77713          	andi	a4,a4,255
  20392a:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  20392e:	fdf44703          	lbu	a4,-33(s0)
  203932:	47a9                	li	a5,10
  203934:	02f777bb          	remuw	a5,a4,a5
  203938:	0ff7f713          	andi	a4,a5,255
  20393c:	fc843783          	ld	a5,-56(s0)
  203940:	0791                	addi	a5,a5,4
  203942:	0307071b          	addiw	a4,a4,48
  203946:	0ff77713          	andi	a4,a4,255
  20394a:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  20394e:	fc843783          	ld	a5,-56(s0)
  203952:	0795                	addi	a5,a5,5
  203954:	03a00713          	li	a4,58
  203958:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  20395c:	fe043703          	ld	a4,-32(s0)
  203960:	03c00793          	li	a5,60
  203964:	02f777b3          	remu	a5,a4,a5
  203968:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  20396c:	fdf44703          	lbu	a4,-33(s0)
  203970:	47a9                	li	a5,10
  203972:	02f757bb          	divuw	a5,a4,a5
  203976:	0ff7f713          	andi	a4,a5,255
  20397a:	fc843783          	ld	a5,-56(s0)
  20397e:	0799                	addi	a5,a5,6
  203980:	0307071b          	addiw	a4,a4,48
  203984:	0ff77713          	andi	a4,a4,255
  203988:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  20398c:	fdf44703          	lbu	a4,-33(s0)
  203990:	47a9                	li	a5,10
  203992:	02f777bb          	remuw	a5,a4,a5
  203996:	0ff7f713          	andi	a4,a5,255
  20399a:	fc843783          	ld	a5,-56(s0)
  20399e:	079d                	addi	a5,a5,7
  2039a0:	0307071b          	addiw	a4,a4,48
  2039a4:	0ff77713          	andi	a4,a4,255
  2039a8:	00e78023          	sb	a4,0(a5)
}
  2039ac:	0001                	nop
  2039ae:	7462                	ld	s0,56(sp)
  2039b0:	6121                	addi	sp,sp,64
  2039b2:	8082                	ret

00000000002039b4 <get_priority>:
static int _num = 0;
static int _current = -1;



uint8_t get_priority(){
  2039b4:	1101                	addi	sp,sp,-32
  2039b6:	ec06                	sd	ra,24(sp)
  2039b8:	e822                	sd	s0,16(sp)
  2039ba:	1000                	addi	s0,sp,32
	struct context* pmycontext = r_mscratch();
  2039bc:	e3bff0ef          	jal	ra,2037f6 <r_mscratch>
  2039c0:	87aa                	mv	a5,a0
  2039c2:	fef43423          	sd	a5,-24(s0)
	return pmycontext->priority;
  2039c6:	fe843783          	ld	a5,-24(s0)
  2039ca:	1007c783          	lbu	a5,256(a5)
}
  2039ce:	853e                	mv	a0,a5
  2039d0:	60e2                	ld	ra,24(sp)
  2039d2:	6442                	ld	s0,16(sp)
  2039d4:	6105                	addi	sp,sp,32
  2039d6:	8082                	ret

00000000002039d8 <newpriority>:

void newpriority(){
  2039d8:	1101                	addi	sp,sp,-32
  2039da:	ec06                	sd	ra,24(sp)
  2039dc:	e822                	sd	s0,16(sp)
  2039de:	1000                	addi	s0,sp,32
	_min_priority = 255;
  2039e0:	00002797          	auipc	a5,0x2
  2039e4:	64078793          	addi	a5,a5,1600 # 206020 <_min_priority>
  2039e8:	577d                	li	a4,-1
  2039ea:	00e78023          	sb	a4,0(a5)
	for (int i=0; i < MAX_TASKS; i++){
  2039ee:	fe042623          	sw	zero,-20(s0)
  2039f2:	a8bd                	j	203a70 <newpriority+0x98>
		if ((ctx_tasks[i].flags == 1) && (ctx_tasks[i].priority < _min_priority))	_min_priority = ctx_tasks[i].priority;
  2039f4:	00006697          	auipc	a3,0x6
  2039f8:	c2c68693          	addi	a3,a3,-980 # 209620 <ctx_tasks>
  2039fc:	fec42703          	lw	a4,-20(s0)
  203a00:	87ba                	mv	a5,a4
  203a02:	0796                	slli	a5,a5,0x5
  203a04:	97ba                	add	a5,a5,a4
  203a06:	078e                	slli	a5,a5,0x3
  203a08:	97b6                	add	a5,a5,a3
  203a0a:	1017c783          	lbu	a5,257(a5)
  203a0e:	873e                	mv	a4,a5
  203a10:	4785                	li	a5,1
  203a12:	04f71a63          	bne	a4,a5,203a66 <newpriority+0x8e>
  203a16:	00006697          	auipc	a3,0x6
  203a1a:	c0a68693          	addi	a3,a3,-1014 # 209620 <ctx_tasks>
  203a1e:	fec42703          	lw	a4,-20(s0)
  203a22:	87ba                	mv	a5,a4
  203a24:	0796                	slli	a5,a5,0x5
  203a26:	97ba                	add	a5,a5,a4
  203a28:	078e                	slli	a5,a5,0x3
  203a2a:	97b6                	add	a5,a5,a3
  203a2c:	1007c703          	lbu	a4,256(a5)
  203a30:	00002797          	auipc	a5,0x2
  203a34:	5f078793          	addi	a5,a5,1520 # 206020 <_min_priority>
  203a38:	0007c783          	lbu	a5,0(a5)
  203a3c:	02f77563          	bgeu	a4,a5,203a66 <newpriority+0x8e>
  203a40:	00006697          	auipc	a3,0x6
  203a44:	be068693          	addi	a3,a3,-1056 # 209620 <ctx_tasks>
  203a48:	fec42703          	lw	a4,-20(s0)
  203a4c:	87ba                	mv	a5,a4
  203a4e:	0796                	slli	a5,a5,0x5
  203a50:	97ba                	add	a5,a5,a4
  203a52:	078e                	slli	a5,a5,0x3
  203a54:	97b6                	add	a5,a5,a3
  203a56:	1007c703          	lbu	a4,256(a5)
  203a5a:	00002797          	auipc	a5,0x2
  203a5e:	5c678793          	addi	a5,a5,1478 # 206020 <_min_priority>
  203a62:	00e78023          	sb	a4,0(a5)
	for (int i=0; i < MAX_TASKS; i++){
  203a66:	fec42783          	lw	a5,-20(s0)
  203a6a:	2785                	addiw	a5,a5,1
  203a6c:	fef42623          	sw	a5,-20(s0)
  203a70:	fec42783          	lw	a5,-20(s0)
  203a74:	0007871b          	sext.w	a4,a5
  203a78:	47a5                	li	a5,9
  203a7a:	f6e7dde3          	bge	a5,a4,2039f4 <newpriority+0x1c>
	}
	#ifdef MYPRINT
	printf("new priority:%d\n\r", _min_priority);
  203a7e:	00002797          	auipc	a5,0x2
  203a82:	5a278793          	addi	a5,a5,1442 # 206020 <_min_priority>
  203a86:	0007c783          	lbu	a5,0(a5)
  203a8a:	2781                	sext.w	a5,a5
  203a8c:	85be                	mv	a1,a5
  203a8e:	00002517          	auipc	a0,0x2
  203a92:	daa50513          	addi	a0,a0,-598 # 205838 <BSS_END+0x7d0>
  203a96:	ccbfe0ef          	jal	ra,202760 <printf>
	#endif

}
  203a9a:	0001                	nop
  203a9c:	60e2                	ld	ra,24(sp)
  203a9e:	6442                	ld	s0,16(sp)
  203aa0:	6105                	addi	sp,sp,32
  203aa2:	8082                	ret

0000000000203aa4 <schedule>:
/*
 * implment a simple cycle FIFO schedular
 */
void schedule()
{
  203aa4:	1101                	addi	sp,sp,-32
  203aa6:	ec06                	sd	ra,24(sp)
  203aa8:	e822                	sd	s0,16(sp)
  203aaa:	1000                	addi	s0,sp,32

	struct context *next = &(ctx_tasks[0]);
  203aac:	00006797          	auipc	a5,0x6
  203ab0:	b7478793          	addi	a5,a5,-1164 # 209620 <ctx_tasks>
  203ab4:	fef43423          	sd	a5,-24(s0)
	if (next -> flags == 0) return;			//no task controller
  203ab8:	fe843783          	ld	a5,-24(s0)
  203abc:	1017c783          	lbu	a5,257(a5)
  203ac0:	cf81                	beqz	a5,203ad8 <schedule+0x34>
	_slice = 0;
  203ac2:	00003797          	auipc	a5,0x3
  203ac6:	9d678793          	addi	a5,a5,-1578 # 206498 <_slice>
  203aca:	0007b023          	sd	zero,0(a5)
	switch_to(next);
  203ace:	fe843503          	ld	a0,-24(s0)
  203ad2:	e8afe0ef          	jal	ra,20215c <switch_to>
  203ad6:	a011                	j	203ada <schedule+0x36>
	if (next -> flags == 0) return;			//no task controller
  203ad8:	0001                	nop
}
  203ada:	60e2                	ld	ra,24(sp)
  203adc:	6442                	ld	s0,16(sp)
  203ade:	6105                	addi	sp,sp,32
  203ae0:	8082                	ret

0000000000203ae2 <task_exit>:

void task_exit(){
  203ae2:	1141                	addi	sp,sp,-16
  203ae4:	e406                	sd	ra,8(sp)
  203ae6:	e022                	sd	s0,0(sp)
  203ae8:	0800                	addi	s0,sp,16
	_num--;
  203aea:	00003797          	auipc	a5,0x3
  203aee:	9c678793          	addi	a5,a5,-1594 # 2064b0 <_num>
  203af2:	439c                	lw	a5,0(a5)
  203af4:	37fd                	addiw	a5,a5,-1
  203af6:	0007871b          	sext.w	a4,a5
  203afa:	00003797          	auipc	a5,0x3
  203afe:	9b678793          	addi	a5,a5,-1610 # 2064b0 <_num>
  203b02:	c398                	sw	a4,0(a5)
	call_software_interrupt(SOFTWARE_USER_KILLMYSELF, (uint64_t)&ctx_tasks[0]);
  203b04:	00006797          	auipc	a5,0x6
  203b08:	b1c78793          	addi	a5,a5,-1252 # 209620 <ctx_tasks>
  203b0c:	85be                	mv	a1,a5
  203b0e:	4511                	li	a0,4
  203b10:	481000ef          	jal	ra,204790 <call_software_interrupt>
}
  203b14:	0001                	nop
  203b16:	60a2                	ld	ra,8(sp)
  203b18:	6402                	ld	s0,0(sp)
  203b1a:	0141                	addi	sp,sp,16
  203b1c:	8082                	ret

0000000000203b1e <task_create>:
 * RETURN VALUE
 * 	0: success
 * 	-1: if error occured
 */
int task_create(void (*start_routin)(void* ), void* param, uint8_t priority)
{
  203b1e:	7139                	addi	sp,sp,-64
  203b20:	fc06                	sd	ra,56(sp)
  203b22:	f822                	sd	s0,48(sp)
  203b24:	0080                	addi	s0,sp,64
  203b26:	fca43c23          	sd	a0,-40(s0)
  203b2a:	fcb43823          	sd	a1,-48(s0)
  203b2e:	87b2                	mv	a5,a2
  203b30:	fcf407a3          	sb	a5,-49(s0)
	if (_num < MAX_TASKS) {
  203b34:	00003797          	auipc	a5,0x3
  203b38:	97c78793          	addi	a5,a5,-1668 # 2064b0 <_num>
  203b3c:	439c                	lw	a5,0(a5)
  203b3e:	873e                	mv	a4,a5
  203b40:	47a5                	li	a5,9
  203b42:	16e7c263          	blt	a5,a4,203ca6 <task_create+0x188>
		int tmp = 0;
  203b46:	fe042623          	sw	zero,-20(s0)
		while (ctx_tasks[tmp].flags == 1) tmp = (tmp + 1) % MAX_TASKS;
  203b4a:	a819                	j	203b60 <task_create+0x42>
  203b4c:	fec42783          	lw	a5,-20(s0)
  203b50:	2785                	addiw	a5,a5,1
  203b52:	2781                	sext.w	a5,a5
  203b54:	873e                	mv	a4,a5
  203b56:	47a9                	li	a5,10
  203b58:	02f767bb          	remw	a5,a4,a5
  203b5c:	fef42623          	sw	a5,-20(s0)
  203b60:	00006697          	auipc	a3,0x6
  203b64:	ac068693          	addi	a3,a3,-1344 # 209620 <ctx_tasks>
  203b68:	fec42703          	lw	a4,-20(s0)
  203b6c:	87ba                	mv	a5,a4
  203b6e:	0796                	slli	a5,a5,0x5
  203b70:	97ba                	add	a5,a5,a4
  203b72:	078e                	slli	a5,a5,0x3
  203b74:	97b6                	add	a5,a5,a3
  203b76:	1017c783          	lbu	a5,257(a5)
  203b7a:	873e                	mv	a4,a5
  203b7c:	4785                	li	a5,1
  203b7e:	fcf707e3          	beq	a4,a5,203b4c <task_create+0x2e>
		ctx_tasks[tmp].sp = (reg_t) &task_stack[tmp][STACK_SIZE];
  203b82:	fec42783          	lw	a5,-20(s0)
  203b86:	0785                	addi	a5,a5,1
  203b88:	00a79713          	slli	a4,a5,0xa
  203b8c:	00003797          	auipc	a5,0x3
  203b90:	29478793          	addi	a5,a5,660 # 206e20 <task_stack>
  203b94:	97ba                	add	a5,a5,a4
  203b96:	863e                	mv	a2,a5
  203b98:	00006697          	auipc	a3,0x6
  203b9c:	a8868693          	addi	a3,a3,-1400 # 209620 <ctx_tasks>
  203ba0:	fec42703          	lw	a4,-20(s0)
  203ba4:	87ba                	mv	a5,a4
  203ba6:	0796                	slli	a5,a5,0x5
  203ba8:	97ba                	add	a5,a5,a4
  203baa:	078e                	slli	a5,a5,0x3
  203bac:	97b6                	add	a5,a5,a3
  203bae:	e790                	sd	a2,8(a5)
		ctx_tasks[tmp].a0 = (reg_t) param;
  203bb0:	fd043683          	ld	a3,-48(s0)
  203bb4:	00006617          	auipc	a2,0x6
  203bb8:	a6c60613          	addi	a2,a2,-1428 # 209620 <ctx_tasks>
  203bbc:	fec42703          	lw	a4,-20(s0)
  203bc0:	87ba                	mv	a5,a4
  203bc2:	0796                	slli	a5,a5,0x5
  203bc4:	97ba                	add	a5,a5,a4
  203bc6:	078e                	slli	a5,a5,0x3
  203bc8:	97b2                	add	a5,a5,a2
  203bca:	e7b4                	sd	a3,72(a5)
		ctx_tasks[tmp].priority = priority;
  203bcc:	00006697          	auipc	a3,0x6
  203bd0:	a5468693          	addi	a3,a3,-1452 # 209620 <ctx_tasks>
  203bd4:	fec42703          	lw	a4,-20(s0)
  203bd8:	87ba                	mv	a5,a4
  203bda:	0796                	slli	a5,a5,0x5
  203bdc:	97ba                	add	a5,a5,a4
  203bde:	078e                	slli	a5,a5,0x3
  203be0:	97b6                	add	a5,a5,a3
  203be2:	fcf44703          	lbu	a4,-49(s0)
  203be6:	10e78023          	sb	a4,256(a5)
		ctx_tasks[tmp].flags = 1;
  203bea:	00006697          	auipc	a3,0x6
  203bee:	a3668693          	addi	a3,a3,-1482 # 209620 <ctx_tasks>
  203bf2:	fec42703          	lw	a4,-20(s0)
  203bf6:	87ba                	mv	a5,a4
  203bf8:	0796                	slli	a5,a5,0x5
  203bfa:	97ba                	add	a5,a5,a4
  203bfc:	078e                	slli	a5,a5,0x3
  203bfe:	97b6                	add	a5,a5,a3
  203c00:	4705                	li	a4,1
  203c02:	10e780a3          	sb	a4,257(a5)
		ctx_tasks[tmp].mepc = start_routin;
  203c06:	fd843683          	ld	a3,-40(s0)
  203c0a:	00006617          	auipc	a2,0x6
  203c0e:	a1660613          	addi	a2,a2,-1514 # 209620 <ctx_tasks>
  203c12:	fec42703          	lw	a4,-20(s0)
  203c16:	87ba                	mv	a5,a4
  203c18:	0796                	slli	a5,a5,0x5
  203c1a:	97ba                	add	a5,a5,a4
  203c1c:	078e                	slli	a5,a5,0x3
  203c1e:	97b2                	add	a5,a5,a2
  203c20:	fff4                	sd	a3,248(a5)
		#ifdef MYPRINT
		printf("my mepc is %p \n\r", ctx_tasks[tmp].mepc);
  203c22:	00006697          	auipc	a3,0x6
  203c26:	9fe68693          	addi	a3,a3,-1538 # 209620 <ctx_tasks>
  203c2a:	fec42703          	lw	a4,-20(s0)
  203c2e:	87ba                	mv	a5,a4
  203c30:	0796                	slli	a5,a5,0x5
  203c32:	97ba                	add	a5,a5,a4
  203c34:	078e                	slli	a5,a5,0x3
  203c36:	97b6                	add	a5,a5,a3
  203c38:	7ffc                	ld	a5,248(a5)
  203c3a:	85be                	mv	a1,a5
  203c3c:	00002517          	auipc	a0,0x2
  203c40:	c1450513          	addi	a0,a0,-1004 # 205850 <BSS_END+0x7e8>
  203c44:	b1dfe0ef          	jal	ra,202760 <printf>
		#endif
		_num++;
  203c48:	00003797          	auipc	a5,0x3
  203c4c:	86878793          	addi	a5,a5,-1944 # 2064b0 <_num>
  203c50:	439c                	lw	a5,0(a5)
  203c52:	2785                	addiw	a5,a5,1
  203c54:	0007871b          	sext.w	a4,a5
  203c58:	00003797          	auipc	a5,0x3
  203c5c:	85878793          	addi	a5,a5,-1960 # 2064b0 <_num>
  203c60:	c398                	sw	a4,0(a5)
		if (_num == 1) print_taskcontroller_created();
  203c62:	00003797          	auipc	a5,0x3
  203c66:	84e78793          	addi	a5,a5,-1970 # 2064b0 <_num>
  203c6a:	439c                	lw	a5,0(a5)
  203c6c:	873e                	mv	a4,a5
  203c6e:	4785                	li	a5,1
  203c70:	00f71563          	bne	a4,a5,203c7a <task_create+0x15c>
  203c74:	b27ff0ef          	jal	ra,20379a <print_taskcontroller_created>
  203c78:	a02d                	j	203ca2 <task_create+0x184>
		else if (priority < _min_priority) _min_priority = priority;//find the best task level
  203c7a:	00002797          	auipc	a5,0x2
  203c7e:	3a678793          	addi	a5,a5,934 # 206020 <_min_priority>
  203c82:	0007c703          	lbu	a4,0(a5)
  203c86:	fcf44783          	lbu	a5,-49(s0)
  203c8a:	0ff7f793          	andi	a5,a5,255
  203c8e:	00e7fa63          	bgeu	a5,a4,203ca2 <task_create+0x184>
  203c92:	00002797          	auipc	a5,0x2
  203c96:	38e78793          	addi	a5,a5,910 # 206020 <_min_priority>
  203c9a:	fcf44703          	lbu	a4,-49(s0)
  203c9e:	00e78023          	sb	a4,0(a5)
		return 0;
  203ca2:	4781                	li	a5,0
  203ca4:	a011                	j	203ca8 <task_create+0x18a>
	} else {
		return -1;
  203ca6:	57fd                	li	a5,-1
	}
}
  203ca8:	853e                	mv	a0,a5
  203caa:	70e2                	ld	ra,56(sp)
  203cac:	7442                	ld	s0,48(sp)
  203cae:	6121                	addi	sp,sp,64
  203cb0:	8082                	ret

0000000000203cb2 <task_yield>:
 * DESCRIPTION
 * 	task_yield()  causes the calling task to relinquish the CPU and a new 
 * 	task gets to run.
 */
void task_yield()
{
  203cb2:	1141                	addi	sp,sp,-16
  203cb4:	e406                	sd	ra,8(sp)
  203cb6:	e022                	sd	s0,0(sp)
  203cb8:	0800                	addi	s0,sp,16
	call_software_interrupt(SOFTWARE_USER_SWITCH_FLAG, 0);
  203cba:	4581                	li	a1,0
  203cbc:	450d                	li	a0,3
  203cbe:	2d3000ef          	jal	ra,204790 <call_software_interrupt>
}
  203cc2:	0001                	nop
  203cc4:	60a2                	ld	ra,8(sp)
  203cc6:	6402                	ld	s0,0(sp)
  203cc8:	0141                	addi	sp,sp,16
  203cca:	8082                	ret

0000000000203ccc <task_delay>:
 * a very rough implementaion, just to consume the cpu
 */

#define DELAY 1000
void task_delay(volatile int count)
{
  203ccc:	1101                	addi	sp,sp,-32
  203cce:	ec22                	sd	s0,24(sp)
  203cd0:	1000                	addi	s0,sp,32
  203cd2:	87aa                	mv	a5,a0
  203cd4:	fef42623          	sw	a5,-20(s0)
	count *= 50000;
  203cd8:	fec42783          	lw	a5,-20(s0)
  203cdc:	0007871b          	sext.w	a4,a5
  203ce0:	67b1                	lui	a5,0xc
  203ce2:	3507879b          	addiw	a5,a5,848
  203ce6:	02f707bb          	mulw	a5,a4,a5
  203cea:	2781                	sext.w	a5,a5
  203cec:	fef42623          	sw	a5,-20(s0)
	while (count--);
  203cf0:	0001                	nop
  203cf2:	fec42783          	lw	a5,-20(s0)
  203cf6:	2781                	sext.w	a5,a5
  203cf8:	fff7871b          	addiw	a4,a5,-1
  203cfc:	2701                	sext.w	a4,a4
  203cfe:	fee42623          	sw	a4,-20(s0)
  203d02:	fbe5                	bnez	a5,203cf2 <task_delay+0x26>
}
  203d04:	0001                	nop
  203d06:	6462                	ld	s0,24(sp)
  203d08:	6105                	addi	sp,sp,32
  203d0a:	8082                	ret

0000000000203d0c <kernel_schedule>:

//kernel use this function to switch to task controller
void kernel_schedule(){
  203d0c:	1101                	addi	sp,sp,-32
  203d0e:	ec06                	sd	ra,24(sp)
  203d10:	e822                	sd	s0,16(sp)
  203d12:	1000                	addi	s0,sp,32
	struct context * tmpcontext = &ctx_tasks[0];
  203d14:	00006797          	auipc	a5,0x6
  203d18:	90c78793          	addi	a5,a5,-1780 # 209620 <ctx_tasks>
  203d1c:	fef43423          	sd	a5,-24(s0)
	call_software_interrupt(SOFTWARE_KERNEL_SWITCH, (uint64_t)tmpcontext);
  203d20:	fe843783          	ld	a5,-24(s0)
  203d24:	85be                	mv	a1,a5
  203d26:	4505                	li	a0,1
  203d28:	269000ef          	jal	ra,204790 <call_software_interrupt>
}
  203d2c:	0001                	nop
  203d2e:	60e2                	ld	ra,24(sp)
  203d30:	6442                	ld	s0,16(sp)
  203d32:	6105                	addi	sp,sp,32
  203d34:	8082                	ret

0000000000203d36 <task_controller>:

static void task_controller(void* param){
  203d36:	7179                	addi	sp,sp,-48
  203d38:	f406                	sd	ra,40(sp)
  203d3a:	f022                	sd	s0,32(sp)
  203d3c:	1800                	addi	s0,sp,48
  203d3e:	fca43c23          	sd	a0,-40(s0)
	static int next_task = 0;
	while (1){
	if (_num <= 1) {
  203d42:	00002797          	auipc	a5,0x2
  203d46:	76e78793          	addi	a5,a5,1902 # 2064b0 <_num>
  203d4a:	439c                	lw	a5,0(a5)
  203d4c:	873e                	mv	a4,a5
  203d4e:	4785                	li	a5,1
  203d50:	00e7c963          	blt	a5,a4,203d62 <task_controller+0x2c>
		panic("Num of task should be greater than zero!");
  203d54:	00002517          	auipc	a0,0x2
  203d58:	b1450513          	addi	a0,a0,-1260 # 205868 <BSS_END+0x800>
  203d5c:	a55fe0ef          	jal	ra,2027b0 <panic>
		return;
  203d60:	aa31                	j	203e7c <task_controller+0x146>
	}else{
		printf("\033[33mI am task controller!\n\r");
  203d62:	00002517          	auipc	a0,0x2
  203d66:	b3650513          	addi	a0,a0,-1226 # 205898 <BSS_END+0x830>
  203d6a:	9f7fe0ef          	jal	ra,202760 <printf>
		next_task  = next_task % MAX_TASKS + 1;
  203d6e:	00002797          	auipc	a5,0x2
  203d72:	74678793          	addi	a5,a5,1862 # 2064b4 <next_task.1209>
  203d76:	439c                	lw	a5,0(a5)
  203d78:	873e                	mv	a4,a5
  203d7a:	47a9                	li	a5,10
  203d7c:	02f767bb          	remw	a5,a4,a5
  203d80:	2781                	sext.w	a5,a5
  203d82:	2785                	addiw	a5,a5,1
  203d84:	0007871b          	sext.w	a4,a5
  203d88:	00002797          	auipc	a5,0x2
  203d8c:	72c78793          	addi	a5,a5,1836 # 2064b4 <next_task.1209>
  203d90:	c398                	sw	a4,0(a5)
		while ((ctx_tasks[next_task].flags == 0) || (ctx_tasks[next_task].priority != _min_priority)) {
  203d92:	a01d                	j	203db8 <task_controller+0x82>
			next_task  = next_task % MAX_TASKS + 1;
  203d94:	00002797          	auipc	a5,0x2
  203d98:	72078793          	addi	a5,a5,1824 # 2064b4 <next_task.1209>
  203d9c:	439c                	lw	a5,0(a5)
  203d9e:	873e                	mv	a4,a5
  203da0:	47a9                	li	a5,10
  203da2:	02f767bb          	remw	a5,a4,a5
  203da6:	2781                	sext.w	a5,a5
  203da8:	2785                	addiw	a5,a5,1
  203daa:	0007871b          	sext.w	a4,a5
  203dae:	00002797          	auipc	a5,0x2
  203db2:	70678793          	addi	a5,a5,1798 # 2064b4 <next_task.1209>
  203db6:	c398                	sw	a4,0(a5)
		while ((ctx_tasks[next_task].flags == 0) || (ctx_tasks[next_task].priority != _min_priority)) {
  203db8:	00002797          	auipc	a5,0x2
  203dbc:	6fc78793          	addi	a5,a5,1788 # 2064b4 <next_task.1209>
  203dc0:	4398                	lw	a4,0(a5)
  203dc2:	00006697          	auipc	a3,0x6
  203dc6:	85e68693          	addi	a3,a3,-1954 # 209620 <ctx_tasks>
  203dca:	87ba                	mv	a5,a4
  203dcc:	0796                	slli	a5,a5,0x5
  203dce:	97ba                	add	a5,a5,a4
  203dd0:	078e                	slli	a5,a5,0x3
  203dd2:	97b6                	add	a5,a5,a3
  203dd4:	1017c783          	lbu	a5,257(a5)
  203dd8:	dfd5                	beqz	a5,203d94 <task_controller+0x5e>
  203dda:	00002797          	auipc	a5,0x2
  203dde:	6da78793          	addi	a5,a5,1754 # 2064b4 <next_task.1209>
  203de2:	4398                	lw	a4,0(a5)
  203de4:	00006697          	auipc	a3,0x6
  203de8:	83c68693          	addi	a3,a3,-1988 # 209620 <ctx_tasks>
  203dec:	87ba                	mv	a5,a4
  203dee:	0796                	slli	a5,a5,0x5
  203df0:	97ba                	add	a5,a5,a4
  203df2:	078e                	slli	a5,a5,0x3
  203df4:	97b6                	add	a5,a5,a3
  203df6:	1007c703          	lbu	a4,256(a5)
  203dfa:	00002797          	auipc	a5,0x2
  203dfe:	22678793          	addi	a5,a5,550 # 206020 <_min_priority>
  203e02:	0007c783          	lbu	a5,0(a5)
  203e06:	f8f717e3          	bne	a4,a5,203d94 <task_controller+0x5e>
		}
		printf("I am goint to switch to %dth task\033[0m\n\r", next_task);
  203e0a:	00002797          	auipc	a5,0x2
  203e0e:	6aa78793          	addi	a5,a5,1706 # 2064b4 <next_task.1209>
  203e12:	439c                	lw	a5,0(a5)
  203e14:	85be                	mv	a1,a5
  203e16:	00002517          	auipc	a0,0x2
  203e1a:	aa250513          	addi	a0,a0,-1374 # 2058b8 <BSS_END+0x850>
  203e1e:	943fe0ef          	jal	ra,202760 <printf>
		#ifdef MYPRINT
		printf("the mepc of next task is %p\n\r", ctx_tasks[next_task].mepc);
  203e22:	00002797          	auipc	a5,0x2
  203e26:	69278793          	addi	a5,a5,1682 # 2064b4 <next_task.1209>
  203e2a:	4398                	lw	a4,0(a5)
  203e2c:	00005697          	auipc	a3,0x5
  203e30:	7f468693          	addi	a3,a3,2036 # 209620 <ctx_tasks>
  203e34:	87ba                	mv	a5,a4
  203e36:	0796                	slli	a5,a5,0x5
  203e38:	97ba                	add	a5,a5,a4
  203e3a:	078e                	slli	a5,a5,0x3
  203e3c:	97b6                	add	a5,a5,a3
  203e3e:	7ffc                	ld	a5,248(a5)
  203e40:	85be                	mv	a1,a5
  203e42:	00002517          	auipc	a0,0x2
  203e46:	a9e50513          	addi	a0,a0,-1378 # 2058e0 <BSS_END+0x878>
  203e4a:	917fe0ef          	jal	ra,202760 <printf>
		#endif
		struct context * tmpcontext = &ctx_tasks[next_task];
  203e4e:	00002797          	auipc	a5,0x2
  203e52:	66678793          	addi	a5,a5,1638 # 2064b4 <next_task.1209>
  203e56:	4398                	lw	a4,0(a5)
  203e58:	87ba                	mv	a5,a4
  203e5a:	0796                	slli	a5,a5,0x5
  203e5c:	97ba                	add	a5,a5,a4
  203e5e:	078e                	slli	a5,a5,0x3
  203e60:	00005717          	auipc	a4,0x5
  203e64:	7c070713          	addi	a4,a4,1984 # 209620 <ctx_tasks>
  203e68:	97ba                	add	a5,a5,a4
  203e6a:	fef43423          	sd	a5,-24(s0)
		printf("\033[1A");
		printf("\033[K");
		printf("\033[1A");
		printf("\033[K");
		#endif
		call_software_interrupt(SOFTWARE_TASK_CONTROLLER_FLAG, (uint64_t)tmpcontext);
  203e6e:	fe843783          	ld	a5,-24(s0)
  203e72:	85be                	mv	a1,a5
  203e74:	4509                	li	a0,2
  203e76:	11b000ef          	jal	ra,204790 <call_software_interrupt>
	if (_num <= 1) {
  203e7a:	b5e1                	j	203d42 <task_controller+0xc>
	}
	}
}
  203e7c:	70a2                	ld	ra,40(sp)
  203e7e:	7402                	ld	s0,32(sp)
  203e80:	6145                	addi	sp,sp,48
  203e82:	8082                	ret

0000000000203e84 <sched_init>:


void sched_init(int slice)
{
  203e84:	7179                	addi	sp,sp,-48
  203e86:	f406                	sd	ra,40(sp)
  203e88:	f022                	sd	s0,32(sp)
  203e8a:	1800                	addi	s0,sp,48
  203e8c:	87aa                	mv	a5,a0
  203e8e:	fcf42e23          	sw	a5,-36(s0)
	TICKS_PER_SLICE = slice;
  203e92:	fdc42703          	lw	a4,-36(s0)
  203e96:	00002797          	auipc	a5,0x2
  203e9a:	18278793          	addi	a5,a5,386 # 206018 <TICKS_PER_SLICE>
  203e9e:	e398                	sd	a4,0(a5)
	w_mscratch(0);
  203ea0:	4501                	li	a0,0
  203ea2:	93bff0ef          	jal	ra,2037dc <w_mscratch>
	for (int i=0; i < MAX_TASKS; i++){
  203ea6:	fe042623          	sw	zero,-20(s0)
  203eaa:	a01d                	j	203ed0 <sched_init+0x4c>
		ctx_tasks[i].flags = 0;
  203eac:	00005697          	auipc	a3,0x5
  203eb0:	77468693          	addi	a3,a3,1908 # 209620 <ctx_tasks>
  203eb4:	fec42703          	lw	a4,-20(s0)
  203eb8:	87ba                	mv	a5,a4
  203eba:	0796                	slli	a5,a5,0x5
  203ebc:	97ba                	add	a5,a5,a4
  203ebe:	078e                	slli	a5,a5,0x3
  203ec0:	97b6                	add	a5,a5,a3
  203ec2:	100780a3          	sb	zero,257(a5)
	for (int i=0; i < MAX_TASKS; i++){
  203ec6:	fec42783          	lw	a5,-20(s0)
  203eca:	2785                	addiw	a5,a5,1
  203ecc:	fef42623          	sw	a5,-20(s0)
  203ed0:	fec42783          	lw	a5,-20(s0)
  203ed4:	0007871b          	sext.w	a4,a5
  203ed8:	47a5                	li	a5,9
  203eda:	fce7d9e3          	bge	a5,a4,203eac <sched_init+0x28>
	}
	task_create(task_controller, 0, 255);
  203ede:	0ff00613          	li	a2,255
  203ee2:	4581                	li	a1,0
  203ee4:	00000517          	auipc	a0,0x0
  203ee8:	e5250513          	addi	a0,a0,-430 # 203d36 <task_controller>
  203eec:	c33ff0ef          	jal	ra,203b1e <task_create>
	
	/* enable machine-mode software interrupts. */
	w_mie(r_mie() | MIE_MSIE);
  203ef0:	921ff0ef          	jal	ra,203810 <r_mie>
  203ef4:	87aa                	mv	a5,a0
  203ef6:	0087e793          	ori	a5,a5,8
  203efa:	853e                	mv	a0,a5
  203efc:	92fff0ef          	jal	ra,20382a <w_mie>

}
  203f00:	0001                	nop
  203f02:	70a2                	ld	ra,40(sp)
  203f04:	7402                	ld	s0,32(sp)
  203f06:	6145                	addi	sp,sp,48
  203f08:	8082                	ret

0000000000203f0a <isChar>:
#include "goish.h"
static char inputbuffer[256];
char goishbuffer[2048] = "";
static uint8_t ibuffer = 0;
static inline uint8_t isChar(char c){
  203f0a:	1101                	addi	sp,sp,-32
  203f0c:	ec22                	sd	s0,24(sp)
  203f0e:	1000                	addi	s0,sp,32
  203f10:	87aa                	mv	a5,a0
  203f12:	fef407a3          	sb	a5,-17(s0)
    if ((c >= 32) && (c <= 126)) return 1;
  203f16:	fef44783          	lbu	a5,-17(s0)
  203f1a:	0ff7f713          	andi	a4,a5,255
  203f1e:	47fd                	li	a5,31
  203f20:	00e7fc63          	bgeu	a5,a4,203f38 <isChar+0x2e>
  203f24:	fef44783          	lbu	a5,-17(s0)
  203f28:	0ff7f713          	andi	a4,a5,255
  203f2c:	07e00793          	li	a5,126
  203f30:	00e7e463          	bltu	a5,a4,203f38 <isChar+0x2e>
  203f34:	4785                	li	a5,1
  203f36:	a011                	j	203f3a <isChar+0x30>
    return 0;
  203f38:	4781                	li	a5,0
}
  203f3a:	853e                	mv	a0,a5
  203f3c:	6462                	ld	s0,24(sp)
  203f3e:	6105                	addi	sp,sp,32
  203f40:	8082                	ret

0000000000203f42 <strcmp>:
static uint8_t strcmp(char* c1, char* c2){
  203f42:	7179                	addi	sp,sp,-48
  203f44:	f422                	sd	s0,40(sp)
  203f46:	1800                	addi	s0,sp,48
  203f48:	fca43c23          	sd	a0,-40(s0)
  203f4c:	fcb43823          	sd	a1,-48(s0)
    int i = 0;
  203f50:	fe042623          	sw	zero,-20(s0)
    while (c1[i] * c2[i]){
  203f54:	a80d                	j	203f86 <strcmp+0x44>
        if (c1[i] != c2[i]) return 0;
  203f56:	fec42783          	lw	a5,-20(s0)
  203f5a:	fd843703          	ld	a4,-40(s0)
  203f5e:	97ba                	add	a5,a5,a4
  203f60:	0007c683          	lbu	a3,0(a5)
  203f64:	fec42783          	lw	a5,-20(s0)
  203f68:	fd043703          	ld	a4,-48(s0)
  203f6c:	97ba                	add	a5,a5,a4
  203f6e:	0007c783          	lbu	a5,0(a5)
  203f72:	8736                	mv	a4,a3
  203f74:	00f70463          	beq	a4,a5,203f7c <strcmp+0x3a>
  203f78:	4781                	li	a5,0
  203f7a:	a8b9                	j	203fd8 <strcmp+0x96>
        i ++;
  203f7c:	fec42783          	lw	a5,-20(s0)
  203f80:	2785                	addiw	a5,a5,1
  203f82:	fef42623          	sw	a5,-20(s0)
    while (c1[i] * c2[i]){
  203f86:	fec42783          	lw	a5,-20(s0)
  203f8a:	fd843703          	ld	a4,-40(s0)
  203f8e:	97ba                	add	a5,a5,a4
  203f90:	0007c783          	lbu	a5,0(a5)
  203f94:	0007871b          	sext.w	a4,a5
  203f98:	fec42783          	lw	a5,-20(s0)
  203f9c:	fd043683          	ld	a3,-48(s0)
  203fa0:	97b6                	add	a5,a5,a3
  203fa2:	0007c783          	lbu	a5,0(a5)
  203fa6:	2781                	sext.w	a5,a5
  203fa8:	02f707bb          	mulw	a5,a4,a5
  203fac:	2781                	sext.w	a5,a5
  203fae:	f7c5                	bnez	a5,203f56 <strcmp+0x14>
    }
    if (c1[i] != c2[i]) return 0;
  203fb0:	fec42783          	lw	a5,-20(s0)
  203fb4:	fd843703          	ld	a4,-40(s0)
  203fb8:	97ba                	add	a5,a5,a4
  203fba:	0007c683          	lbu	a3,0(a5)
  203fbe:	fec42783          	lw	a5,-20(s0)
  203fc2:	fd043703          	ld	a4,-48(s0)
  203fc6:	97ba                	add	a5,a5,a4
  203fc8:	0007c783          	lbu	a5,0(a5)
  203fcc:	8736                	mv	a4,a3
  203fce:	00f70463          	beq	a4,a5,203fd6 <strcmp+0x94>
  203fd2:	4781                	li	a5,0
  203fd4:	a011                	j	203fd8 <strcmp+0x96>
    return 1;
  203fd6:	4785                	li	a5,1
}
  203fd8:	853e                	mv	a0,a5
  203fda:	7422                	ld	s0,40(sp)
  203fdc:	6145                	addi	sp,sp,48
  203fde:	8082                	ret

0000000000203fe0 <goishfunction>:

static goishfunction(char* str){
  203fe0:	1101                	addi	sp,sp,-32
  203fe2:	ec06                	sd	ra,24(sp)
  203fe4:	e822                	sd	s0,16(sp)
  203fe6:	1000                	addi	s0,sp,32
  203fe8:	fea43423          	sd	a0,-24(s0)
    printf("\n\r");
  203fec:	00002517          	auipc	a0,0x2
  203ff0:	91450513          	addi	a0,a0,-1772 # 205900 <BSS_END+0x898>
  203ff4:	f6cfe0ef          	jal	ra,202760 <printf>
    if (strcmp(str, "WhoAmI")) print_WhoAmI();
  203ff8:	00002597          	auipc	a1,0x2
  203ffc:	91058593          	addi	a1,a1,-1776 # 205908 <BSS_END+0x8a0>
  204000:	fe843503          	ld	a0,-24(s0)
  204004:	f3fff0ef          	jal	ra,203f42 <strcmp>
  204008:	87aa                	mv	a5,a0
  20400a:	c781                	beqz	a5,204012 <goishfunction+0x32>
  20400c:	e00ff0ef          	jal	ra,20360c <print_WhoAmI>
  204010:	a029                	j	20401a <goishfunction+0x3a>
    else printf(str);
  204012:	fe843503          	ld	a0,-24(s0)
  204016:	f4afe0ef          	jal	ra,202760 <printf>
    #ifndef MYPRINT
	printf("\033[1A");
    #endif
}
  20401a:	0001                	nop
  20401c:	853e                	mv	a0,a5
  20401e:	60e2                	ld	ra,24(sp)
  204020:	6442                	ld	s0,16(sp)
  204022:	6105                	addi	sp,sp,32
  204024:	8082                	ret

0000000000204026 <addGoishBuffer>:
void addGoishBuffer(char c){
  204026:	1101                	addi	sp,sp,-32
  204028:	ec06                	sd	ra,24(sp)
  20402a:	e822                	sd	s0,16(sp)
  20402c:	1000                	addi	s0,sp,32
  20402e:	87aa                	mv	a5,a0
  204030:	fef407a3          	sb	a5,-17(s0)
    if (isChar(c)) {
  204034:	fef44783          	lbu	a5,-17(s0)
  204038:	853e                	mv	a0,a5
  20403a:	ed1ff0ef          	jal	ra,203f0a <isChar>
  20403e:	87aa                	mv	a5,a0
  204040:	cfb9                	beqz	a5,20409e <addGoishBuffer+0x78>
        inputbuffer[ibuffer] = c;
  204042:	00003797          	auipc	a5,0x3
  204046:	d7678793          	addi	a5,a5,-650 # 206db8 <ibuffer>
  20404a:	0007c783          	lbu	a5,0(a5)
  20404e:	2781                	sext.w	a5,a5
  204050:	00003717          	auipc	a4,0x3
  204054:	c6870713          	addi	a4,a4,-920 # 206cb8 <inputbuffer>
  204058:	97ba                	add	a5,a5,a4
  20405a:	fef44703          	lbu	a4,-17(s0)
  20405e:	00e78023          	sb	a4,0(a5)
        ibuffer ++;
  204062:	00003797          	auipc	a5,0x3
  204066:	d5678793          	addi	a5,a5,-682 # 206db8 <ibuffer>
  20406a:	0007c783          	lbu	a5,0(a5)
  20406e:	2785                	addiw	a5,a5,1
  204070:	0ff7f713          	andi	a4,a5,255
  204074:	00003797          	auipc	a5,0x3
  204078:	d4478793          	addi	a5,a5,-700 # 206db8 <ibuffer>
  20407c:	00e78023          	sb	a4,0(a5)
        inputbuffer[ibuffer] = 0;
  204080:	00003797          	auipc	a5,0x3
  204084:	d3878793          	addi	a5,a5,-712 # 206db8 <ibuffer>
  204088:	0007c783          	lbu	a5,0(a5)
  20408c:	2781                	sext.w	a5,a5
  20408e:	00003717          	auipc	a4,0x3
  204092:	c2a70713          	addi	a4,a4,-982 # 206cb8 <inputbuffer>
  204096:	97ba                	add	a5,a5,a4
  204098:	00078023          	sb	zero,0(a5)
  20409c:	a41d                	j	2042c2 <addGoishBuffer+0x29c>
    } else {
        switch (c){
  20409e:	fef44783          	lbu	a5,-17(s0)
  2040a2:	2781                	sext.w	a5,a5
  2040a4:	86be                	mv	a3,a5
  2040a6:	4725                	li	a4,9
  2040a8:	20e68a63          	beq	a3,a4,2042bc <addGoishBuffer+0x296>
  2040ac:	86be                	mv	a3,a5
  2040ae:	4735                	li	a4,13
  2040b0:	04e68c63          	beq	a3,a4,204108 <addGoishBuffer+0xe2>
  2040b4:	873e                	mv	a4,a5
  2040b6:	47a1                	li	a5,8
  2040b8:	08f71363          	bne	a4,a5,20413e <addGoishBuffer+0x118>
            case GOISH_BACKSPACE:
                if (ibuffer > 0){
  2040bc:	00003797          	auipc	a5,0x3
  2040c0:	cfc78793          	addi	a5,a5,-772 # 206db8 <ibuffer>
  2040c4:	0007c783          	lbu	a5,0(a5)
  2040c8:	1e078c63          	beqz	a5,2042c0 <addGoishBuffer+0x29a>
                    ibuffer --;
  2040cc:	00003797          	auipc	a5,0x3
  2040d0:	cec78793          	addi	a5,a5,-788 # 206db8 <ibuffer>
  2040d4:	0007c783          	lbu	a5,0(a5)
  2040d8:	37fd                	addiw	a5,a5,-1
  2040da:	0ff7f713          	andi	a4,a5,255
  2040de:	00003797          	auipc	a5,0x3
  2040e2:	cda78793          	addi	a5,a5,-806 # 206db8 <ibuffer>
  2040e6:	00e78023          	sb	a4,0(a5)
                    inputbuffer[ibuffer] = 0;
  2040ea:	00003797          	auipc	a5,0x3
  2040ee:	cce78793          	addi	a5,a5,-818 # 206db8 <ibuffer>
  2040f2:	0007c783          	lbu	a5,0(a5)
  2040f6:	2781                	sext.w	a5,a5
  2040f8:	00003717          	auipc	a4,0x3
  2040fc:	bc070713          	addi	a4,a4,-1088 # 206cb8 <inputbuffer>
  204100:	97ba                	add	a5,a5,a4
  204102:	00078023          	sb	zero,0(a5)
                }
                break;
  204106:	aa6d                	j	2042c0 <addGoishBuffer+0x29a>
            case GOISH_TAB:
                //do something                
                break;
            case GOISH_ENTER:
                goishfunction(inputbuffer);
  204108:	00003517          	auipc	a0,0x3
  20410c:	bb050513          	addi	a0,a0,-1104 # 206cb8 <inputbuffer>
  204110:	ed1ff0ef          	jal	ra,203fe0 <goishfunction>
                //do something
                ibuffer = 0;
  204114:	00003797          	auipc	a5,0x3
  204118:	ca478793          	addi	a5,a5,-860 # 206db8 <ibuffer>
  20411c:	00078023          	sb	zero,0(a5)
                inputbuffer[ibuffer] = 0;
  204120:	00003797          	auipc	a5,0x3
  204124:	c9878793          	addi	a5,a5,-872 # 206db8 <ibuffer>
  204128:	0007c783          	lbu	a5,0(a5)
  20412c:	2781                	sext.w	a5,a5
  20412e:	00003717          	auipc	a4,0x3
  204132:	b8a70713          	addi	a4,a4,-1142 # 206cb8 <inputbuffer>
  204136:	97ba                	add	a5,a5,a4
  204138:	00078023          	sb	zero,0(a5)
                break;
  20413c:	a259                	j	2042c2 <addGoishBuffer+0x29c>
            default:
                inputbuffer[ibuffer] = '^';
  20413e:	00003797          	auipc	a5,0x3
  204142:	c7a78793          	addi	a5,a5,-902 # 206db8 <ibuffer>
  204146:	0007c783          	lbu	a5,0(a5)
  20414a:	2781                	sext.w	a5,a5
  20414c:	00003717          	auipc	a4,0x3
  204150:	b6c70713          	addi	a4,a4,-1172 # 206cb8 <inputbuffer>
  204154:	97ba                	add	a5,a5,a4
  204156:	05e00713          	li	a4,94
  20415a:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  20415e:	00003797          	auipc	a5,0x3
  204162:	c5a78793          	addi	a5,a5,-934 # 206db8 <ibuffer>
  204166:	0007c783          	lbu	a5,0(a5)
  20416a:	2785                	addiw	a5,a5,1
  20416c:	0ff7f713          	andi	a4,a5,255
  204170:	00003797          	auipc	a5,0x3
  204174:	c4878793          	addi	a5,a5,-952 # 206db8 <ibuffer>
  204178:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = (c / 100) + '0';
  20417c:	fef44703          	lbu	a4,-17(s0)
  204180:	06400793          	li	a5,100
  204184:	02f757bb          	divuw	a5,a4,a5
  204188:	0ff7f713          	andi	a4,a5,255
  20418c:	00003797          	auipc	a5,0x3
  204190:	c2c78793          	addi	a5,a5,-980 # 206db8 <ibuffer>
  204194:	0007c783          	lbu	a5,0(a5)
  204198:	2781                	sext.w	a5,a5
  20419a:	0307071b          	addiw	a4,a4,48
  20419e:	0ff77713          	andi	a4,a4,255
  2041a2:	00003697          	auipc	a3,0x3
  2041a6:	b1668693          	addi	a3,a3,-1258 # 206cb8 <inputbuffer>
  2041aa:	97b6                	add	a5,a5,a3
  2041ac:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  2041b0:	00003797          	auipc	a5,0x3
  2041b4:	c0878793          	addi	a5,a5,-1016 # 206db8 <ibuffer>
  2041b8:	0007c783          	lbu	a5,0(a5)
  2041bc:	2785                	addiw	a5,a5,1
  2041be:	0ff7f713          	andi	a4,a5,255
  2041c2:	00003797          	auipc	a5,0x3
  2041c6:	bf678793          	addi	a5,a5,-1034 # 206db8 <ibuffer>
  2041ca:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = ((c % 100) / 10) + '0';
  2041ce:	fef44703          	lbu	a4,-17(s0)
  2041d2:	06400793          	li	a5,100
  2041d6:	02f777bb          	remuw	a5,a4,a5
  2041da:	0ff7f793          	andi	a5,a5,255
  2041de:	873e                	mv	a4,a5
  2041e0:	47a9                	li	a5,10
  2041e2:	02f757bb          	divuw	a5,a4,a5
  2041e6:	0ff7f713          	andi	a4,a5,255
  2041ea:	00003797          	auipc	a5,0x3
  2041ee:	bce78793          	addi	a5,a5,-1074 # 206db8 <ibuffer>
  2041f2:	0007c783          	lbu	a5,0(a5)
  2041f6:	2781                	sext.w	a5,a5
  2041f8:	0307071b          	addiw	a4,a4,48
  2041fc:	0ff77713          	andi	a4,a4,255
  204200:	00003697          	auipc	a3,0x3
  204204:	ab868693          	addi	a3,a3,-1352 # 206cb8 <inputbuffer>
  204208:	97b6                	add	a5,a5,a3
  20420a:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  20420e:	00003797          	auipc	a5,0x3
  204212:	baa78793          	addi	a5,a5,-1110 # 206db8 <ibuffer>
  204216:	0007c783          	lbu	a5,0(a5)
  20421a:	2785                	addiw	a5,a5,1
  20421c:	0ff7f713          	andi	a4,a5,255
  204220:	00003797          	auipc	a5,0x3
  204224:	b9878793          	addi	a5,a5,-1128 # 206db8 <ibuffer>
  204228:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = ((c % 10)) + '0';
  20422c:	fef44703          	lbu	a4,-17(s0)
  204230:	47a9                	li	a5,10
  204232:	02f777bb          	remuw	a5,a4,a5
  204236:	0ff7f713          	andi	a4,a5,255
  20423a:	00003797          	auipc	a5,0x3
  20423e:	b7e78793          	addi	a5,a5,-1154 # 206db8 <ibuffer>
  204242:	0007c783          	lbu	a5,0(a5)
  204246:	2781                	sext.w	a5,a5
  204248:	0307071b          	addiw	a4,a4,48
  20424c:	0ff77713          	andi	a4,a4,255
  204250:	00003697          	auipc	a3,0x3
  204254:	a6868693          	addi	a3,a3,-1432 # 206cb8 <inputbuffer>
  204258:	97b6                	add	a5,a5,a3
  20425a:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  20425e:	00003797          	auipc	a5,0x3
  204262:	b5a78793          	addi	a5,a5,-1190 # 206db8 <ibuffer>
  204266:	0007c783          	lbu	a5,0(a5)
  20426a:	2785                	addiw	a5,a5,1
  20426c:	0ff7f713          	andi	a4,a5,255
  204270:	00003797          	auipc	a5,0x3
  204274:	b4878793          	addi	a5,a5,-1208 # 206db8 <ibuffer>
  204278:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = '^';
  20427c:	00003797          	auipc	a5,0x3
  204280:	b3c78793          	addi	a5,a5,-1220 # 206db8 <ibuffer>
  204284:	0007c783          	lbu	a5,0(a5)
  204288:	2781                	sext.w	a5,a5
  20428a:	00003717          	auipc	a4,0x3
  20428e:	a2e70713          	addi	a4,a4,-1490 # 206cb8 <inputbuffer>
  204292:	97ba                	add	a5,a5,a4
  204294:	05e00713          	li	a4,94
  204298:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  20429c:	00003797          	auipc	a5,0x3
  2042a0:	b1c78793          	addi	a5,a5,-1252 # 206db8 <ibuffer>
  2042a4:	0007c783          	lbu	a5,0(a5)
  2042a8:	2785                	addiw	a5,a5,1
  2042aa:	0ff7f713          	andi	a4,a5,255
  2042ae:	00003797          	auipc	a5,0x3
  2042b2:	b0a78793          	addi	a5,a5,-1270 # 206db8 <ibuffer>
  2042b6:	00e78023          	sb	a4,0(a5)
  2042ba:	a021                	j	2042c2 <addGoishBuffer+0x29c>
                break;
  2042bc:	0001                	nop
  2042be:	a011                	j	2042c2 <addGoishBuffer+0x29c>
                break;
  2042c0:	0001                	nop
        }
        
    }
    printf("\033[33m\rgoish>>$\033[0m%s\r", inputbuffer);
  2042c2:	00003597          	auipc	a1,0x3
  2042c6:	9f658593          	addi	a1,a1,-1546 # 206cb8 <inputbuffer>
  2042ca:	00001517          	auipc	a0,0x1
  2042ce:	64650513          	addi	a0,a0,1606 # 205910 <BSS_END+0x8a8>
  2042d2:	c8efe0ef          	jal	ra,202760 <printf>

}
  2042d6:	0001                	nop
  2042d8:	60e2                	ld	ra,24(sp)
  2042da:	6442                	ld	s0,16(sp)
  2042dc:	6105                	addi	sp,sp,32
  2042de:	8082                	ret

00000000002042e0 <w_mscratch>:
static void w_mscratch(reg_t x){
  2042e0:	1101                	addi	sp,sp,-32
  2042e2:	ec22                	sd	s0,24(sp)
  2042e4:	1000                	addi	s0,sp,32
  2042e6:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  2042ea:	fe843783          	ld	a5,-24(s0)
  2042ee:	34079073          	csrw	mscratch,a5
}
  2042f2:	0001                	nop
  2042f4:	6462                	ld	s0,24(sp)
  2042f6:	6105                	addi	sp,sp,32
  2042f8:	8082                	ret

00000000002042fa <r_mscratch>:
static reg_t r_mscratch(){
  2042fa:	1101                	addi	sp,sp,-32
  2042fc:	ec22                	sd	s0,24(sp)
  2042fe:	1000                	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  204300:	340027f3          	csrr	a5,mscratch
  204304:	fef43423          	sd	a5,-24(s0)
	return ret;
  204308:	fe843783          	ld	a5,-24(s0)
}
  20430c:	853e                	mv	a0,a5
  20430e:	6462                	ld	s0,24(sp)
  204310:	6105                	addi	sp,sp,32
  204312:	8082                	ret

0000000000204314 <r_mhartid>:
static inline reg_t r_mhartid(){
  204314:	1101                	addi	sp,sp,-32
  204316:	ec22                	sd	s0,24(sp)
  204318:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mhartid" : "=r" (x) );
  20431a:	f14027f3          	csrr	a5,mhartid
  20431e:	fef43423          	sd	a5,-24(s0)
	return x;
  204322:	fe843783          	ld	a5,-24(s0)
}
  204326:	853e                	mv	a0,a5
  204328:	6462                	ld	s0,24(sp)
  20432a:	6105                	addi	sp,sp,32
  20432c:	8082                	ret

000000000020432e <r_mstatus>:
static inline reg_t r_mstatus(){
  20432e:	1101                	addi	sp,sp,-32
  204330:	ec22                	sd	s0,24(sp)
  204332:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
  204334:	300027f3          	csrr	a5,mstatus
  204338:	fef43423          	sd	a5,-24(s0)
	return x;
  20433c:	fe843783          	ld	a5,-24(s0)
}
  204340:	853e                	mv	a0,a5
  204342:	6462                	ld	s0,24(sp)
  204344:	6105                	addi	sp,sp,32
  204346:	8082                	ret

0000000000204348 <w_mstatus>:
static inline void w_mstatus(reg_t x){
  204348:	1101                	addi	sp,sp,-32
  20434a:	ec22                	sd	s0,24(sp)
  20434c:	1000                	addi	s0,sp,32
  20434e:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
  204352:	fe843783          	ld	a5,-24(s0)
  204356:	30079073          	csrw	mstatus,a5
}
  20435a:	0001                	nop
  20435c:	6462                	ld	s0,24(sp)
  20435e:	6105                	addi	sp,sp,32
  204360:	8082                	ret

0000000000204362 <r_mie>:
{
  204362:	1101                	addi	sp,sp,-32
  204364:	ec22                	sd	s0,24(sp)
  204366:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  204368:	304027f3          	csrr	a5,mie
  20436c:	fef43423          	sd	a5,-24(s0)
	return x;
  204370:	fe843783          	ld	a5,-24(s0)
}
  204374:	853e                	mv	a0,a5
  204376:	6462                	ld	s0,24(sp)
  204378:	6105                	addi	sp,sp,32
  20437a:	8082                	ret

000000000020437c <w_mie>:
{
  20437c:	1101                	addi	sp,sp,-32
  20437e:	ec22                	sd	s0,24(sp)
  204380:	1000                	addi	s0,sp,32
  204382:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
  204386:	fe843783          	ld	a5,-24(s0)
  20438a:	30479073          	csrw	mie,a5
}
  20438e:	0001                	nop
  204390:	6462                	ld	s0,24(sp)
  204392:	6105                	addi	sp,sp,32
  204394:	8082                	ret

0000000000204396 <r_time>:
static inline reg_t r_time(){
  204396:	1101                	addi	sp,sp,-32
  204398:	ec22                	sd	s0,24(sp)
  20439a:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, time" : "=r" (ret)); 
  20439c:	c01027f3          	rdtime	a5
  2043a0:	fef43423          	sd	a5,-24(s0)
	return ret;
  2043a4:	fe843783          	ld	a5,-24(s0)
}
  2043a8:	853e                	mv	a0,a5
  2043aa:	6462                	ld	s0,24(sp)
  2043ac:	6105                	addi	sp,sp,32
  2043ae:	8082                	ret

00000000002043b0 <w_msip>:
static inline void w_msip(int hartid, int x){
  2043b0:	1101                	addi	sp,sp,-32
  2043b2:	ec22                	sd	s0,24(sp)
  2043b4:	1000                	addi	s0,sp,32
  2043b6:	87aa                	mv	a5,a0
  2043b8:	872e                	mv	a4,a1
  2043ba:	fef42623          	sw	a5,-20(s0)
  2043be:	87ba                	mv	a5,a4
  2043c0:	fef42423          	sw	a5,-24(s0)
	*(uint32_t*)CLINT_MSIP(hartid) = x;
  2043c4:	fec42783          	lw	a5,-20(s0)
  2043c8:	0027979b          	slliw	a5,a5,0x2
  2043cc:	2781                	sext.w	a5,a5
  2043ce:	873e                	mv	a4,a5
  2043d0:	03ff77b7          	lui	a5,0x3ff7
  2043d4:	07ba                	slli	a5,a5,0xe
  2043d6:	97ba                	add	a5,a5,a4
  2043d8:	873e                	mv	a4,a5
  2043da:	fe842783          	lw	a5,-24(s0)
  2043de:	c31c                	sw	a5,0(a4)
}
  2043e0:	0001                	nop
  2043e2:	6462                	ld	s0,24(sp)
  2043e4:	6105                	addi	sp,sp,32
  2043e6:	8082                	ret

00000000002043e8 <w_mtimecmp>:
static inline void w_mtimecmp(reg_t timecmp){
  2043e8:	7179                	addi	sp,sp,-48
  2043ea:	f406                	sd	ra,40(sp)
  2043ec:	f022                	sd	s0,32(sp)
  2043ee:	1800                	addi	s0,sp,48
  2043f0:	fca43c23          	sd	a0,-40(s0)
	reg_t hartid = r_mhartid();
  2043f4:	f21ff0ef          	jal	ra,204314 <r_mhartid>
  2043f8:	fea43423          	sd	a0,-24(s0)
	*(uint32_t*)CLINT_MTIMECMPH(hartid) = ((timecmp >> 32) & 0xffffffff);
  2043fc:	fd843783          	ld	a5,-40(s0)
  204400:	0207d693          	srli	a3,a5,0x20
  204404:	fe843703          	ld	a4,-24(s0)
  204408:	03ff77b7          	lui	a5,0x3ff7
  20440c:	0785                	addi	a5,a5,1
  20440e:	07ae                	slli	a5,a5,0xb
  204410:	97ba                	add	a5,a5,a4
  204412:	078e                	slli	a5,a5,0x3
  204414:	0791                	addi	a5,a5,4
  204416:	873e                	mv	a4,a5
  204418:	0006879b          	sext.w	a5,a3
  20441c:	c31c                	sw	a5,0(a4)
	*(uint32_t*)CLINT_MTIMECMPL(hartid) = (timecmp & 0xffffffff);
  20441e:	fe843703          	ld	a4,-24(s0)
  204422:	03ff77b7          	lui	a5,0x3ff7
  204426:	0785                	addi	a5,a5,1
  204428:	07ae                	slli	a5,a5,0xb
  20442a:	97ba                	add	a5,a5,a4
  20442c:	078e                	slli	a5,a5,0x3
  20442e:	873e                	mv	a4,a5
  204430:	fd843783          	ld	a5,-40(s0)
  204434:	2781                	sext.w	a5,a5
  204436:	c31c                	sw	a5,0(a4)
}
  204438:	0001                	nop
  20443a:	70a2                	ld	ra,40(sp)
  20443c:	7402                	ld	s0,32(sp)
  20443e:	6145                	addi	sp,sp,48
  204440:	8082                	ret

0000000000204442 <get_time>:
static uint64_t get_time(){
  204442:	1141                	addi	sp,sp,-16
  204444:	e422                	sd	s0,8(sp)
  204446:	0800                	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  204448:	00003797          	auipc	a5,0x3
  20444c:	97878793          	addi	a5,a5,-1672 # 206dc0 <_tick>
  204450:	6398                	ld	a4,0(a5)
  204452:	03c00793          	li	a5,60
  204456:	02f757b3          	divu	a5,a4,a5
}
  20445a:	853e                	mv	a0,a5
  20445c:	6422                	ld	s0,8(sp)
  20445e:	0141                	addi	sp,sp,16
  204460:	8082                	ret

0000000000204462 <get_time_str>:
static void get_time_str(char* time){
  204462:	7139                	addi	sp,sp,-64
  204464:	fc22                	sd	s0,56(sp)
  204466:	0080                	addi	s0,sp,64
  204468:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  20446c:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  204470:	00003797          	auipc	a5,0x3
  204474:	95078793          	addi	a5,a5,-1712 # 206dc0 <_tick>
  204478:	6398                	ld	a4,0(a5)
  20447a:	03c00793          	li	a5,60
  20447e:	02f757b3          	divu	a5,a4,a5
  204482:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  204486:	fe043703          	ld	a4,-32(s0)
  20448a:	6785                	lui	a5,0x1
  20448c:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  204490:	02f757b3          	divu	a5,a4,a5
  204494:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  204498:	fdf44703          	lbu	a4,-33(s0)
  20449c:	06400793          	li	a5,100
  2044a0:	02f777bb          	remuw	a5,a4,a5
  2044a4:	0ff7f793          	andi	a5,a5,255
  2044a8:	873e                	mv	a4,a5
  2044aa:	47a9                	li	a5,10
  2044ac:	02f757bb          	divuw	a5,a4,a5
  2044b0:	0ff7f793          	andi	a5,a5,255
  2044b4:	0307879b          	addiw	a5,a5,48
  2044b8:	0ff7f713          	andi	a4,a5,255
  2044bc:	fc843783          	ld	a5,-56(s0)
  2044c0:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  2044c4:	fdf44703          	lbu	a4,-33(s0)
  2044c8:	47a9                	li	a5,10
  2044ca:	02f777bb          	remuw	a5,a4,a5
  2044ce:	0ff7f713          	andi	a4,a5,255
  2044d2:	fc843783          	ld	a5,-56(s0)
  2044d6:	0785                	addi	a5,a5,1
  2044d8:	0307071b          	addiw	a4,a4,48
  2044dc:	0ff77713          	andi	a4,a4,255
  2044e0:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  2044e4:	fc843783          	ld	a5,-56(s0)
  2044e8:	0789                	addi	a5,a5,2
  2044ea:	03a00713          	li	a4,58
  2044ee:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  2044f2:	fe043703          	ld	a4,-32(s0)
  2044f6:	6785                	lui	a5,0x1
  2044f8:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2044fc:	02f77733          	remu	a4,a4,a5
  204500:	03c00793          	li	a5,60
  204504:	02f757b3          	divu	a5,a4,a5
  204508:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  20450c:	fdf44703          	lbu	a4,-33(s0)
  204510:	47a9                	li	a5,10
  204512:	02f757bb          	divuw	a5,a4,a5
  204516:	0ff7f713          	andi	a4,a5,255
  20451a:	fc843783          	ld	a5,-56(s0)
  20451e:	078d                	addi	a5,a5,3
  204520:	0307071b          	addiw	a4,a4,48
  204524:	0ff77713          	andi	a4,a4,255
  204528:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  20452c:	fdf44703          	lbu	a4,-33(s0)
  204530:	47a9                	li	a5,10
  204532:	02f777bb          	remuw	a5,a4,a5
  204536:	0ff7f713          	andi	a4,a5,255
  20453a:	fc843783          	ld	a5,-56(s0)
  20453e:	0791                	addi	a5,a5,4
  204540:	0307071b          	addiw	a4,a4,48
  204544:	0ff77713          	andi	a4,a4,255
  204548:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  20454c:	fc843783          	ld	a5,-56(s0)
  204550:	0795                	addi	a5,a5,5
  204552:	03a00713          	li	a4,58
  204556:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  20455a:	fe043703          	ld	a4,-32(s0)
  20455e:	03c00793          	li	a5,60
  204562:	02f777b3          	remu	a5,a4,a5
  204566:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  20456a:	fdf44703          	lbu	a4,-33(s0)
  20456e:	47a9                	li	a5,10
  204570:	02f757bb          	divuw	a5,a4,a5
  204574:	0ff7f713          	andi	a4,a5,255
  204578:	fc843783          	ld	a5,-56(s0)
  20457c:	0799                	addi	a5,a5,6
  20457e:	0307071b          	addiw	a4,a4,48
  204582:	0ff77713          	andi	a4,a4,255
  204586:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  20458a:	fdf44703          	lbu	a4,-33(s0)
  20458e:	47a9                	li	a5,10
  204590:	02f777bb          	remuw	a5,a4,a5
  204594:	0ff7f713          	andi	a4,a5,255
  204598:	fc843783          	ld	a5,-56(s0)
  20459c:	079d                	addi	a5,a5,7
  20459e:	0307071b          	addiw	a4,a4,48
  2045a2:	0ff77713          	andi	a4,a4,255
  2045a6:	00e78023          	sb	a4,0(a5)
}
  2045aa:	0001                	nop
  2045ac:	7462                	ld	s0,56(sp)
  2045ae:	6121                	addi	sp,sp,64
  2045b0:	8082                	ret

00000000002045b2 <timer_load>:
#include "timer.h"
extern void switch_to(struct context *next);

/* load timer interval(in ticks) for next timer interrupt.*/
void timer_load(int interval)
{
  2045b2:	7179                	addi	sp,sp,-48
  2045b4:	f406                	sd	ra,40(sp)
  2045b6:	f022                	sd	s0,32(sp)
  2045b8:	1800                	addi	s0,sp,48
  2045ba:	87aa                	mv	a5,a0
  2045bc:	fcf42e23          	sw	a5,-36(s0)
	/* each CPU has a separate source of timer interrupts. */
	int id = r_mhartid();
  2045c0:	d55ff0ef          	jal	ra,204314 <r_mhartid>
  2045c4:	87aa                	mv	a5,a0
  2045c6:	fef42623          	sw	a5,-20(s0)
    reg_t MTIME = r_time();
  2045ca:	dcdff0ef          	jal	ra,204396 <r_time>
  2045ce:	fea43023          	sd	a0,-32(s0)
	w_mtimecmp(MTIME + interval);
  2045d2:	fdc42703          	lw	a4,-36(s0)
  2045d6:	fe043783          	ld	a5,-32(s0)
  2045da:	97ba                	add	a5,a5,a4
  2045dc:	853e                	mv	a0,a5
  2045de:	e0bff0ef          	jal	ra,2043e8 <w_mtimecmp>
	}
  2045e2:	0001                	nop
  2045e4:	70a2                	ld	ra,40(sp)
  2045e6:	7402                	ld	s0,32(sp)
  2045e8:	6145                	addi	sp,sp,48
  2045ea:	8082                	ret

00000000002045ec <timer_init>:

void timer_init()
{
  2045ec:	1141                	addi	sp,sp,-16
  2045ee:	e406                	sd	ra,8(sp)
  2045f0:	e022                	sd	s0,0(sp)
  2045f2:	0800                	addi	s0,sp,16
	/*
	 * On reset, mtime is cleared to zero, but the mtimecmp registers 
	 * are not reset. So we have to init the mtimecmp manually.
	 */
	timer_load(TIMER_INTERVAL);
  2045f4:	67b1                	lui	a5,0xc
  2045f6:	35078513          	addi	a0,a5,848 # c350 <STACK_SIZE+0xbf50>
  2045fa:	fb9ff0ef          	jal	ra,2045b2 <timer_load>

	/* enable machine-mode timer interrupts. */
	w_mie(r_mie() | MIE_MTIE);
  2045fe:	d65ff0ef          	jal	ra,204362 <r_mie>
  204602:	87aa                	mv	a5,a0
  204604:	0807e793          	ori	a5,a5,128
  204608:	853e                	mv	a0,a5
  20460a:	d73ff0ef          	jal	ra,20437c <w_mie>

	/* enable machine-mode global interrupts. */
	w_mstatus(r_mstatus() | MSTATUS_MIE);
  20460e:	d21ff0ef          	jal	ra,20432e <r_mstatus>
  204612:	87aa                	mv	a5,a0
  204614:	0087e793          	ori	a5,a5,8
  204618:	853e                	mv	a0,a5
  20461a:	d2fff0ef          	jal	ra,204348 <w_mstatus>
	printf("timer init!!\n\r");
  20461e:	00001517          	auipc	a0,0x1
  204622:	30a50513          	addi	a0,a0,778 # 205928 <BSS_END+0x8c0>
  204626:	93afe0ef          	jal	ra,202760 <printf>
}
  20462a:	0001                	nop
  20462c:	60a2                	ld	ra,8(sp)
  20462e:	6402                	ld	s0,0(sp)
  204630:	0141                	addi	sp,sp,16
  204632:	8082                	ret

0000000000204634 <timer_handler>:

void timer_handler() 
{
  204634:	1101                	addi	sp,sp,-32
  204636:	ec06                	sd	ra,24(sp)
  204638:	e822                	sd	s0,16(sp)
  20463a:	1000                	addi	s0,sp,32
	_tick++;
  20463c:	00002797          	auipc	a5,0x2
  204640:	78478793          	addi	a5,a5,1924 # 206dc0 <_tick>
  204644:	639c                	ld	a5,0(a5)
  204646:	00178713          	addi	a4,a5,1
  20464a:	00002797          	auipc	a5,0x2
  20464e:	77678793          	addi	a5,a5,1910 # 206dc0 <_tick>
  204652:	e398                	sd	a4,0(a5)
	_slice++;
  204654:	00002797          	auipc	a5,0x2
  204658:	77478793          	addi	a5,a5,1908 # 206dc8 <_slice>
  20465c:	639c                	ld	a5,0(a5)
  20465e:	00178713          	addi	a4,a5,1
  204662:	00002797          	auipc	a5,0x2
  204666:	76678793          	addi	a5,a5,1894 # 206dc8 <_slice>
  20466a:	e398                	sd	a4,0(a5)
    // #ifdef MYPRINT
	// printf("tick: %d\n\r", _tick);
    // #endif

	timer_load(TIMER_INTERVAL);
  20466c:	67b1                	lui	a5,0xc
  20466e:	35078513          	addi	a0,a5,848 # c350 <STACK_SIZE+0xbf50>
  204672:	f41ff0ef          	jal	ra,2045b2 <timer_load>
	char timestr[9];
	get_time_str(timestr);
  204676:	fe040793          	addi	a5,s0,-32
  20467a:	853e                	mv	a0,a5
  20467c:	de7ff0ef          	jal	ra,204462 <get_time_str>
	timestr[8] = 0;
  204680:	fe040423          	sb	zero,-24(s0)
	if (_slice >= TICKS_PER_SLICE){
  204684:	00002797          	auipc	a5,0x2
  204688:	74478793          	addi	a5,a5,1860 # 206dc8 <_slice>
  20468c:	6398                	ld	a4,0(a5)
  20468e:	00002797          	auipc	a5,0x2
  204692:	99a78793          	addi	a5,a5,-1638 # 206028 <TICKS_PER_SLICE>
  204696:	639c                	ld	a5,0(a5)
  204698:	00f76463          	bltu	a4,a5,2046a0 <timer_handler+0x6c>
		schedule();
  20469c:	c08ff0ef          	jal	ra,203aa4 <schedule>
	}
}
  2046a0:	0001                	nop
  2046a2:	60e2                	ld	ra,24(sp)
  2046a4:	6442                	ld	s0,16(sp)
  2046a6:	6105                	addi	sp,sp,32
  2046a8:	8082                	ret

00000000002046aa <software_handler>:


void software_handler(){
  2046aa:	7179                	addi	sp,sp,-48
  2046ac:	f406                	sd	ra,40(sp)
  2046ae:	f022                	sd	s0,32(sp)
  2046b0:	1800                	addi	s0,sp,48
	uint8_t flag = software_interrupt_flag;
  2046b2:	00002797          	auipc	a5,0x2
  2046b6:	71e78793          	addi	a5,a5,1822 # 206dd0 <software_interrupt_flag>
  2046ba:	0007c783          	lbu	a5,0(a5)
  2046be:	fef407a3          	sb	a5,-17(s0)
	uint64_t arg = software_interrupt_arg;
  2046c2:	00002797          	auipc	a5,0x2
  2046c6:	71678793          	addi	a5,a5,1814 # 206dd8 <software_interrupt_arg>
  2046ca:	639c                	ld	a5,0(a5)
  2046cc:	fef43023          	sd	a5,-32(s0)
	reset_software_interrupt();
  2046d0:	110000ef          	jal	ra,2047e0 <reset_software_interrupt>
	struct context* pmycontext = r_mscratch();
  2046d4:	c27ff0ef          	jal	ra,2042fa <r_mscratch>
  2046d8:	87aa                	mv	a5,a0
  2046da:	fcf43c23          	sd	a5,-40(s0)
	switch(flag){
  2046de:	fef44783          	lbu	a5,-17(s0)
  2046e2:	2781                	sext.w	a5,a5
  2046e4:	86be                	mv	a3,a5
  2046e6:	4711                	li	a4,4
  2046e8:	08d76863          	bltu	a4,a3,204778 <software_handler+0xce>
  2046ec:	00279713          	slli	a4,a5,0x2
  2046f0:	00001797          	auipc	a5,0x1
  2046f4:	2c878793          	addi	a5,a5,712 # 2059b8 <BSS_END+0x950>
  2046f8:	97ba                	add	a5,a5,a4
  2046fa:	439c                	lw	a5,0(a5)
  2046fc:	0007871b          	sext.w	a4,a5
  204700:	00001797          	auipc	a5,0x1
  204704:	2b878793          	addi	a5,a5,696 # 2059b8 <BSS_END+0x950>
  204708:	97ba                	add	a5,a5,a4
  20470a:	8782                	jr	a5
		case SOFTWARE_NOTHING:
			printf("nothing happend\n\r");
  20470c:	00001517          	auipc	a0,0x1
  204710:	22c50513          	addi	a0,a0,556 # 205938 <BSS_END+0x8d0>
  204714:	84cfe0ef          	jal	ra,202760 <printf>
			break;
  204718:	a0bd                	j	204786 <software_handler+0xdc>
		case SOFTWARE_KERNEL_SWITCH:
			#ifdef MYPRINT
			printf("kernel switch to task controller\n\r");
  20471a:	00001517          	auipc	a0,0x1
  20471e:	23650513          	addi	a0,a0,566 # 205950 <BSS_END+0x8e8>
  204722:	83efe0ef          	jal	ra,202760 <printf>
			printf("arg%p\n\r", arg);
  204726:	fe043583          	ld	a1,-32(s0)
  20472a:	00001517          	auipc	a0,0x1
  20472e:	24e50513          	addi	a0,a0,590 # 205978 <BSS_END+0x910>
  204732:	82efe0ef          	jal	ra,202760 <printf>
			#endif
			schedule();
  204736:	b6eff0ef          	jal	ra,203aa4 <schedule>
			break;
  20473a:	a0b1                	j	204786 <software_handler+0xdc>
		case SOFTWARE_TASK_CONTROLLER_FLAG:
			//printf("task controller calling\n\r");
			_slice = 0;
  20473c:	00002797          	auipc	a5,0x2
  204740:	68c78793          	addi	a5,a5,1676 # 206dc8 <_slice>
  204744:	0007b023          	sd	zero,0(a5)
			switch_to((uint64_t) arg);
  204748:	fe043783          	ld	a5,-32(s0)
  20474c:	853e                	mv	a0,a5
  20474e:	a0ffd0ef          	jal	ra,20215c <switch_to>
			break;
  204752:	a815                	j	204786 <software_handler+0xdc>
		case SOFTWARE_USER_SWITCH_FLAG:
			printf("user want to switch\n\r");
  204754:	00001517          	auipc	a0,0x1
  204758:	22c50513          	addi	a0,a0,556 # 205980 <BSS_END+0x918>
  20475c:	804fe0ef          	jal	ra,202760 <printf>
			schedule();
  204760:	b44ff0ef          	jal	ra,203aa4 <schedule>
			break;
  204764:	a00d                	j	204786 <software_handler+0xdc>
		case SOFTWARE_USER_KILLMYSELF:
			pmycontext->flags = 0;
  204766:	fd843783          	ld	a5,-40(s0)
  20476a:	100780a3          	sb	zero,257(a5)
			newpriority();
  20476e:	a6aff0ef          	jal	ra,2039d8 <newpriority>
			schedule();
  204772:	b32ff0ef          	jal	ra,203aa4 <schedule>
			break;
  204776:	a801                	j	204786 <software_handler+0xdc>
		default:
			printf("UNKNOWN SOFTWARE INTERRUPT!!\n\r");
  204778:	00001517          	auipc	a0,0x1
  20477c:	22050513          	addi	a0,a0,544 # 205998 <BSS_END+0x930>
  204780:	fe1fd0ef          	jal	ra,202760 <printf>
			break;
  204784:	0001                	nop
	}
}
  204786:	0001                	nop
  204788:	70a2                	ld	ra,40(sp)
  20478a:	7402                	ld	s0,32(sp)
  20478c:	6145                	addi	sp,sp,48
  20478e:	8082                	ret

0000000000204790 <call_software_interrupt>:


void call_software_interrupt(uint8_t flag, uint64_t arg){
  204790:	7179                	addi	sp,sp,-48
  204792:	f406                	sd	ra,40(sp)
  204794:	f022                	sd	s0,32(sp)
  204796:	1800                	addi	s0,sp,48
  204798:	87aa                	mv	a5,a0
  20479a:	fcb43823          	sd	a1,-48(s0)
  20479e:	fcf40fa3          	sb	a5,-33(s0)
	software_interrupt_flag = flag;
  2047a2:	00002797          	auipc	a5,0x2
  2047a6:	62e78793          	addi	a5,a5,1582 # 206dd0 <software_interrupt_flag>
  2047aa:	fdf44703          	lbu	a4,-33(s0)
  2047ae:	00e78023          	sb	a4,0(a5)
	software_interrupt_arg = arg;
  2047b2:	00002797          	auipc	a5,0x2
  2047b6:	62678793          	addi	a5,a5,1574 # 206dd8 <software_interrupt_arg>
  2047ba:	fd043703          	ld	a4,-48(s0)
  2047be:	e398                	sd	a4,0(a5)
	reg_t hartid = r_mhartid();
  2047c0:	b55ff0ef          	jal	ra,204314 <r_mhartid>
  2047c4:	fea43423          	sd	a0,-24(s0)
	w_msip(hartid, 1);
  2047c8:	fe843783          	ld	a5,-24(s0)
  2047cc:	2781                	sext.w	a5,a5
  2047ce:	4585                	li	a1,1
  2047d0:	853e                	mv	a0,a5
  2047d2:	bdfff0ef          	jal	ra,2043b0 <w_msip>
}
  2047d6:	0001                	nop
  2047d8:	70a2                	ld	ra,40(sp)
  2047da:	7402                	ld	s0,32(sp)
  2047dc:	6145                	addi	sp,sp,48
  2047de:	8082                	ret

00000000002047e0 <reset_software_interrupt>:
void reset_software_interrupt(){
  2047e0:	1101                	addi	sp,sp,-32
  2047e2:	ec06                	sd	ra,24(sp)
  2047e4:	e822                	sd	s0,16(sp)
  2047e6:	1000                	addi	s0,sp,32
	software_interrupt_flag = 0;
  2047e8:	00002797          	auipc	a5,0x2
  2047ec:	5e878793          	addi	a5,a5,1512 # 206dd0 <software_interrupt_flag>
  2047f0:	00078023          	sb	zero,0(a5)
	software_interrupt_arg = 0;
  2047f4:	00002797          	auipc	a5,0x2
  2047f8:	5e478793          	addi	a5,a5,1508 # 206dd8 <software_interrupt_arg>
  2047fc:	0007b023          	sd	zero,0(a5)
	reg_t hartid = r_mhartid();
  204800:	b15ff0ef          	jal	ra,204314 <r_mhartid>
  204804:	fea43423          	sd	a0,-24(s0)
	w_msip(hartid, 0);
  204808:	fe843783          	ld	a5,-24(s0)
  20480c:	2781                	sext.w	a5,a5
  20480e:	4581                	li	a1,0
  204810:	853e                	mv	a0,a5
  204812:	b9fff0ef          	jal	ra,2043b0 <w_msip>
}
  204816:	0001                	nop
  204818:	60e2                	ld	ra,24(sp)
  20481a:	6442                	ld	s0,16(sp)
  20481c:	6105                	addi	sp,sp,32
  20481e:	8082                	ret

0000000000204820 <_clear>:
struct Page {
	uint8_t flags;
};

static inline void _clear(struct Page *page)
{
  204820:	1101                	addi	sp,sp,-32
  204822:	ec22                	sd	s0,24(sp)
  204824:	1000                	addi	s0,sp,32
  204826:	fea43423          	sd	a0,-24(s0)
	page->flags = 0;
  20482a:	fe843783          	ld	a5,-24(s0)
  20482e:	00078023          	sb	zero,0(a5)
}
  204832:	0001                	nop
  204834:	6462                	ld	s0,24(sp)
  204836:	6105                	addi	sp,sp,32
  204838:	8082                	ret

000000000020483a <_is_free>:

static inline int _is_free(struct Page *page)
{
  20483a:	1101                	addi	sp,sp,-32
  20483c:	ec22                	sd	s0,24(sp)
  20483e:	1000                	addi	s0,sp,32
  204840:	fea43423          	sd	a0,-24(s0)
	if (page->flags & PAGE_TAKEN) {
  204844:	fe843783          	ld	a5,-24(s0)
  204848:	0007c783          	lbu	a5,0(a5)
  20484c:	2781                	sext.w	a5,a5
  20484e:	8b85                	andi	a5,a5,1
  204850:	2781                	sext.w	a5,a5
  204852:	c399                	beqz	a5,204858 <_is_free+0x1e>
		return 0;
  204854:	4781                	li	a5,0
  204856:	a011                	j	20485a <_is_free+0x20>
	} else {
		return 1;
  204858:	4785                	li	a5,1
	}
}
  20485a:	853e                	mv	a0,a5
  20485c:	6462                	ld	s0,24(sp)
  20485e:	6105                	addi	sp,sp,32
  204860:	8082                	ret

0000000000204862 <_set_flag>:

static inline void _set_flag(struct Page *page, uint8_t flags)
{
  204862:	1101                	addi	sp,sp,-32
  204864:	ec22                	sd	s0,24(sp)
  204866:	1000                	addi	s0,sp,32
  204868:	fea43423          	sd	a0,-24(s0)
  20486c:	87ae                	mv	a5,a1
  20486e:	fef403a3          	sb	a5,-25(s0)
	page->flags |= flags;
  204872:	fe843783          	ld	a5,-24(s0)
  204876:	0007c703          	lbu	a4,0(a5)
  20487a:	fe744783          	lbu	a5,-25(s0)
  20487e:	8fd9                	or	a5,a5,a4
  204880:	0ff7f713          	andi	a4,a5,255
  204884:	fe843783          	ld	a5,-24(s0)
  204888:	00e78023          	sb	a4,0(a5)
}
  20488c:	0001                	nop
  20488e:	6462                	ld	s0,24(sp)
  204890:	6105                	addi	sp,sp,32
  204892:	8082                	ret

0000000000204894 <_is_last>:

static inline int _is_last(struct Page *page)
{
  204894:	1101                	addi	sp,sp,-32
  204896:	ec22                	sd	s0,24(sp)
  204898:	1000                	addi	s0,sp,32
  20489a:	fea43423          	sd	a0,-24(s0)
	if (page->flags & PAGE_LAST) {
  20489e:	fe843783          	ld	a5,-24(s0)
  2048a2:	0007c783          	lbu	a5,0(a5)
  2048a6:	2781                	sext.w	a5,a5
  2048a8:	8b89                	andi	a5,a5,2
  2048aa:	2781                	sext.w	a5,a5
  2048ac:	c399                	beqz	a5,2048b2 <_is_last+0x1e>
		return 1;
  2048ae:	4785                	li	a5,1
  2048b0:	a011                	j	2048b4 <_is_last+0x20>
	} else {
		return 0;
  2048b2:	4781                	li	a5,0
	}
}
  2048b4:	853e                	mv	a0,a5
  2048b6:	6462                	ld	s0,24(sp)
  2048b8:	6105                	addi	sp,sp,32
  2048ba:	8082                	ret

00000000002048bc <_align_page>:
/*
 * align the address to the border of page(4K)
 * the up boundage of a 4k size page
 */
static inline ptr_t _align_page(ptr_t address)
{
  2048bc:	7179                	addi	sp,sp,-48
  2048be:	f422                	sd	s0,40(sp)
  2048c0:	1800                	addi	s0,sp,48
  2048c2:	fca43c23          	sd	a0,-40(s0)
	ptr_t order = (1 << PAGE_ORDER) - 1;
  2048c6:	6785                	lui	a5,0x1
  2048c8:	17fd                	addi	a5,a5,-1
  2048ca:	fef43423          	sd	a5,-24(s0)
	return (address + order) & (~order);
  2048ce:	fd843703          	ld	a4,-40(s0)
  2048d2:	fe843783          	ld	a5,-24(s0)
  2048d6:	973e                	add	a4,a4,a5
  2048d8:	fe843783          	ld	a5,-24(s0)
  2048dc:	fff7c793          	not	a5,a5
  2048e0:	8ff9                	and	a5,a5,a4
}
  2048e2:	853e                	mv	a0,a5
  2048e4:	7422                	ld	s0,40(sp)
  2048e6:	6145                	addi	sp,sp,48
  2048e8:	8082                	ret

00000000002048ea <page_init>:
 *  HEAP_START(BSS_END)
 *
 *  Note: _alloc_end may equal to _memory_end.
 */
void page_init()
{
  2048ea:	7179                	addi	sp,sp,-48
  2048ec:	f406                	sd	ra,40(sp)
  2048ee:	f022                	sd	s0,32(sp)
  2048f0:	1800                	addi	s0,sp,48
	ptr_t _heap_start_aligned = _align_page(HEAP_START);
  2048f2:	00000797          	auipc	a5,0x0
  2048f6:	72e78793          	addi	a5,a5,1838 # 205020 <HEAP_START>
  2048fa:	639c                	ld	a5,0(a5)
  2048fc:	853e                	mv	a0,a5
  2048fe:	fbfff0ef          	jal	ra,2048bc <_align_page>
  204902:	fca43c23          	sd	a0,-40(s0)
	 * For simplicity, the space we reserve here is just an approximation,
	 * assuming that it can accommodate the maximum LENGTH_RAM.
	 * We assume LENGTH_RAM should not be too small, ideally no less
	 * than 16M (i.e. PAGE_SIZE * PAGE_SIZE).
	 */
	uint32_t num_reserved_pages = LENGTH_RAM / (PAGE_SIZE * PAGE_SIZE);
  204906:	47bd                	li	a5,15
  204908:	fcf42a23          	sw	a5,-44(s0)

	_num_pages = (HEAP_SIZE - (_heap_start_aligned - HEAP_START))/ PAGE_SIZE - num_reserved_pages;
  20490c:	00000797          	auipc	a5,0x0
  204910:	71478793          	addi	a5,a5,1812 # 205020 <HEAP_START>
  204914:	6398                	ld	a4,0(a5)
  204916:	fd843783          	ld	a5,-40(s0)
  20491a:	8f1d                	sub	a4,a4,a5
  20491c:	00000797          	auipc	a5,0x0
  204920:	70c78793          	addi	a5,a5,1804 # 205028 <HEAP_SIZE>
  204924:	639c                	ld	a5,0(a5)
  204926:	97ba                	add	a5,a5,a4
  204928:	83b1                	srli	a5,a5,0xc
  20492a:	0007871b          	sext.w	a4,a5
  20492e:	fd442783          	lw	a5,-44(s0)
  204932:	40f707bb          	subw	a5,a4,a5
  204936:	0007871b          	sext.w	a4,a5
  20493a:	00002797          	auipc	a5,0x2
  20493e:	4b678793          	addi	a5,a5,1206 # 206df0 <_num_pages>
  204942:	c398                	sw	a4,0(a5)
	printf("HEAP_START = %p(aligned to %p), HEAP_SIZE = 0x%lx,\n\r"
  204944:	00000797          	auipc	a5,0x0
  204948:	6dc78793          	addi	a5,a5,1756 # 205020 <HEAP_START>
  20494c:	638c                	ld	a1,0(a5)
  20494e:	00000797          	auipc	a5,0x0
  204952:	6da78793          	addi	a5,a5,1754 # 205028 <HEAP_SIZE>
  204956:	6394                	ld	a3,0(a5)
  204958:	00002797          	auipc	a5,0x2
  20495c:	49878793          	addi	a5,a5,1176 # 206df0 <_num_pages>
  204960:	439c                	lw	a5,0(a5)
  204962:	fd442703          	lw	a4,-44(s0)
  204966:	fd843603          	ld	a2,-40(s0)
  20496a:	00001517          	auipc	a0,0x1
  20496e:	06650513          	addi	a0,a0,102 # 2059d0 <BSS_END+0x968>
  204972:	deffd0ef          	jal	ra,202760 <printf>
	/*
	 * We use HEAP_START, not _heap_start_aligned as begin address for
	 * allocating struct Page, because we have no requirement of alignment
	 * for position of struct Page.
	 */
	struct Page *page = (struct Page *)HEAP_START;
  204976:	00000797          	auipc	a5,0x0
  20497a:	6aa78793          	addi	a5,a5,1706 # 205020 <HEAP_START>
  20497e:	639c                	ld	a5,0(a5)
  204980:	fef43423          	sd	a5,-24(s0)
	for (int i = 0; i < _num_pages; i++) {
  204984:	fe042223          	sw	zero,-28(s0)
  204988:	a839                	j	2049a6 <page_init+0xbc>
		_clear(page);
  20498a:	fe843503          	ld	a0,-24(s0)
  20498e:	e93ff0ef          	jal	ra,204820 <_clear>
		page++;	
  204992:	fe843783          	ld	a5,-24(s0)
  204996:	0785                	addi	a5,a5,1
  204998:	fef43423          	sd	a5,-24(s0)
	for (int i = 0; i < _num_pages; i++) {
  20499c:	fe442783          	lw	a5,-28(s0)
  2049a0:	2785                	addiw	a5,a5,1
  2049a2:	fef42223          	sw	a5,-28(s0)
  2049a6:	fe442703          	lw	a4,-28(s0)
  2049aa:	00002797          	auipc	a5,0x2
  2049ae:	44678793          	addi	a5,a5,1094 # 206df0 <_num_pages>
  2049b2:	439c                	lw	a5,0(a5)
  2049b4:	fcf76be3          	bltu	a4,a5,20498a <page_init+0xa0>
	}

	_alloc_start = _heap_start_aligned + num_reserved_pages * PAGE_SIZE;
  2049b8:	fd442783          	lw	a5,-44(s0)
  2049bc:	00c7979b          	slliw	a5,a5,0xc
  2049c0:	2781                	sext.w	a5,a5
  2049c2:	02079713          	slli	a4,a5,0x20
  2049c6:	9301                	srli	a4,a4,0x20
  2049c8:	fd843783          	ld	a5,-40(s0)
  2049cc:	973e                	add	a4,a4,a5
  2049ce:	00002797          	auipc	a5,0x2
  2049d2:	41278793          	addi	a5,a5,1042 # 206de0 <_alloc_start>
  2049d6:	e398                	sd	a4,0(a5)
	_alloc_end = _alloc_start + (PAGE_SIZE * _num_pages);
  2049d8:	00002797          	auipc	a5,0x2
  2049dc:	41878793          	addi	a5,a5,1048 # 206df0 <_num_pages>
  2049e0:	439c                	lw	a5,0(a5)
  2049e2:	00c7979b          	slliw	a5,a5,0xc
  2049e6:	2781                	sext.w	a5,a5
  2049e8:	02079713          	slli	a4,a5,0x20
  2049ec:	9301                	srli	a4,a4,0x20
  2049ee:	00002797          	auipc	a5,0x2
  2049f2:	3f278793          	addi	a5,a5,1010 # 206de0 <_alloc_start>
  2049f6:	639c                	ld	a5,0(a5)
  2049f8:	973e                	add	a4,a4,a5
  2049fa:	00002797          	auipc	a5,0x2
  2049fe:	3ee78793          	addi	a5,a5,1006 # 206de8 <_alloc_end>
  204a02:	e398                	sd	a4,0(a5)
	#ifdef MYPRINT
	printf("TEXT:   %p -> %p\n\r", TEXT_START, TEXT_END);
  204a04:	00000797          	auipc	a5,0x0
  204a08:	62c78793          	addi	a5,a5,1580 # 205030 <TEXT_START>
  204a0c:	6398                	ld	a4,0(a5)
  204a0e:	00000797          	auipc	a5,0x0
  204a12:	62a78793          	addi	a5,a5,1578 # 205038 <TEXT_END>
  204a16:	639c                	ld	a5,0(a5)
  204a18:	863e                	mv	a2,a5
  204a1a:	85ba                	mv	a1,a4
  204a1c:	00001517          	auipc	a0,0x1
  204a20:	03450513          	addi	a0,a0,52 # 205a50 <BSS_END+0x9e8>
  204a24:	d3dfd0ef          	jal	ra,202760 <printf>
	printf("RODATA: %p -> %p\n\r", RODATA_START, RODATA_END);
  204a28:	00000797          	auipc	a5,0x0
  204a2c:	62878793          	addi	a5,a5,1576 # 205050 <RODATA_START>
  204a30:	6398                	ld	a4,0(a5)
  204a32:	00000797          	auipc	a5,0x0
  204a36:	62678793          	addi	a5,a5,1574 # 205058 <RODATA_END>
  204a3a:	639c                	ld	a5,0(a5)
  204a3c:	863e                	mv	a2,a5
  204a3e:	85ba                	mv	a1,a4
  204a40:	00001517          	auipc	a0,0x1
  204a44:	02850513          	addi	a0,a0,40 # 205a68 <BSS_END+0xa00>
  204a48:	d19fd0ef          	jal	ra,202760 <printf>
	printf("DATA:   %p -> %p\n\r", DATA_START, DATA_END);
  204a4c:	00000797          	auipc	a5,0x0
  204a50:	5f478793          	addi	a5,a5,1524 # 205040 <DATA_START>
  204a54:	6398                	ld	a4,0(a5)
  204a56:	00000797          	auipc	a5,0x0
  204a5a:	5f278793          	addi	a5,a5,1522 # 205048 <DATA_END>
  204a5e:	639c                	ld	a5,0(a5)
  204a60:	863e                	mv	a2,a5
  204a62:	85ba                	mv	a1,a4
  204a64:	00001517          	auipc	a0,0x1
  204a68:	01c50513          	addi	a0,a0,28 # 205a80 <BSS_END+0xa18>
  204a6c:	cf5fd0ef          	jal	ra,202760 <printf>
	printf("BSS:    %p -> %p\n\r", BSS_START, BSS_END);
  204a70:	00000797          	auipc	a5,0x0
  204a74:	5f078793          	addi	a5,a5,1520 # 205060 <BSS_START>
  204a78:	6398                	ld	a4,0(a5)
  204a7a:	00000797          	auipc	a5,0x0
  204a7e:	5ee78793          	addi	a5,a5,1518 # 205068 <BSS_END>
  204a82:	639c                	ld	a5,0(a5)
  204a84:	863e                	mv	a2,a5
  204a86:	85ba                	mv	a1,a4
  204a88:	00001517          	auipc	a0,0x1
  204a8c:	01050513          	addi	a0,a0,16 # 205a98 <BSS_END+0xa30>
  204a90:	cd1fd0ef          	jal	ra,202760 <printf>
	printf("HEAP:   %p -> %p\n\r", _alloc_start, _alloc_end);
  204a94:	00002797          	auipc	a5,0x2
  204a98:	34c78793          	addi	a5,a5,844 # 206de0 <_alloc_start>
  204a9c:	6398                	ld	a4,0(a5)
  204a9e:	00002797          	auipc	a5,0x2
  204aa2:	34a78793          	addi	a5,a5,842 # 206de8 <_alloc_end>
  204aa6:	639c                	ld	a5,0(a5)
  204aa8:	863e                	mv	a2,a5
  204aaa:	85ba                	mv	a1,a4
  204aac:	00001517          	auipc	a0,0x1
  204ab0:	00450513          	addi	a0,a0,4 # 205ab0 <BSS_END+0xa48>
  204ab4:	cadfd0ef          	jal	ra,202760 <printf>
	printf("size of struct page:%dbyte\n\r", sizeof(struct Page));
  204ab8:	4585                	li	a1,1
  204aba:	00001517          	auipc	a0,0x1
  204abe:	00e50513          	addi	a0,a0,14 # 205ac8 <BSS_END+0xa60>
  204ac2:	c9ffd0ef          	jal	ra,202760 <printf>
	printf("first page position:%p\n\r", HEAP_START);
  204ac6:	00000797          	auipc	a5,0x0
  204aca:	55a78793          	addi	a5,a5,1370 # 205020 <HEAP_START>
  204ace:	639c                	ld	a5,0(a5)
  204ad0:	85be                	mv	a1,a5
  204ad2:	00001517          	auipc	a0,0x1
  204ad6:	01650513          	addi	a0,a0,22 # 205ae8 <BSS_END+0xa80>
  204ada:	c87fd0ef          	jal	ra,202760 <printf>
	printf("last page position:%p\n\r", page);
  204ade:	fe843583          	ld	a1,-24(s0)
  204ae2:	00001517          	auipc	a0,0x1
  204ae6:	02650513          	addi	a0,a0,38 # 205b08 <BSS_END+0xaa0>
  204aea:	c77fd0ef          	jal	ra,202760 <printf>
	#endif
}
  204aee:	0001                	nop
  204af0:	70a2                	ld	ra,40(sp)
  204af2:	7402                	ld	s0,32(sp)
  204af4:	6145                	addi	sp,sp,48
  204af6:	8082                	ret

0000000000204af8 <page_alloc>:
/*
 * Allocate a memory block which is composed of contiguous physical pages
 * - npages: the number of PAGE_SIZE pages to allocate
 */
void *page_alloc(int npages)
{
  204af8:	711d                	addi	sp,sp,-96
  204afa:	ec86                	sd	ra,88(sp)
  204afc:	e8a2                	sd	s0,80(sp)
  204afe:	1080                	addi	s0,sp,96
  204b00:	87aa                	mv	a5,a0
  204b02:	faf42623          	sw	a5,-84(s0)
	/* Note we are searching the page descriptor bitmaps. */
	int found = 0;
  204b06:	fe042623          	sw	zero,-20(s0)
	struct Page *page_i = (struct Page *)HEAP_START;
  204b0a:	00000797          	auipc	a5,0x0
  204b0e:	51678793          	addi	a5,a5,1302 # 205020 <HEAP_START>
  204b12:	639c                	ld	a5,0(a5)
  204b14:	fef43023          	sd	a5,-32(s0)
	for (int i = 0; i <= (_num_pages - npages); i++) {
  204b18:	fc042e23          	sw	zero,-36(s0)
  204b1c:	a229                	j	204c26 <page_alloc+0x12e>
		if (_is_free(page_i)) {
  204b1e:	fe043503          	ld	a0,-32(s0)
  204b22:	d19ff0ef          	jal	ra,20483a <_is_free>
  204b26:	87aa                	mv	a5,a0
  204b28:	c7ed                	beqz	a5,204c12 <page_alloc+0x11a>
			found = 1;
  204b2a:	4785                	li	a5,1
  204b2c:	fef42623          	sw	a5,-20(s0)
			/* 
			 * meet a free page, continue to check if following
			 * (npages - 1) pages are also unallocated.
			 */
			struct Page *page_j = page_i + 1;
  204b30:	fe043783          	ld	a5,-32(s0)
  204b34:	0785                	addi	a5,a5,1
  204b36:	fcf43823          	sd	a5,-48(s0)
			for (int j = i + 1; j < (i + npages); j++) {
  204b3a:	fdc42783          	lw	a5,-36(s0)
  204b3e:	2785                	addiw	a5,a5,1
  204b40:	fcf42623          	sw	a5,-52(s0)
  204b44:	a025                	j	204b6c <page_alloc+0x74>
				if (!_is_free(page_j)) {
  204b46:	fd043503          	ld	a0,-48(s0)
  204b4a:	cf1ff0ef          	jal	ra,20483a <_is_free>
  204b4e:	87aa                	mv	a5,a0
  204b50:	e781                	bnez	a5,204b58 <page_alloc+0x60>
					found = 0;
  204b52:	fe042623          	sw	zero,-20(s0)
					break;
  204b56:	a03d                	j	204b84 <page_alloc+0x8c>
				}
				page_j++;
  204b58:	fd043783          	ld	a5,-48(s0)
  204b5c:	0785                	addi	a5,a5,1
  204b5e:	fcf43823          	sd	a5,-48(s0)
			for (int j = i + 1; j < (i + npages); j++) {
  204b62:	fcc42783          	lw	a5,-52(s0)
  204b66:	2785                	addiw	a5,a5,1
  204b68:	fcf42623          	sw	a5,-52(s0)
  204b6c:	fdc42703          	lw	a4,-36(s0)
  204b70:	fac42783          	lw	a5,-84(s0)
  204b74:	9fb9                	addw	a5,a5,a4
  204b76:	0007871b          	sext.w	a4,a5
  204b7a:	fcc42783          	lw	a5,-52(s0)
  204b7e:	2781                	sext.w	a5,a5
  204b80:	fce7c3e3          	blt	a5,a4,204b46 <page_alloc+0x4e>
			/*
			 * get a memory block which is good enough for us,
			 * take housekeeping, then return the actual start
			 * address of the first page of this memory block
			 */
			if (found) {
  204b84:	fec42783          	lw	a5,-20(s0)
  204b88:	2781                	sext.w	a5,a5
  204b8a:	cfa5                	beqz	a5,204c02 <page_alloc+0x10a>
				struct Page *page_k = page_i;
  204b8c:	fe043783          	ld	a5,-32(s0)
  204b90:	fcf43023          	sd	a5,-64(s0)
				for (int k = i; k < (i + npages); k++) {
  204b94:	fdc42783          	lw	a5,-36(s0)
  204b98:	faf42e23          	sw	a5,-68(s0)
  204b9c:	a005                	j	204bbc <page_alloc+0xc4>
					_set_flag(page_k, PAGE_TAKEN);
  204b9e:	4585                	li	a1,1
  204ba0:	fc043503          	ld	a0,-64(s0)
  204ba4:	cbfff0ef          	jal	ra,204862 <_set_flag>
					page_k++;
  204ba8:	fc043783          	ld	a5,-64(s0)
  204bac:	0785                	addi	a5,a5,1
  204bae:	fcf43023          	sd	a5,-64(s0)
				for (int k = i; k < (i + npages); k++) {
  204bb2:	fbc42783          	lw	a5,-68(s0)
  204bb6:	2785                	addiw	a5,a5,1
  204bb8:	faf42e23          	sw	a5,-68(s0)
  204bbc:	fdc42703          	lw	a4,-36(s0)
  204bc0:	fac42783          	lw	a5,-84(s0)
  204bc4:	9fb9                	addw	a5,a5,a4
  204bc6:	0007871b          	sext.w	a4,a5
  204bca:	fbc42783          	lw	a5,-68(s0)
  204bce:	2781                	sext.w	a5,a5
  204bd0:	fce7c7e3          	blt	a5,a4,204b9e <page_alloc+0xa6>
				}
				page_k--;
  204bd4:	fc043783          	ld	a5,-64(s0)
  204bd8:	17fd                	addi	a5,a5,-1
  204bda:	fcf43023          	sd	a5,-64(s0)
				_set_flag(page_k, PAGE_LAST);
  204bde:	4589                	li	a1,2
  204be0:	fc043503          	ld	a0,-64(s0)
  204be4:	c7fff0ef          	jal	ra,204862 <_set_flag>
				return (void *)(_alloc_start + i * PAGE_SIZE);
  204be8:	fdc42783          	lw	a5,-36(s0)
  204bec:	00c7979b          	slliw	a5,a5,0xc
  204bf0:	2781                	sext.w	a5,a5
  204bf2:	873e                	mv	a4,a5
  204bf4:	00002797          	auipc	a5,0x2
  204bf8:	1ec78793          	addi	a5,a5,492 # 206de0 <_alloc_start>
  204bfc:	639c                	ld	a5,0(a5)
  204bfe:	97ba                	add	a5,a5,a4
  204c00:	a099                	j	204c46 <page_alloc+0x14e>
			}else{
				printf("warning:no suitable pages founded!\n\r");
  204c02:	00001517          	auipc	a0,0x1
  204c06:	f1e50513          	addi	a0,a0,-226 # 205b20 <BSS_END+0xab8>
  204c0a:	b57fd0ef          	jal	ra,202760 <printf>
				return NULL;
  204c0e:	4781                	li	a5,0
  204c10:	a81d                	j	204c46 <page_alloc+0x14e>
			}
		}
		page_i++;
  204c12:	fe043783          	ld	a5,-32(s0)
  204c16:	0785                	addi	a5,a5,1
  204c18:	fef43023          	sd	a5,-32(s0)
	for (int i = 0; i <= (_num_pages - npages); i++) {
  204c1c:	fdc42783          	lw	a5,-36(s0)
  204c20:	2785                	addiw	a5,a5,1
  204c22:	fcf42e23          	sw	a5,-36(s0)
  204c26:	00002797          	auipc	a5,0x2
  204c2a:	1ca78793          	addi	a5,a5,458 # 206df0 <_num_pages>
  204c2e:	4398                	lw	a4,0(a5)
  204c30:	fac42783          	lw	a5,-84(s0)
  204c34:	40f707bb          	subw	a5,a4,a5
  204c38:	0007871b          	sext.w	a4,a5
  204c3c:	fdc42783          	lw	a5,-36(s0)
  204c40:	ecf77fe3          	bgeu	a4,a5,204b1e <page_alloc+0x26>
	}
	return NULL;
  204c44:	4781                	li	a5,0
}
  204c46:	853e                	mv	a0,a5
  204c48:	60e6                	ld	ra,88(sp)
  204c4a:	6446                	ld	s0,80(sp)
  204c4c:	6125                	addi	sp,sp,96
  204c4e:	8082                	ret

0000000000204c50 <page_free>:
/*
 * Free the memory block
 * - p: start address of the memory block
 */
void page_free(void *p)
{
  204c50:	7179                	addi	sp,sp,-48
  204c52:	f406                	sd	ra,40(sp)
  204c54:	f022                	sd	s0,32(sp)
  204c56:	1800                	addi	s0,sp,48
  204c58:	fca43c23          	sd	a0,-40(s0)
	/*
	 * Assert (TBD) if p is invalid
	 */
	if (!p || (ptr_t)p >= _alloc_end) {
  204c5c:	fd843783          	ld	a5,-40(s0)
  204c60:	cfa5                	beqz	a5,204cd8 <page_free+0x88>
  204c62:	fd843703          	ld	a4,-40(s0)
  204c66:	00002797          	auipc	a5,0x2
  204c6a:	18278793          	addi	a5,a5,386 # 206de8 <_alloc_end>
  204c6e:	639c                	ld	a5,0(a5)
  204c70:	06f77463          	bgeu	a4,a5,204cd8 <page_free+0x88>
		return;
	}
	/* get the first page descriptor of this memory block */
	struct Page *page = (struct Page *)HEAP_START;
  204c74:	00000797          	auipc	a5,0x0
  204c78:	3ac78793          	addi	a5,a5,940 # 205020 <HEAP_START>
  204c7c:	639c                	ld	a5,0(a5)
  204c7e:	fef43423          	sd	a5,-24(s0)
	page += ((ptr_t)p - _alloc_start)/ PAGE_SIZE;
  204c82:	fd843703          	ld	a4,-40(s0)
  204c86:	00002797          	auipc	a5,0x2
  204c8a:	15a78793          	addi	a5,a5,346 # 206de0 <_alloc_start>
  204c8e:	639c                	ld	a5,0(a5)
  204c90:	40f707b3          	sub	a5,a4,a5
  204c94:	83b1                	srli	a5,a5,0xc
  204c96:	fe843703          	ld	a4,-24(s0)
  204c9a:	97ba                	add	a5,a5,a4
  204c9c:	fef43423          	sd	a5,-24(s0)
	/* loop and clear all the page descriptors of the memory block */
	while (!_is_free(page)) {
  204ca0:	a02d                	j	204cca <page_free+0x7a>
		if (_is_last(page)) {
  204ca2:	fe843503          	ld	a0,-24(s0)
  204ca6:	befff0ef          	jal	ra,204894 <_is_last>
  204caa:	87aa                	mv	a5,a0
  204cac:	c791                	beqz	a5,204cb8 <page_free+0x68>
			_clear(page);
  204cae:	fe843503          	ld	a0,-24(s0)
  204cb2:	b6fff0ef          	jal	ra,204820 <_clear>
			break;
  204cb6:	a015                	j	204cda <page_free+0x8a>
		} else {
			_clear(page);
  204cb8:	fe843503          	ld	a0,-24(s0)
  204cbc:	b65ff0ef          	jal	ra,204820 <_clear>
			page++;;
  204cc0:	fe843783          	ld	a5,-24(s0)
  204cc4:	0785                	addi	a5,a5,1
  204cc6:	fef43423          	sd	a5,-24(s0)
	while (!_is_free(page)) {
  204cca:	fe843503          	ld	a0,-24(s0)
  204cce:	b6dff0ef          	jal	ra,20483a <_is_free>
  204cd2:	87aa                	mv	a5,a0
  204cd4:	d7f9                	beqz	a5,204ca2 <page_free+0x52>
  204cd6:	a011                	j	204cda <page_free+0x8a>
		return;
  204cd8:	0001                	nop
		}
	}
}
  204cda:	70a2                	ld	ra,40(sp)
  204cdc:	7402                	ld	s0,32(sp)
  204cde:	6145                	addi	sp,sp,48
  204ce0:	8082                	ret

0000000000204ce2 <page_test>:

void page_test()
{
  204ce2:	7179                	addi	sp,sp,-48
  204ce4:	f406                	sd	ra,40(sp)
  204ce6:	f022                	sd	s0,32(sp)
  204ce8:	1800                	addi	s0,sp,48
	void *p = page_alloc(2);
  204cea:	4509                	li	a0,2
  204cec:	e0dff0ef          	jal	ra,204af8 <page_alloc>
  204cf0:	fea43423          	sd	a0,-24(s0)
	printf("p = %p\n\r", p);
  204cf4:	fe843583          	ld	a1,-24(s0)
  204cf8:	00001517          	auipc	a0,0x1
  204cfc:	e5050513          	addi	a0,a0,-432 # 205b48 <BSS_END+0xae0>
  204d00:	a61fd0ef          	jal	ra,202760 <printf>
	//page_free(p);

	void *p2 = page_alloc(7);
  204d04:	451d                	li	a0,7
  204d06:	df3ff0ef          	jal	ra,204af8 <page_alloc>
  204d0a:	fea43023          	sd	a0,-32(s0)
	printf("p2 = %p\n\r", p2);
  204d0e:	fe043583          	ld	a1,-32(s0)
  204d12:	00001517          	auipc	a0,0x1
  204d16:	e4650513          	addi	a0,a0,-442 # 205b58 <BSS_END+0xaf0>
  204d1a:	a47fd0ef          	jal	ra,202760 <printf>
	page_free(p);
  204d1e:	fe843503          	ld	a0,-24(s0)
  204d22:	f2fff0ef          	jal	ra,204c50 <page_free>

	void *p3 = page_alloc(1);
  204d26:	4505                	li	a0,1
  204d28:	dd1ff0ef          	jal	ra,204af8 <page_alloc>
  204d2c:	fca43c23          	sd	a0,-40(s0)
	printf("p3 = %p\n\r", p3);
  204d30:	fd843583          	ld	a1,-40(s0)
  204d34:	00001517          	auipc	a0,0x1
  204d38:	e3450513          	addi	a0,a0,-460 # 205b68 <BSS_END+0xb00>
  204d3c:	a25fd0ef          	jal	ra,202760 <printf>
}
  204d40:	0001                	nop
  204d42:	70a2                	ld	ra,40(sp)
  204d44:	7402                	ld	s0,32(sp)
  204d46:	6145                	addi	sp,sp,48
  204d48:	8082                	ret

0000000000204d4a <w_mscratch>:
static void w_mscratch(reg_t x){
  204d4a:	1101                	addi	sp,sp,-32
  204d4c:	ec22                	sd	s0,24(sp)
  204d4e:	1000                	addi	s0,sp,32
  204d50:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  204d54:	fe843783          	ld	a5,-24(s0)
  204d58:	34079073          	csrw	mscratch,a5
}
  204d5c:	0001                	nop
  204d5e:	6462                	ld	s0,24(sp)
  204d60:	6105                	addi	sp,sp,32
  204d62:	8082                	ret

0000000000204d64 <r_mscratch>:
static reg_t r_mscratch(){
  204d64:	1101                	addi	sp,sp,-32
  204d66:	ec22                	sd	s0,24(sp)
  204d68:	1000                	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  204d6a:	340027f3          	csrr	a5,mscratch
  204d6e:	fef43423          	sd	a5,-24(s0)
	return ret;
  204d72:	fe843783          	ld	a5,-24(s0)
}
  204d76:	853e                	mv	a0,a5
  204d78:	6462                	ld	s0,24(sp)
  204d7a:	6105                	addi	sp,sp,32
  204d7c:	8082                	ret

0000000000204d7e <r_mstatus>:
static inline reg_t r_mstatus(){
  204d7e:	1101                	addi	sp,sp,-32
  204d80:	ec22                	sd	s0,24(sp)
  204d82:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
  204d84:	300027f3          	csrr	a5,mstatus
  204d88:	fef43423          	sd	a5,-24(s0)
	return x;
  204d8c:	fe843783          	ld	a5,-24(s0)
}
  204d90:	853e                	mv	a0,a5
  204d92:	6462                	ld	s0,24(sp)
  204d94:	6105                	addi	sp,sp,32
  204d96:	8082                	ret

0000000000204d98 <r_mtvec>:
static inline reg_t r_mtvec(){
  204d98:	1101                	addi	sp,sp,-32
  204d9a:	ec22                	sd	s0,24(sp)
  204d9c:	1000                	addi	s0,sp,32
	asm volatile("csrr  %0, mtvec" :  "=r" (ret):);
  204d9e:	305027f3          	csrr	a5,mtvec
  204da2:	fef43423          	sd	a5,-24(s0)
	return ret;
  204da6:	fe843783          	ld	a5,-24(s0)
}
  204daa:	853e                	mv	a0,a5
  204dac:	6462                	ld	s0,24(sp)
  204dae:	6105                	addi	sp,sp,32
  204db0:	8082                	ret

0000000000204db2 <r_mie>:
{
  204db2:	1101                	addi	sp,sp,-32
  204db4:	ec22                	sd	s0,24(sp)
  204db6:	1000                	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  204db8:	304027f3          	csrr	a5,mie
  204dbc:	fef43423          	sd	a5,-24(s0)
	return x;
  204dc0:	fe843783          	ld	a5,-24(s0)
}
  204dc4:	853e                	mv	a0,a5
  204dc6:	6462                	ld	s0,24(sp)
  204dc8:	6105                	addi	sp,sp,32
  204dca:	8082                	ret

0000000000204dcc <get_time>:
static uint64_t get_time(){
  204dcc:	1141                	addi	sp,sp,-16
  204dce:	e422                	sd	s0,8(sp)
  204dd0:	0800                	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  204dd2:	00002797          	auipc	a5,0x2
  204dd6:	02678793          	addi	a5,a5,38 # 206df8 <_tick>
  204dda:	6398                	ld	a4,0(a5)
  204ddc:	03c00793          	li	a5,60
  204de0:	02f757b3          	divu	a5,a4,a5
}
  204de4:	853e                	mv	a0,a5
  204de6:	6422                	ld	s0,8(sp)
  204de8:	0141                	addi	sp,sp,16
  204dea:	8082                	ret

0000000000204dec <get_time_str>:
static void get_time_str(char* time){
  204dec:	7139                	addi	sp,sp,-64
  204dee:	fc22                	sd	s0,56(sp)
  204df0:	0080                	addi	s0,sp,64
  204df2:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  204df6:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  204dfa:	00002797          	auipc	a5,0x2
  204dfe:	ffe78793          	addi	a5,a5,-2 # 206df8 <_tick>
  204e02:	6398                	ld	a4,0(a5)
  204e04:	03c00793          	li	a5,60
  204e08:	02f757b3          	divu	a5,a4,a5
  204e0c:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  204e10:	fe043703          	ld	a4,-32(s0)
  204e14:	6785                	lui	a5,0x1
  204e16:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  204e1a:	02f757b3          	divu	a5,a4,a5
  204e1e:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  204e22:	fdf44703          	lbu	a4,-33(s0)
  204e26:	06400793          	li	a5,100
  204e2a:	02f777bb          	remuw	a5,a4,a5
  204e2e:	0ff7f793          	andi	a5,a5,255
  204e32:	873e                	mv	a4,a5
  204e34:	47a9                	li	a5,10
  204e36:	02f757bb          	divuw	a5,a4,a5
  204e3a:	0ff7f793          	andi	a5,a5,255
  204e3e:	0307879b          	addiw	a5,a5,48
  204e42:	0ff7f713          	andi	a4,a5,255
  204e46:	fc843783          	ld	a5,-56(s0)
  204e4a:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  204e4e:	fdf44703          	lbu	a4,-33(s0)
  204e52:	47a9                	li	a5,10
  204e54:	02f777bb          	remuw	a5,a4,a5
  204e58:	0ff7f713          	andi	a4,a5,255
  204e5c:	fc843783          	ld	a5,-56(s0)
  204e60:	0785                	addi	a5,a5,1
  204e62:	0307071b          	addiw	a4,a4,48
  204e66:	0ff77713          	andi	a4,a4,255
  204e6a:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  204e6e:	fc843783          	ld	a5,-56(s0)
  204e72:	0789                	addi	a5,a5,2
  204e74:	03a00713          	li	a4,58
  204e78:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  204e7c:	fe043703          	ld	a4,-32(s0)
  204e80:	6785                	lui	a5,0x1
  204e82:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  204e86:	02f77733          	remu	a4,a4,a5
  204e8a:	03c00793          	li	a5,60
  204e8e:	02f757b3          	divu	a5,a4,a5
  204e92:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  204e96:	fdf44703          	lbu	a4,-33(s0)
  204e9a:	47a9                	li	a5,10
  204e9c:	02f757bb          	divuw	a5,a4,a5
  204ea0:	0ff7f713          	andi	a4,a5,255
  204ea4:	fc843783          	ld	a5,-56(s0)
  204ea8:	078d                	addi	a5,a5,3
  204eaa:	0307071b          	addiw	a4,a4,48
  204eae:	0ff77713          	andi	a4,a4,255
  204eb2:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  204eb6:	fdf44703          	lbu	a4,-33(s0)
  204eba:	47a9                	li	a5,10
  204ebc:	02f777bb          	remuw	a5,a4,a5
  204ec0:	0ff7f713          	andi	a4,a5,255
  204ec4:	fc843783          	ld	a5,-56(s0)
  204ec8:	0791                	addi	a5,a5,4
  204eca:	0307071b          	addiw	a4,a4,48
  204ece:	0ff77713          	andi	a4,a4,255
  204ed2:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  204ed6:	fc843783          	ld	a5,-56(s0)
  204eda:	0795                	addi	a5,a5,5
  204edc:	03a00713          	li	a4,58
  204ee0:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  204ee4:	fe043703          	ld	a4,-32(s0)
  204ee8:	03c00793          	li	a5,60
  204eec:	02f777b3          	remu	a5,a4,a5
  204ef0:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  204ef4:	fdf44703          	lbu	a4,-33(s0)
  204ef8:	47a9                	li	a5,10
  204efa:	02f757bb          	divuw	a5,a4,a5
  204efe:	0ff7f713          	andi	a4,a5,255
  204f02:	fc843783          	ld	a5,-56(s0)
  204f06:	0799                	addi	a5,a5,6
  204f08:	0307071b          	addiw	a4,a4,48
  204f0c:	0ff77713          	andi	a4,a4,255
  204f10:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  204f14:	fdf44703          	lbu	a4,-33(s0)
  204f18:	47a9                	li	a5,10
  204f1a:	02f777bb          	remuw	a5,a4,a5
  204f1e:	0ff7f713          	andi	a4,a5,255
  204f22:	fc843783          	ld	a5,-56(s0)
  204f26:	079d                	addi	a5,a5,7
  204f28:	0307071b          	addiw	a4,a4,48
  204f2c:	0ff77713          	andi	a4,a4,255
  204f30:	00e78023          	sb	a4,0(a5)
}
  204f34:	0001                	nop
  204f36:	7462                	ld	s0,56(sp)
  204f38:	6121                	addi	sp,sp,64
  204f3a:	8082                	ret

0000000000204f3c <start_kernel>:
 * so just declared here ONCE and NOT included in file os.h.
 */


void start_kernel(void)
{
  204f3c:	1141                	addi	sp,sp,-16
  204f3e:	e406                	sd	ra,8(sp)
  204f40:	e022                	sd	s0,0(sp)
  204f42:	0800                	addi	s0,sp,16
	uart_init();
  204f44:	8f4fe0ef          	jal	ra,203038 <uart_init>
	printf("Hello, GROL_OS!\n\r");//this should be replaced with graph later
  204f48:	00001517          	auipc	a0,0x1
  204f4c:	c3050513          	addi	a0,a0,-976 # 205b78 <BSS_END+0xb10>
  204f50:	811fd0ef          	jal	ra,202760 <printf>
	#ifdef MYPRINT
	printf("mtvec:%p\n\r", r_mtvec());
  204f54:	e45ff0ef          	jal	ra,204d98 <r_mtvec>
  204f58:	87aa                	mv	a5,a0
  204f5a:	85be                	mv	a1,a5
  204f5c:	00001517          	auipc	a0,0x1
  204f60:	c3450513          	addi	a0,a0,-972 # 205b90 <BSS_END+0xb28>
  204f64:	ffcfd0ef          	jal	ra,202760 <printf>
	printf("mstatus:%p\n\r", r_mstatus());
  204f68:	e17ff0ef          	jal	ra,204d7e <r_mstatus>
  204f6c:	87aa                	mv	a5,a0
  204f6e:	85be                	mv	a1,a5
  204f70:	00001517          	auipc	a0,0x1
  204f74:	c3050513          	addi	a0,a0,-976 # 205ba0 <BSS_END+0xb38>
  204f78:	fe8fd0ef          	jal	ra,202760 <printf>
	print_printftest();
  204f7c:	e36fe0ef          	jal	ra,2035b2 <print_printftest>
	#endif
	trap_init();
  204f80:	f05fd0ef          	jal	ra,202e84 <trap_init>
	#ifdef MYPRINT
	printf("mtvec:%p\n\r", r_mtvec());
  204f84:	e15ff0ef          	jal	ra,204d98 <r_mtvec>
  204f88:	87aa                	mv	a5,a0
  204f8a:	85be                	mv	a1,a5
  204f8c:	00001517          	auipc	a0,0x1
  204f90:	c0450513          	addi	a0,a0,-1020 # 205b90 <BSS_END+0xb28>
  204f94:	fccfd0ef          	jal	ra,202760 <printf>
	printf("mstatus:%p\n\r", r_mstatus());
  204f98:	de7ff0ef          	jal	ra,204d7e <r_mstatus>
  204f9c:	87aa                	mv	a5,a0
  204f9e:	85be                	mv	a1,a5
  204fa0:	00001517          	auipc	a0,0x1
  204fa4:	c0050513          	addi	a0,a0,-1024 # 205ba0 <BSS_END+0xb38>
  204fa8:	fb8fd0ef          	jal	ra,202760 <printf>
	//trap_test();
	#endif
	sched_init(60);
  204fac:	03c00513          	li	a0,60
  204fb0:	ed5fe0ef          	jal	ra,203e84 <sched_init>
	plic_init();
  204fb4:	cfefe0ef          	jal	ra,2034b2 <plic_init>
	timer_init();
  204fb8:	e34ff0ef          	jal	ra,2045ec <timer_init>
	#ifdef MYPRINT
	printf("mtvec:%p\n\r", r_mtvec());
  204fbc:	dddff0ef          	jal	ra,204d98 <r_mtvec>
  204fc0:	87aa                	mv	a5,a0
  204fc2:	85be                	mv	a1,a5
  204fc4:	00001517          	auipc	a0,0x1
  204fc8:	bcc50513          	addi	a0,a0,-1076 # 205b90 <BSS_END+0xb28>
  204fcc:	f94fd0ef          	jal	ra,202760 <printf>
	printf("mstatus:%p\n\r", r_mstatus());
  204fd0:	dafff0ef          	jal	ra,204d7e <r_mstatus>
  204fd4:	87aa                	mv	a5,a0
  204fd6:	85be                	mv	a1,a5
  204fd8:	00001517          	auipc	a0,0x1
  204fdc:	bc850513          	addi	a0,a0,-1080 # 205ba0 <BSS_END+0xb38>
  204fe0:	f80fd0ef          	jal	ra,202760 <printf>
	printf("mie:%p\n\r", r_mie());
  204fe4:	dcfff0ef          	jal	ra,204db2 <r_mie>
  204fe8:	87aa                	mv	a5,a0
  204fea:	85be                	mv	a1,a5
  204fec:	00001517          	auipc	a0,0x1
  204ff0:	bc450513          	addi	a0,a0,-1084 # 205bb0 <BSS_END+0xb48>
  204ff4:	f6cfd0ef          	jal	ra,202760 <printf>
	#endif

	page_init();
  204ff8:	8f3ff0ef          	jal	ra,2048ea <page_init>
	print_heapinit();
  204ffc:	e66fe0ef          	jal	ra,203662 <print_heapinit>
	#ifdef MYPRINT
	page_test();
  205000:	ce3ff0ef          	jal	ra,204ce2 <page_test>
	#endif
	print_multitasktest();
  205004:	ea0fe0ef          	jal	ra,2036a4 <print_multitasktest>

	os_main();
  205008:	c2bfd0ef          	jal	ra,202c32 <os_main>

	kernel_schedule();
  20500c:	d01fe0ef          	jal	ra,203d0c <kernel_schedule>

	printf("Would not go here!\n\r");
  205010:	00001517          	auipc	a0,0x1
  205014:	bb050513          	addi	a0,a0,-1104 # 205bc0 <BSS_END+0xb58>
  205018:	f48fd0ef          	jal	ra,202760 <printf>

	while (1) {}; // stop here!
  20501c:	a001                	j	20501c <start_kernel+0xe0>
