
bin/GROL.elf:     file format elf64-littleriscv


Disassembly of section .text:

0000000000200000 <_start>:
	.global	_start

	.text
_start:
	# park harts with id != 0
	csrr	t0, mhartid		# read current hart id
  200000:	f14022f3          	csrr	t0,mhartid
	mv	tp, t0			# keep CPU's hartid in its tp for later usage.
  200004:	00028213          	mv	tp,t0
	bnez	t0, park		# if we're not on the hart 0
  200008:	02029c63          	bnez	t0,200040 <park>
					# we park the hart

	# Set all bytes in the BSS section to zero.
	la	a0, _bss_start
  20000c:	00007517          	auipc	a0,0x7
  200010:	06450513          	addi	a0,a0,100 # 207070 <_bss_start>
	la	a1, _bss_end
  200014:	0000b597          	auipc	a1,0xb
  200018:	09c58593          	addi	a1,a1,156 # 20b0b0 <_bss_end>
	bgeu	a0, a1, 2f
  20001c:	00b57863          	bgeu	a0,a1,20002c <_start+0x2c>
1:
	sw	zero, (a0)
  200020:	00052023          	sw	zero,0(a0)
	addi	a0, a0, 4
  200024:	00450513          	addi	a0,a0,4
	bltu	a0, a1, 1b
  200028:	feb56ce3          	bltu	a0,a1,200020 <_start+0x20>
2:
	# Setup stacks, the stack grows from bottom to top, so we put the
	# stack pointer to the very end of the stack range.
	slli	t0, t0, 10		# shift left the hart id by 1024
  20002c:	00a29293          	slli	t0,t0,0xa
	la	sp, stacks + STACK_SIZE	# set the initial stack pointer
  200030:	00000117          	auipc	sp,0x0
  200034:	42010113          	addi	sp,sp,1056 # 200450 <stacks+0x400>
					# to the end of the first stack space
	add	sp, sp, t0		# move the current hart stack pointer
  200038:	00510133          	add	sp,sp,t0
					# to its place in the stack space

	j	start_kernel		# hart 0 jump to c
  20003c:	3910506f          	j	205bcc <start_kernel>

0000000000200040 <park>:

park:
	wfi
  200040:	10500073          	wfi
	j	park
  200044:	ffdff06f          	j	200040 <park>
  200048:	00000013          	nop
  20004c:	00000013          	nop

0000000000200050 <stacks>:
	...

000000000020205c <trap_vector>:
.globl trap_vector
# the trap vector base address must always be aligned on a 4-byte boundary
.balign 4
trap_vector:
	# save context(registers).
	csrrw	t6, mscratch, t6	# swap t6 and mscratch
  20205c:	340f9ff3          	csrrw	t6,mscratch,t6
	reg_save t6
  202060:	001fb023          	sd	ra,0(t6)
  202064:	002fb423          	sd	sp,8(t6)
  202068:	025fb023          	sd	t0,32(t6)
  20206c:	026fb423          	sd	t1,40(t6)
  202070:	027fb823          	sd	t2,48(t6)
  202074:	028fbc23          	sd	s0,56(t6)
  202078:	049fb023          	sd	s1,64(t6)
  20207c:	04afb423          	sd	a0,72(t6)
  202080:	04bfb823          	sd	a1,80(t6)
  202084:	04cfbc23          	sd	a2,88(t6)
  202088:	06dfb023          	sd	a3,96(t6)
  20208c:	06efb423          	sd	a4,104(t6)
  202090:	06ffb823          	sd	a5,112(t6)
  202094:	070fbc23          	sd	a6,120(t6)
  202098:	091fb023          	sd	a7,128(t6)
  20209c:	092fb423          	sd	s2,136(t6)
  2020a0:	093fb823          	sd	s3,144(t6)
  2020a4:	094fbc23          	sd	s4,152(t6)
  2020a8:	0b5fb023          	sd	s5,160(t6)
  2020ac:	0b6fb423          	sd	s6,168(t6)
  2020b0:	0b7fb823          	sd	s7,176(t6)
  2020b4:	0b8fbc23          	sd	s8,184(t6)
  2020b8:	0d9fb023          	sd	s9,192(t6)
  2020bc:	0dafb423          	sd	s10,200(t6)
  2020c0:	0dbfb823          	sd	s11,208(t6)
  2020c4:	0dcfbc23          	sd	t3,216(t6)
  2020c8:	0fdfb023          	sd	t4,224(t6)
  2020cc:	0fefb423          	sd	t5,232(t6)

	# Save the actual t6 register, which we swapped into
	# mscratch
	mv	t5, t6			# t5 points to the context of current task
  2020d0:	000f8f13          	mv	t5,t6
	csrr	t6, mscratch		# read t6 back from mscratch
  2020d4:	34002ff3          	csrr	t6,mscratch
	STORE	t6, 30*SIZE_REG(t5)	# save t6 with t5 as base
  2020d8:	0fff3823          	sd	t6,240(t5)

	csrr 	a0, mepc
  2020dc:	34102573          	csrr	a0,mepc
	STORE	a0, 31*SIZE_REG(t5) #save current mepc
  2020e0:	0eaf3c23          	sd	a0,248(t5)

	# Restore the context pointer into mscratch
	csrw	mscratch, t5
  2020e4:	340f1073          	csrw	mscratch,t5

	# call the C trap handler in trap.c
	csrr	a0, mepc
  2020e8:	34102573          	csrr	a0,mepc
	csrr	a1, mcause
  2020ec:	342025f3          	csrr	a1,mcause
	call	trap_handler
  2020f0:	6d5000ef          	jal	ra,202fc4 <trap_handler>

	# trap_handler will return the return address via a0.
	csrw	mepc, a0
  2020f4:	34151073          	csrw	mepc,a0

	# restore context(registers).
	csrr	t6, mscratch
  2020f8:	34002ff3          	csrr	t6,mscratch
	reg_restore t6
  2020fc:	000fb083          	ld	ra,0(t6)
  202100:	008fb103          	ld	sp,8(t6)
  202104:	020fb283          	ld	t0,32(t6)
  202108:	028fb303          	ld	t1,40(t6)
  20210c:	030fb383          	ld	t2,48(t6)
  202110:	038fb403          	ld	s0,56(t6)
  202114:	040fb483          	ld	s1,64(t6)
  202118:	048fb503          	ld	a0,72(t6)
  20211c:	050fb583          	ld	a1,80(t6)
  202120:	058fb603          	ld	a2,88(t6)
  202124:	060fb683          	ld	a3,96(t6)
  202128:	068fb703          	ld	a4,104(t6)
  20212c:	070fb783          	ld	a5,112(t6)
  202130:	078fb803          	ld	a6,120(t6)
  202134:	080fb883          	ld	a7,128(t6)
  202138:	088fb903          	ld	s2,136(t6)
  20213c:	090fb983          	ld	s3,144(t6)
  202140:	098fba03          	ld	s4,152(t6)
  202144:	0a0fba83          	ld	s5,160(t6)
  202148:	0a8fbb03          	ld	s6,168(t6)
  20214c:	0b0fbb83          	ld	s7,176(t6)
  202150:	0b8fbc03          	ld	s8,184(t6)
  202154:	0c0fbc83          	ld	s9,192(t6)
  202158:	0c8fbd03          	ld	s10,200(t6)
  20215c:	0d0fbd83          	ld	s11,208(t6)
  202160:	0d8fbe03          	ld	t3,216(t6)
  202164:	0e0fbe83          	ld	t4,224(t6)
  202168:	0e8fbf03          	ld	t5,232(t6)
  20216c:	0f0fbf83          	ld	t6,240(t6)

	# return to whatever we were doing before trap.
	mret
  202170:	30200073          	mret

0000000000202174 <switch_to>:
#	csrr	t6, mscratch		# read t6 back from mscratch
#	STORE	t6, 30*SIZE_REG(t5)	# save t6 with t5 as base

# 1:
	# switch mscratch to point to the context of the next task
	csrw	mscratch, a0
  202174:	34051073          	csrw	mscratch,a0


	LOAD	a1, 31*SIZE_REG(a0)
  202178:	0f853583          	ld	a1,248(a0)
	csrw	mepc, a1
  20217c:	34159073          	csrw	mepc,a1
	#read mepc of context and set it


	# Restore all GP registers
	# Use t6 to point to the context of the new task
	mv	t6, a0
  202180:	00050f93          	mv	t6,a0
	reg_restore t6
  202184:	000fb083          	ld	ra,0(t6)
  202188:	008fb103          	ld	sp,8(t6)
  20218c:	020fb283          	ld	t0,32(t6)
  202190:	028fb303          	ld	t1,40(t6)
  202194:	030fb383          	ld	t2,48(t6)
  202198:	038fb403          	ld	s0,56(t6)
  20219c:	040fb483          	ld	s1,64(t6)
  2021a0:	048fb503          	ld	a0,72(t6)
  2021a4:	050fb583          	ld	a1,80(t6)
  2021a8:	058fb603          	ld	a2,88(t6)
  2021ac:	060fb683          	ld	a3,96(t6)
  2021b0:	068fb703          	ld	a4,104(t6)
  2021b4:	070fb783          	ld	a5,112(t6)
  2021b8:	078fb803          	ld	a6,120(t6)
  2021bc:	080fb883          	ld	a7,128(t6)
  2021c0:	088fb903          	ld	s2,136(t6)
  2021c4:	090fb983          	ld	s3,144(t6)
  2021c8:	098fba03          	ld	s4,152(t6)
  2021cc:	0a0fba83          	ld	s5,160(t6)
  2021d0:	0a8fbb03          	ld	s6,168(t6)
  2021d4:	0b0fbb83          	ld	s7,176(t6)
  2021d8:	0b8fbc03          	ld	s8,184(t6)
  2021dc:	0c0fbc83          	ld	s9,192(t6)
  2021e0:	0c8fbd03          	ld	s10,200(t6)
  2021e4:	0d0fbd83          	ld	s11,208(t6)
  2021e8:	0d8fbe03          	ld	t3,216(t6)
  2021ec:	0e0fbe83          	ld	t4,224(t6)
  2021f0:	0e8fbf03          	ld	t5,232(t6)
  2021f4:	0f0fbf83          	ld	t6,240(t6)

	# Do actual context switching.
	mret
  2021f8:	30200073          	mret

00000000002021fc <mod10>:
#include "printf.h"
/*
 * ref: https://github.com/cccriscv/mini-riscv-os/blob/master/05-Preemptive/lib.c
 */
static int mod10(long n){
  2021fc:	fd010113          	addi	sp,sp,-48
  202200:	02813423          	sd	s0,40(sp)
  202204:	03010413          	addi	s0,sp,48
  202208:	fca43c23          	sd	a0,-40(s0)
	unsigned int upn = *((int*)&n + 1);
  20220c:	fd840793          	addi	a5,s0,-40
  202210:	00478793          	addi	a5,a5,4
  202214:	0007a783          	lw	a5,0(a5)
  202218:	fef42623          	sw	a5,-20(s0)
	unsigned int downn = *(int*)&n ;
  20221c:	fd840793          	addi	a5,s0,-40
  202220:	0007a783          	lw	a5,0(a5)
  202224:	fef42423          	sw	a5,-24(s0)
	return (((upn % 10) * 6 + downn % 10)) % 10;
  202228:	fec42703          	lw	a4,-20(s0)
  20222c:	00a00793          	li	a5,10
  202230:	02f777bb          	remuw	a5,a4,a5
  202234:	0007879b          	sext.w	a5,a5
  202238:	00078713          	mv	a4,a5
  20223c:	00070793          	mv	a5,a4
  202240:	0017979b          	slliw	a5,a5,0x1
  202244:	00e787bb          	addw	a5,a5,a4
  202248:	0017979b          	slliw	a5,a5,0x1
  20224c:	0007871b          	sext.w	a4,a5
  202250:	fe842683          	lw	a3,-24(s0)
  202254:	00a00793          	li	a5,10
  202258:	02f6f7bb          	remuw	a5,a3,a5
  20225c:	0007879b          	sext.w	a5,a5
  202260:	00f707bb          	addw	a5,a4,a5
  202264:	0007879b          	sext.w	a5,a5
  202268:	00078713          	mv	a4,a5
  20226c:	00a00793          	li	a5,10
  202270:	02f777bb          	remuw	a5,a4,a5
  202274:	0007879b          	sext.w	a5,a5
  202278:	0007879b          	sext.w	a5,a5
}
  20227c:	00078513          	mv	a0,a5
  202280:	02813403          	ld	s0,40(sp)
  202284:	03010113          	addi	sp,sp,48
  202288:	00008067          	ret

000000000020228c <div10>:
(a*2^32 + b) mod 10 = a * 2^32 mod 10 + b mod 10
					= (a mod 10) * (2 ^ 32)mod 10 + b mod 10
					= 6(a mod 10) + b mod 10
*/

static long div10(long n){
  20228c:	fd010113          	addi	sp,sp,-48
  202290:	02813423          	sd	s0,40(sp)
  202294:	03010413          	addi	s0,sp,48
  202298:	fca43c23          	sd	a0,-40(s0)
	long a = 10;
  20229c:	00a00793          	li	a5,10
  2022a0:	fef43423          	sd	a5,-24(s0)
	long ret;
	asm volatile (
  2022a4:	fd843783          	ld	a5,-40(s0)
  2022a8:	fe843703          	ld	a4,-24(s0)
  2022ac:	02e7c7b3          	div	a5,a5,a4
  2022b0:	fef43023          	sd	a5,-32(s0)
		"div %[sum], %[add1], %[add2]" 
		:[sum]"=r"(ret)
		:[add1]"r"(n), [add2]"r"(a)
	);
	return ret;
  2022b4:	fe043783          	ld	a5,-32(s0)
}
  2022b8:	00078513          	mv	a0,a5
  2022bc:	02813403          	ld	s0,40(sp)
  2022c0:	03010113          	addi	sp,sp,48
  2022c4:	00008067          	ret

00000000002022c8 <_vsnprintf>:

static int _vsnprintf(char * out, size_t n, const char* s, va_list vl)
{
  2022c8:	f8010113          	addi	sp,sp,-128
  2022cc:	06113c23          	sd	ra,120(sp)
  2022d0:	06813823          	sd	s0,112(sp)
  2022d4:	08010413          	addi	s0,sp,128
  2022d8:	f8a43c23          	sd	a0,-104(s0)
  2022dc:	f8b43823          	sd	a1,-112(s0)
  2022e0:	f8c43423          	sd	a2,-120(s0)
  2022e4:	f8d43023          	sd	a3,-128(s0)
	int format = 0;
  2022e8:	fe042623          	sw	zero,-20(s0)
	int longarg = 0;
  2022ec:	fe042423          	sw	zero,-24(s0)
	size_t pos = 0;
  2022f0:	fe043023          	sd	zero,-32(s0)
	for (; *s; s++) {
  2022f4:	4600006f          	j	202754 <_vsnprintf+0x48c>
		if (format) {
  2022f8:	fec42783          	lw	a5,-20(s0)
  2022fc:	0007879b          	sext.w	a5,a5
  202300:	3e078463          	beqz	a5,2026e8 <_vsnprintf+0x420>
			switch(*s) {
  202304:	f8843783          	ld	a5,-120(s0)
  202308:	0007c783          	lbu	a5,0(a5)
  20230c:	0007879b          	sext.w	a5,a5
  202310:	f9d7869b          	addiw	a3,a5,-99
  202314:	0006871b          	sext.w	a4,a3
  202318:	01500793          	li	a5,21
  20231c:	42e7e463          	bltu	a5,a4,202744 <_vsnprintf+0x47c>
  202320:	02069793          	slli	a5,a3,0x20
  202324:	0207d793          	srli	a5,a5,0x20
  202328:	00279713          	slli	a4,a5,0x2
  20232c:	00004797          	auipc	a5,0x4
  202330:	9fc78793          	addi	a5,a5,-1540 # 205d28 <BSS_END+0x8>
  202334:	00f707b3          	add	a5,a4,a5
  202338:	0007a783          	lw	a5,0(a5)
  20233c:	0007871b          	sext.w	a4,a5
  202340:	00004797          	auipc	a5,0x4
  202344:	9e878793          	addi	a5,a5,-1560 # 205d28 <BSS_END+0x8>
  202348:	00f707b3          	add	a5,a4,a5
  20234c:	00078067          	jr	a5
			case 'l': {
				longarg = 1;
  202350:	00100793          	li	a5,1
  202354:	fef42423          	sw	a5,-24(s0)
				break;
  202358:	3f00006f          	j	202748 <_vsnprintf+0x480>
			}
			case 'p': {
				longarg = 1;
  20235c:	00100793          	li	a5,1
  202360:	fef42423          	sw	a5,-24(s0)
				if (out && pos < n) {
  202364:	f9843783          	ld	a5,-104(s0)
  202368:	02078263          	beqz	a5,20238c <_vsnprintf+0xc4>
  20236c:	fe043703          	ld	a4,-32(s0)
  202370:	f9043783          	ld	a5,-112(s0)
  202374:	00f77c63          	bgeu	a4,a5,20238c <_vsnprintf+0xc4>
					out[pos] = '0';
  202378:	f9843703          	ld	a4,-104(s0)
  20237c:	fe043783          	ld	a5,-32(s0)
  202380:	00f707b3          	add	a5,a4,a5
  202384:	03000713          	li	a4,48
  202388:	00e78023          	sb	a4,0(a5)
				}
				pos++;
  20238c:	fe043783          	ld	a5,-32(s0)
  202390:	00178793          	addi	a5,a5,1
  202394:	fef43023          	sd	a5,-32(s0)
				if (out && pos < n) {
  202398:	f9843783          	ld	a5,-104(s0)
  20239c:	02078263          	beqz	a5,2023c0 <_vsnprintf+0xf8>
  2023a0:	fe043703          	ld	a4,-32(s0)
  2023a4:	f9043783          	ld	a5,-112(s0)
  2023a8:	00f77c63          	bgeu	a4,a5,2023c0 <_vsnprintf+0xf8>
					out[pos] = 'x';
  2023ac:	f9843703          	ld	a4,-104(s0)
  2023b0:	fe043783          	ld	a5,-32(s0)
  2023b4:	00f707b3          	add	a5,a4,a5
  2023b8:	07800713          	li	a4,120
  2023bc:	00e78023          	sb	a4,0(a5)
				}
				pos++;
  2023c0:	fe043783          	ld	a5,-32(s0)
  2023c4:	00178793          	addi	a5,a5,1
  2023c8:	fef43023          	sd	a5,-32(s0)
			}
			case 'x': {
				long num = longarg ? va_arg(vl, long) : va_arg(vl, int);
  2023cc:	fe842783          	lw	a5,-24(s0)
  2023d0:	0007879b          	sext.w	a5,a5
  2023d4:	00078c63          	beqz	a5,2023ec <_vsnprintf+0x124>
  2023d8:	f8043783          	ld	a5,-128(s0)
  2023dc:	00878713          	addi	a4,a5,8
  2023e0:	f8e43023          	sd	a4,-128(s0)
  2023e4:	0007b783          	ld	a5,0(a5)
  2023e8:	0140006f          	j	2023fc <_vsnprintf+0x134>
  2023ec:	f8043783          	ld	a5,-128(s0)
  2023f0:	00878713          	addi	a4,a5,8
  2023f4:	f8e43023          	sd	a4,-128(s0)
  2023f8:	0007a783          	lw	a5,0(a5)
  2023fc:	faf43423          	sd	a5,-88(s0)
				int hexdigits = 2*(longarg ? sizeof(long) : sizeof(int))-1;
  202400:	fe842783          	lw	a5,-24(s0)
  202404:	0007879b          	sext.w	a5,a5
  202408:	00078663          	beqz	a5,202414 <_vsnprintf+0x14c>
  20240c:	00f00793          	li	a5,15
  202410:	0080006f          	j	202418 <_vsnprintf+0x150>
  202414:	00700793          	li	a5,7
  202418:	faf42223          	sw	a5,-92(s0)
				for(int i = hexdigits; i >= 0; i--) {
  20241c:	fa442783          	lw	a5,-92(s0)
  202420:	fcf42e23          	sw	a5,-36(s0)
  202424:	0940006f          	j	2024b8 <_vsnprintf+0x1f0>
					int d = (num >> (4*i)) & 0xF;
  202428:	fdc42783          	lw	a5,-36(s0)
  20242c:	0027979b          	slliw	a5,a5,0x2
  202430:	0007879b          	sext.w	a5,a5
  202434:	fa843703          	ld	a4,-88(s0)
  202438:	40f757b3          	sra	a5,a4,a5
  20243c:	0007879b          	sext.w	a5,a5
  202440:	00f7f793          	andi	a5,a5,15
  202444:	faf42023          	sw	a5,-96(s0)
					if (out && pos < n) {
  202448:	f9843783          	ld	a5,-104(s0)
  20244c:	04078a63          	beqz	a5,2024a0 <_vsnprintf+0x1d8>
  202450:	fe043703          	ld	a4,-32(s0)
  202454:	f9043783          	ld	a5,-112(s0)
  202458:	04f77463          	bgeu	a4,a5,2024a0 <_vsnprintf+0x1d8>
						out[pos] = (d < 10 ? '0'+d : 'a'+d-10);
  20245c:	fa042783          	lw	a5,-96(s0)
  202460:	0007871b          	sext.w	a4,a5
  202464:	00900793          	li	a5,9
  202468:	00e7cc63          	blt	a5,a4,202480 <_vsnprintf+0x1b8>
  20246c:	fa042783          	lw	a5,-96(s0)
  202470:	0ff7f793          	andi	a5,a5,255
  202474:	0307879b          	addiw	a5,a5,48
  202478:	0ff7f793          	andi	a5,a5,255
  20247c:	0140006f          	j	202490 <_vsnprintf+0x1c8>
  202480:	fa042783          	lw	a5,-96(s0)
  202484:	0ff7f793          	andi	a5,a5,255
  202488:	0577879b          	addiw	a5,a5,87
  20248c:	0ff7f793          	andi	a5,a5,255
  202490:	f9843683          	ld	a3,-104(s0)
  202494:	fe043703          	ld	a4,-32(s0)
  202498:	00e68733          	add	a4,a3,a4
  20249c:	00f70023          	sb	a5,0(a4)
					}
					pos++;
  2024a0:	fe043783          	ld	a5,-32(s0)
  2024a4:	00178793          	addi	a5,a5,1
  2024a8:	fef43023          	sd	a5,-32(s0)
				for(int i = hexdigits; i >= 0; i--) {
  2024ac:	fdc42783          	lw	a5,-36(s0)
  2024b0:	fff7879b          	addiw	a5,a5,-1
  2024b4:	fcf42e23          	sw	a5,-36(s0)
  2024b8:	fdc42783          	lw	a5,-36(s0)
  2024bc:	0007879b          	sext.w	a5,a5
  2024c0:	f607d4e3          	bgez	a5,202428 <_vsnprintf+0x160>
				}
				longarg = 0;
  2024c4:	fe042423          	sw	zero,-24(s0)
				format = 0;
  2024c8:	fe042623          	sw	zero,-20(s0)
				break;
  2024cc:	27c0006f          	j	202748 <_vsnprintf+0x480>
			}
			case 'd': {
				long num = longarg ? va_arg(vl, long) : va_arg(vl, int);
  2024d0:	fe842783          	lw	a5,-24(s0)
  2024d4:	0007879b          	sext.w	a5,a5
  2024d8:	00078c63          	beqz	a5,2024f0 <_vsnprintf+0x228>
  2024dc:	f8043783          	ld	a5,-128(s0)
  2024e0:	00878713          	addi	a4,a5,8
  2024e4:	f8e43023          	sd	a4,-128(s0)
  2024e8:	0007b783          	ld	a5,0(a5)
  2024ec:	0140006f          	j	202500 <_vsnprintf+0x238>
  2024f0:	f8043783          	ld	a5,-128(s0)
  2024f4:	00878713          	addi	a4,a5,8
  2024f8:	f8e43023          	sd	a4,-128(s0)
  2024fc:	0007a783          	lw	a5,0(a5)
  202500:	fcf43823          	sd	a5,-48(s0)
				if (num < 0) {
  202504:	fd043783          	ld	a5,-48(s0)
  202508:	0407d263          	bgez	a5,20254c <_vsnprintf+0x284>
					num = -num;
  20250c:	fd043783          	ld	a5,-48(s0)
  202510:	40f007b3          	neg	a5,a5
  202514:	fcf43823          	sd	a5,-48(s0)
					if (out && pos < n) {
  202518:	f9843783          	ld	a5,-104(s0)
  20251c:	02078263          	beqz	a5,202540 <_vsnprintf+0x278>
  202520:	fe043703          	ld	a4,-32(s0)
  202524:	f9043783          	ld	a5,-112(s0)
  202528:	00f77c63          	bgeu	a4,a5,202540 <_vsnprintf+0x278>
						out[pos] = '-';
  20252c:	f9843703          	ld	a4,-104(s0)
  202530:	fe043783          	ld	a5,-32(s0)
  202534:	00f707b3          	add	a5,a4,a5
  202538:	02d00713          	li	a4,45
  20253c:	00e78023          	sb	a4,0(a5)
					}
					pos++;
  202540:	fe043783          	ld	a5,-32(s0)
  202544:	00178793          	addi	a5,a5,1
  202548:	fef43023          	sd	a5,-32(s0)
				}
				long digits = 1;
  20254c:	00100793          	li	a5,1
  202550:	fcf43423          	sd	a5,-56(s0)
				for (long nn = num; nn /= 10; digits++);
  202554:	fd043783          	ld	a5,-48(s0)
  202558:	fcf43023          	sd	a5,-64(s0)
  20255c:	0100006f          	j	20256c <_vsnprintf+0x2a4>
  202560:	fc843783          	ld	a5,-56(s0)
  202564:	00178793          	addi	a5,a5,1
  202568:	fcf43423          	sd	a5,-56(s0)
  20256c:	fc043503          	ld	a0,-64(s0)
  202570:	d1dff0ef          	jal	ra,20228c <div10>
  202574:	fca43023          	sd	a0,-64(s0)
  202578:	fc043783          	ld	a5,-64(s0)
  20257c:	fe0792e3          	bnez	a5,202560 <_vsnprintf+0x298>
				for (int i = digits-1; i >= 0; i--) {
  202580:	fc843783          	ld	a5,-56(s0)
  202584:	0007879b          	sext.w	a5,a5
  202588:	fff7879b          	addiw	a5,a5,-1
  20258c:	0007879b          	sext.w	a5,a5
  202590:	faf42e23          	sw	a5,-68(s0)
  202594:	0680006f          	j	2025fc <_vsnprintf+0x334>
					if (out && pos + i < n) {
  202598:	f9843783          	ld	a5,-104(s0)
  20259c:	04078463          	beqz	a5,2025e4 <_vsnprintf+0x31c>
  2025a0:	fbc42703          	lw	a4,-68(s0)
  2025a4:	fe043783          	ld	a5,-32(s0)
  2025a8:	00f707b3          	add	a5,a4,a5
  2025ac:	f9043703          	ld	a4,-112(s0)
  2025b0:	02e7fa63          	bgeu	a5,a4,2025e4 <_vsnprintf+0x31c>
						out[pos + i] = '0' + num % 10;
  2025b4:	fd043503          	ld	a0,-48(s0)
  2025b8:	c45ff0ef          	jal	ra,2021fc <mod10>
  2025bc:	00050793          	mv	a5,a0
  2025c0:	0ff7f713          	andi	a4,a5,255
  2025c4:	fbc42683          	lw	a3,-68(s0)
  2025c8:	fe043783          	ld	a5,-32(s0)
  2025cc:	00f687b3          	add	a5,a3,a5
  2025d0:	f9843683          	ld	a3,-104(s0)
  2025d4:	00f687b3          	add	a5,a3,a5
  2025d8:	0307071b          	addiw	a4,a4,48
  2025dc:	0ff77713          	andi	a4,a4,255
  2025e0:	00e78023          	sb	a4,0(a5)
					}
					num /= 10;
  2025e4:	fd043503          	ld	a0,-48(s0)
  2025e8:	ca5ff0ef          	jal	ra,20228c <div10>
  2025ec:	fca43823          	sd	a0,-48(s0)
				for (int i = digits-1; i >= 0; i--) {
  2025f0:	fbc42783          	lw	a5,-68(s0)
  2025f4:	fff7879b          	addiw	a5,a5,-1
  2025f8:	faf42e23          	sw	a5,-68(s0)
  2025fc:	fbc42783          	lw	a5,-68(s0)
  202600:	0007879b          	sext.w	a5,a5
  202604:	f807dae3          	bgez	a5,202598 <_vsnprintf+0x2d0>
				}
				pos += digits;
  202608:	fc843783          	ld	a5,-56(s0)
  20260c:	fe043703          	ld	a4,-32(s0)
  202610:	00f707b3          	add	a5,a4,a5
  202614:	fef43023          	sd	a5,-32(s0)
				longarg = 0;
  202618:	fe042423          	sw	zero,-24(s0)
				format = 0;
  20261c:	fe042623          	sw	zero,-20(s0)
				break;
  202620:	1280006f          	j	202748 <_vsnprintf+0x480>
			}
			case 's': {
				const char* s2 = va_arg(vl, const char*);
  202624:	f8043783          	ld	a5,-128(s0)
  202628:	00878713          	addi	a4,a5,8
  20262c:	f8e43023          	sd	a4,-128(s0)
  202630:	0007b783          	ld	a5,0(a5)
  202634:	faf43823          	sd	a5,-80(s0)
				while (*s2) {
  202638:	0480006f          	j	202680 <_vsnprintf+0x3b8>
					if (out && pos < n) {
  20263c:	f9843783          	ld	a5,-104(s0)
  202640:	02078463          	beqz	a5,202668 <_vsnprintf+0x3a0>
  202644:	fe043703          	ld	a4,-32(s0)
  202648:	f9043783          	ld	a5,-112(s0)
  20264c:	00f77e63          	bgeu	a4,a5,202668 <_vsnprintf+0x3a0>
						out[pos] = *s2;
  202650:	f9843703          	ld	a4,-104(s0)
  202654:	fe043783          	ld	a5,-32(s0)
  202658:	00f707b3          	add	a5,a4,a5
  20265c:	fb043703          	ld	a4,-80(s0)
  202660:	00074703          	lbu	a4,0(a4)
  202664:	00e78023          	sb	a4,0(a5)
					}
					pos++;
  202668:	fe043783          	ld	a5,-32(s0)
  20266c:	00178793          	addi	a5,a5,1
  202670:	fef43023          	sd	a5,-32(s0)
					s2++;
  202674:	fb043783          	ld	a5,-80(s0)
  202678:	00178793          	addi	a5,a5,1
  20267c:	faf43823          	sd	a5,-80(s0)
				while (*s2) {
  202680:	fb043783          	ld	a5,-80(s0)
  202684:	0007c783          	lbu	a5,0(a5)
  202688:	fa079ae3          	bnez	a5,20263c <_vsnprintf+0x374>
				}
				longarg = 0;
  20268c:	fe042423          	sw	zero,-24(s0)
				format = 0;
  202690:	fe042623          	sw	zero,-20(s0)
				break;
  202694:	0b40006f          	j	202748 <_vsnprintf+0x480>
			}
			case 'c': {
				if (out && pos < n) {
  202698:	f9843783          	ld	a5,-104(s0)
  20269c:	02078a63          	beqz	a5,2026d0 <_vsnprintf+0x408>
  2026a0:	fe043703          	ld	a4,-32(s0)
  2026a4:	f9043783          	ld	a5,-112(s0)
  2026a8:	02f77463          	bgeu	a4,a5,2026d0 <_vsnprintf+0x408>
					out[pos] = (char)va_arg(vl,int);
  2026ac:	f8043783          	ld	a5,-128(s0)
  2026b0:	00878713          	addi	a4,a5,8
  2026b4:	f8e43023          	sd	a4,-128(s0)
  2026b8:	0007a683          	lw	a3,0(a5)
  2026bc:	f9843703          	ld	a4,-104(s0)
  2026c0:	fe043783          	ld	a5,-32(s0)
  2026c4:	00f707b3          	add	a5,a4,a5
  2026c8:	0ff6f713          	andi	a4,a3,255
  2026cc:	00e78023          	sb	a4,0(a5)
				}
				pos++;
  2026d0:	fe043783          	ld	a5,-32(s0)
  2026d4:	00178793          	addi	a5,a5,1
  2026d8:	fef43023          	sd	a5,-32(s0)
				longarg = 0;
  2026dc:	fe042423          	sw	zero,-24(s0)
				format = 0;
  2026e0:	fe042623          	sw	zero,-20(s0)
				break;
  2026e4:	0640006f          	j	202748 <_vsnprintf+0x480>
			}
			default:
				break;
			}
		} else if (*s == '%') {
  2026e8:	f8843783          	ld	a5,-120(s0)
  2026ec:	0007c783          	lbu	a5,0(a5)
  2026f0:	00078713          	mv	a4,a5
  2026f4:	02500793          	li	a5,37
  2026f8:	00f71863          	bne	a4,a5,202708 <_vsnprintf+0x440>
			format = 1;
  2026fc:	00100793          	li	a5,1
  202700:	fef42623          	sw	a5,-20(s0)
  202704:	0440006f          	j	202748 <_vsnprintf+0x480>
		} else {
			if (out && pos < n) {
  202708:	f9843783          	ld	a5,-104(s0)
  20270c:	02078463          	beqz	a5,202734 <_vsnprintf+0x46c>
  202710:	fe043703          	ld	a4,-32(s0)
  202714:	f9043783          	ld	a5,-112(s0)
  202718:	00f77e63          	bgeu	a4,a5,202734 <_vsnprintf+0x46c>
				out[pos] = *s;
  20271c:	f9843703          	ld	a4,-104(s0)
  202720:	fe043783          	ld	a5,-32(s0)
  202724:	00f707b3          	add	a5,a4,a5
  202728:	f8843703          	ld	a4,-120(s0)
  20272c:	00074703          	lbu	a4,0(a4)
  202730:	00e78023          	sb	a4,0(a5)
			}
			pos++;
  202734:	fe043783          	ld	a5,-32(s0)
  202738:	00178793          	addi	a5,a5,1
  20273c:	fef43023          	sd	a5,-32(s0)
  202740:	0080006f          	j	202748 <_vsnprintf+0x480>
				break;
  202744:	00000013          	nop
	for (; *s; s++) {
  202748:	f8843783          	ld	a5,-120(s0)
  20274c:	00178793          	addi	a5,a5,1
  202750:	f8f43423          	sd	a5,-120(s0)
  202754:	f8843783          	ld	a5,-120(s0)
  202758:	0007c783          	lbu	a5,0(a5)
  20275c:	b8079ee3          	bnez	a5,2022f8 <_vsnprintf+0x30>
		}
    	}
	if (out && pos < n) {
  202760:	f9843783          	ld	a5,-104(s0)
  202764:	02078263          	beqz	a5,202788 <_vsnprintf+0x4c0>
  202768:	fe043703          	ld	a4,-32(s0)
  20276c:	f9043783          	ld	a5,-112(s0)
  202770:	00f77c63          	bgeu	a4,a5,202788 <_vsnprintf+0x4c0>
		out[pos] = 0;
  202774:	f9843703          	ld	a4,-104(s0)
  202778:	fe043783          	ld	a5,-32(s0)
  20277c:	00f707b3          	add	a5,a4,a5
  202780:	00078023          	sb	zero,0(a5)
  202784:	0280006f          	j	2027ac <_vsnprintf+0x4e4>
	} else if (out && n) {
  202788:	f9843783          	ld	a5,-104(s0)
  20278c:	02078063          	beqz	a5,2027ac <_vsnprintf+0x4e4>
  202790:	f9043783          	ld	a5,-112(s0)
  202794:	00078c63          	beqz	a5,2027ac <_vsnprintf+0x4e4>
		out[n-1] = 0;
  202798:	f9043783          	ld	a5,-112(s0)
  20279c:	fff78793          	addi	a5,a5,-1
  2027a0:	f9843703          	ld	a4,-104(s0)
  2027a4:	00f707b3          	add	a5,a4,a5
  2027a8:	00078023          	sb	zero,0(a5)
	}
	return pos;
  2027ac:	fe043783          	ld	a5,-32(s0)
  2027b0:	0007879b          	sext.w	a5,a5
}
  2027b4:	00078513          	mv	a0,a5
  2027b8:	07813083          	ld	ra,120(sp)
  2027bc:	07013403          	ld	s0,112(sp)
  2027c0:	08010113          	addi	sp,sp,128
  2027c4:	00008067          	ret

00000000002027c8 <_vprintf>:

static char out_buf[1000]; // buffer for _vprintf()

static int _vprintf(const char* s, va_list vl)
{
  2027c8:	fd010113          	addi	sp,sp,-48
  2027cc:	02113423          	sd	ra,40(sp)
  2027d0:	02813023          	sd	s0,32(sp)
  2027d4:	03010413          	addi	s0,sp,48
  2027d8:	fca43c23          	sd	a0,-40(s0)
  2027dc:	fcb43823          	sd	a1,-48(s0)
	int res = _vsnprintf(NULL, -1, s, vl);
  2027e0:	fd043683          	ld	a3,-48(s0)
  2027e4:	fd843603          	ld	a2,-40(s0)
  2027e8:	fff00593          	li	a1,-1
  2027ec:	00000513          	li	a0,0
  2027f0:	ad9ff0ef          	jal	ra,2022c8 <_vsnprintf>
  2027f4:	00050793          	mv	a5,a0
  2027f8:	fef42623          	sw	a5,-20(s0)
	if (res+1 >= sizeof(out_buf)) {
  2027fc:	fec42783          	lw	a5,-20(s0)
  202800:	0017879b          	addiw	a5,a5,1
  202804:	0007879b          	sext.w	a5,a5
  202808:	0007879b          	sext.w	a5,a5
  20280c:	00078713          	mv	a4,a5
  202810:	3e700793          	li	a5,999
  202814:	00e7fa63          	bgeu	a5,a4,202828 <_vprintf+0x60>
		uart_puts("error: output string size overflow\n\r");
  202818:	00003517          	auipc	a0,0x3
  20281c:	56850513          	addi	a0,a0,1384 # 205d80 <BSS_END+0x60>
  202820:	2b5000ef          	jal	ra,2032d4 <uart_puts>
		while(1) {}
  202824:	0000006f          	j	202824 <_vprintf+0x5c>
	}
	_vsnprintf(out_buf, res + 1, s, vl);
  202828:	fec42783          	lw	a5,-20(s0)
  20282c:	0017879b          	addiw	a5,a5,1
  202830:	0007879b          	sext.w	a5,a5
  202834:	fd043683          	ld	a3,-48(s0)
  202838:	fd843603          	ld	a2,-40(s0)
  20283c:	00078593          	mv	a1,a5
  202840:	00005517          	auipc	a0,0x5
  202844:	83050513          	addi	a0,a0,-2000 # 207070 <_bss_start>
  202848:	a81ff0ef          	jal	ra,2022c8 <_vsnprintf>
	uart_puts(out_buf);
  20284c:	00005517          	auipc	a0,0x5
  202850:	82450513          	addi	a0,a0,-2012 # 207070 <_bss_start>
  202854:	281000ef          	jal	ra,2032d4 <uart_puts>
	return res;
  202858:	fec42783          	lw	a5,-20(s0)
}
  20285c:	00078513          	mv	a0,a5
  202860:	02813083          	ld	ra,40(sp)
  202864:	02013403          	ld	s0,32(sp)
  202868:	03010113          	addi	sp,sp,48
  20286c:	00008067          	ret

0000000000202870 <printf>:

int printf(const char* s, ...)
{
  202870:	f9010113          	addi	sp,sp,-112
  202874:	02113423          	sd	ra,40(sp)
  202878:	02813023          	sd	s0,32(sp)
  20287c:	03010413          	addi	s0,sp,48
  202880:	fca43c23          	sd	a0,-40(s0)
  202884:	00b43423          	sd	a1,8(s0)
  202888:	00c43823          	sd	a2,16(s0)
  20288c:	00d43c23          	sd	a3,24(s0)
  202890:	02e43023          	sd	a4,32(s0)
  202894:	02f43423          	sd	a5,40(s0)
  202898:	03043823          	sd	a6,48(s0)
  20289c:	03143c23          	sd	a7,56(s0)
	int res = 0;
  2028a0:	fe042623          	sw	zero,-20(s0)
	va_list vl;
	va_start(vl, s);
  2028a4:	04040793          	addi	a5,s0,64
  2028a8:	fc878793          	addi	a5,a5,-56
  2028ac:	fef43023          	sd	a5,-32(s0)
	res = _vprintf(s, vl);
  2028b0:	fe043783          	ld	a5,-32(s0)
  2028b4:	00078593          	mv	a1,a5
  2028b8:	fd843503          	ld	a0,-40(s0)
  2028bc:	f0dff0ef          	jal	ra,2027c8 <_vprintf>
  2028c0:	00050793          	mv	a5,a0
  2028c4:	fef42623          	sw	a5,-20(s0)
	va_end(vl);
	return res;
  2028c8:	fec42783          	lw	a5,-20(s0)
}
  2028cc:	00078513          	mv	a0,a5
  2028d0:	02813083          	ld	ra,40(sp)
  2028d4:	02013403          	ld	s0,32(sp)
  2028d8:	07010113          	addi	sp,sp,112
  2028dc:	00008067          	ret

00000000002028e0 <panic>:

void panic(char *s)
{
  2028e0:	fe010113          	addi	sp,sp,-32
  2028e4:	00113c23          	sd	ra,24(sp)
  2028e8:	00813823          	sd	s0,16(sp)
  2028ec:	02010413          	addi	s0,sp,32
  2028f0:	fea43423          	sd	a0,-24(s0)
	printf("panic: ");
  2028f4:	00003517          	auipc	a0,0x3
  2028f8:	4b450513          	addi	a0,a0,1204 # 205da8 <BSS_END+0x88>
  2028fc:	f75ff0ef          	jal	ra,202870 <printf>
	printf(s);
  202900:	fe843503          	ld	a0,-24(s0)
  202904:	f6dff0ef          	jal	ra,202870 <printf>
	printf("\n\r");
  202908:	00003517          	auipc	a0,0x3
  20290c:	4a850513          	addi	a0,a0,1192 # 205db0 <BSS_END+0x90>
  202910:	f61ff0ef          	jal	ra,202870 <printf>
	while(1){};
  202914:	0000006f          	j	202914 <panic+0x34>

0000000000202918 <w_mscratch>:
#include "types.h"

/* 
 *  register operation of multi-task.
 */
static void w_mscratch(reg_t x){
  202918:	fe010113          	addi	sp,sp,-32
  20291c:	00813c23          	sd	s0,24(sp)
  202920:	02010413          	addi	s0,sp,32
  202924:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  202928:	fe843783          	ld	a5,-24(s0)
  20292c:	34079073          	csrw	mscratch,a5
}
  202930:	00000013          	nop
  202934:	01813403          	ld	s0,24(sp)
  202938:	02010113          	addi	sp,sp,32
  20293c:	00008067          	ret

0000000000202940 <r_mscratch>:

static reg_t r_mscratch(){
  202940:	fe010113          	addi	sp,sp,-32
  202944:	00813c23          	sd	s0,24(sp)
  202948:	02010413          	addi	s0,sp,32
	reg_t ret;
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  20294c:	340027f3          	csrr	a5,mscratch
  202950:	fef43423          	sd	a5,-24(s0)
	return ret;
  202954:	fe843783          	ld	a5,-24(s0)
}
  202958:	00078513          	mv	a0,a5
  20295c:	01813403          	ld	s0,24(sp)
  202960:	02010113          	addi	sp,sp,32
  202964:	00008067          	ret

0000000000202968 <get_time>:
void timer_init();

void timer_handler();


static uint64_t get_time(){
  202968:	ff010113          	addi	sp,sp,-16
  20296c:	00813423          	sd	s0,8(sp)
  202970:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  202974:	00005797          	auipc	a5,0x5
  202978:	ae478793          	addi	a5,a5,-1308 # 207458 <_tick>
  20297c:	0007b703          	ld	a4,0(a5)
  202980:	03c00793          	li	a5,60
  202984:	02f757b3          	divu	a5,a4,a5
}
  202988:	00078513          	mv	a0,a5
  20298c:	00813403          	ld	s0,8(sp)
  202990:	01010113          	addi	sp,sp,16
  202994:	00008067          	ret

0000000000202998 <get_time_str>:

static void get_time_str(char* time){
  202998:	fc010113          	addi	sp,sp,-64
  20299c:	02813c23          	sd	s0,56(sp)
  2029a0:	04010413          	addi	s0,sp,64
  2029a4:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  2029a8:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  2029ac:	00005797          	auipc	a5,0x5
  2029b0:	aac78793          	addi	a5,a5,-1364 # 207458 <_tick>
  2029b4:	0007b703          	ld	a4,0(a5)
  2029b8:	03c00793          	li	a5,60
  2029bc:	02f757b3          	divu	a5,a4,a5
  2029c0:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  2029c4:	fe043703          	ld	a4,-32(s0)
  2029c8:	000017b7          	lui	a5,0x1
  2029cc:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2029d0:	02f757b3          	divu	a5,a4,a5
  2029d4:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  2029d8:	fdf44703          	lbu	a4,-33(s0)
  2029dc:	06400793          	li	a5,100
  2029e0:	02f777bb          	remuw	a5,a4,a5
  2029e4:	0ff7f793          	andi	a5,a5,255
  2029e8:	00078713          	mv	a4,a5
  2029ec:	00a00793          	li	a5,10
  2029f0:	02f757bb          	divuw	a5,a4,a5
  2029f4:	0ff7f793          	andi	a5,a5,255
  2029f8:	0307879b          	addiw	a5,a5,48
  2029fc:	0ff7f713          	andi	a4,a5,255
  202a00:	fc843783          	ld	a5,-56(s0)
  202a04:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  202a08:	fdf44703          	lbu	a4,-33(s0)
  202a0c:	00a00793          	li	a5,10
  202a10:	02f777bb          	remuw	a5,a4,a5
  202a14:	0ff7f713          	andi	a4,a5,255
  202a18:	fc843783          	ld	a5,-56(s0)
  202a1c:	00178793          	addi	a5,a5,1
  202a20:	0307071b          	addiw	a4,a4,48
  202a24:	0ff77713          	andi	a4,a4,255
  202a28:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  202a2c:	fc843783          	ld	a5,-56(s0)
  202a30:	00278793          	addi	a5,a5,2
  202a34:	03a00713          	li	a4,58
  202a38:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  202a3c:	fe043703          	ld	a4,-32(s0)
  202a40:	000017b7          	lui	a5,0x1
  202a44:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  202a48:	02f77733          	remu	a4,a4,a5
  202a4c:	03c00793          	li	a5,60
  202a50:	02f757b3          	divu	a5,a4,a5
  202a54:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  202a58:	fdf44703          	lbu	a4,-33(s0)
  202a5c:	00a00793          	li	a5,10
  202a60:	02f757bb          	divuw	a5,a4,a5
  202a64:	0ff7f713          	andi	a4,a5,255
  202a68:	fc843783          	ld	a5,-56(s0)
  202a6c:	00378793          	addi	a5,a5,3
  202a70:	0307071b          	addiw	a4,a4,48
  202a74:	0ff77713          	andi	a4,a4,255
  202a78:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  202a7c:	fdf44703          	lbu	a4,-33(s0)
  202a80:	00a00793          	li	a5,10
  202a84:	02f777bb          	remuw	a5,a4,a5
  202a88:	0ff7f713          	andi	a4,a5,255
  202a8c:	fc843783          	ld	a5,-56(s0)
  202a90:	00478793          	addi	a5,a5,4
  202a94:	0307071b          	addiw	a4,a4,48
  202a98:	0ff77713          	andi	a4,a4,255
  202a9c:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  202aa0:	fc843783          	ld	a5,-56(s0)
  202aa4:	00578793          	addi	a5,a5,5
  202aa8:	03a00713          	li	a4,58
  202aac:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  202ab0:	fe043703          	ld	a4,-32(s0)
  202ab4:	03c00793          	li	a5,60
  202ab8:	02f777b3          	remu	a5,a4,a5
  202abc:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  202ac0:	fdf44703          	lbu	a4,-33(s0)
  202ac4:	00a00793          	li	a5,10
  202ac8:	02f757bb          	divuw	a5,a4,a5
  202acc:	0ff7f713          	andi	a4,a5,255
  202ad0:	fc843783          	ld	a5,-56(s0)
  202ad4:	00678793          	addi	a5,a5,6
  202ad8:	0307071b          	addiw	a4,a4,48
  202adc:	0ff77713          	andi	a4,a4,255
  202ae0:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  202ae4:	fdf44703          	lbu	a4,-33(s0)
  202ae8:	00a00793          	li	a5,10
  202aec:	02f777bb          	remuw	a5,a4,a5
  202af0:	0ff7f713          	andi	a4,a5,255
  202af4:	fc843783          	ld	a5,-56(s0)
  202af8:	00778793          	addi	a5,a5,7
  202afc:	0307071b          	addiw	a4,a4,48
  202b00:	0ff77713          	andi	a4,a4,255
  202b04:	00e78023          	sb	a4,0(a5)

}
  202b08:	00000013          	nop
  202b0c:	03813403          	ld	s0,56(sp)
  202b10:	04010113          	addi	sp,sp,64
  202b14:	00008067          	ret

0000000000202b18 <user_task1>:
#include "user.h"

#define DELAY 1000

void user_task1(void* param)
{
  202b18:	fd010113          	addi	sp,sp,-48
  202b1c:	02113423          	sd	ra,40(sp)
  202b20:	02813023          	sd	s0,32(sp)
  202b24:	03010413          	addi	s0,sp,48
  202b28:	fca43c23          	sd	a0,-40(s0)
	printf("\033[32mTask 1: Created!\033[0m\n\r");
  202b2c:	00003517          	auipc	a0,0x3
  202b30:	28c50513          	addi	a0,a0,652 # 205db8 <BSS_END+0x98>
  202b34:	d3dff0ef          	jal	ra,202870 <printf>
	while (1) {
		reg_t mytime;
		get_MTIME(mytime);
  202b38:	c01027f3          	rdtime	a5
  202b3c:	fef43423          	sd	a5,-24(s0)
		printf("\033[32mTask 1: Running...\033[0m\n\r");
  202b40:	00003517          	auipc	a0,0x3
  202b44:	29850513          	addi	a0,a0,664 # 205dd8 <BSS_END+0xb8>
  202b48:	d29ff0ef          	jal	ra,202870 <printf>
		printf("\033[32mCurrent time is:%d\033[0m\n\r", mytime);
  202b4c:	fe843583          	ld	a1,-24(s0)
  202b50:	00003517          	auipc	a0,0x3
  202b54:	2a850513          	addi	a0,a0,680 # 205df8 <BSS_END+0xd8>
  202b58:	d19ff0ef          	jal	ra,202870 <printf>
		task_delay(DELAY);
  202b5c:	3e800513          	li	a0,1000
  202b60:	788010ef          	jal	ra,2042e8 <task_delay>
	while (1) {
  202b64:	fd5ff06f          	j	202b38 <user_task1+0x20>

0000000000202b68 <user_task2>:
		#endif
	}
}

void user_task2(void* param)
{
  202b68:	fe010113          	addi	sp,sp,-32
  202b6c:	00113c23          	sd	ra,24(sp)
  202b70:	00813823          	sd	s0,16(sp)
  202b74:	02010413          	addi	s0,sp,32
  202b78:	fea43423          	sd	a0,-24(s0)
	printf("\033[32mTask 2: Created!\033[0m\n\r");
  202b7c:	00003517          	auipc	a0,0x3
  202b80:	29c50513          	addi	a0,a0,668 # 205e18 <BSS_END+0xf8>
  202b84:	cedff0ef          	jal	ra,202870 <printf>
	while (1) {
		printf("\033[32mTask 2: Running...\033[0m\n\r");
  202b88:	00003517          	auipc	a0,0x3
  202b8c:	2b050513          	addi	a0,a0,688 # 205e38 <BSS_END+0x118>
  202b90:	ce1ff0ef          	jal	ra,202870 <printf>
		printf("\033[32mMy cmp is:%p\033[0m\n\r", *(uint64_t*)CLINT_MTIMECMP(0));
  202b94:	03ff77b7          	lui	a5,0x3ff7
  202b98:	00178793          	addi	a5,a5,1 # 3ff7001 <_bss_end+0x3debf51>
  202b9c:	00e79793          	slli	a5,a5,0xe
  202ba0:	0007b783          	ld	a5,0(a5)
  202ba4:	00078593          	mv	a1,a5
  202ba8:	00003517          	auipc	a0,0x3
  202bac:	2b050513          	addi	a0,a0,688 # 205e58 <BSS_END+0x138>
  202bb0:	cc1ff0ef          	jal	ra,202870 <printf>
		task_delay(DELAY);
  202bb4:	3e800513          	li	a0,1000
  202bb8:	730010ef          	jal	ra,2042e8 <task_delay>
		printf("\033[32mTask 2: Running...\033[0m\n\r");
  202bbc:	fcdff06f          	j	202b88 <user_task2+0x20>

0000000000202bc0 <user_task3>:
		#endif
	}
}

void user_task3(void* param)
{
  202bc0:	fe010113          	addi	sp,sp,-32
  202bc4:	00113c23          	sd	ra,24(sp)
  202bc8:	00813823          	sd	s0,16(sp)
  202bcc:	02010413          	addi	s0,sp,32
  202bd0:	fea43423          	sd	a0,-24(s0)
	printf("\033[32mTask 3: Created!\033[0m\n\r");
  202bd4:	00003517          	auipc	a0,0x3
  202bd8:	29c50513          	addi	a0,a0,668 # 205e70 <BSS_END+0x150>
  202bdc:	c95ff0ef          	jal	ra,202870 <printf>
	printf("\033[32mTask 3: Running...\033[0m\n\r");
  202be0:	00003517          	auipc	a0,0x3
  202be4:	2b050513          	addi	a0,a0,688 # 205e90 <BSS_END+0x170>
  202be8:	c89ff0ef          	jal	ra,202870 <printf>
	printf("\033[32mMy output is:%p\033[0m\n\r", param);
  202bec:	fe843583          	ld	a1,-24(s0)
  202bf0:	00003517          	auipc	a0,0x3
  202bf4:	2c050513          	addi	a0,a0,704 # 205eb0 <BSS_END+0x190>
  202bf8:	c79ff0ef          	jal	ra,202870 <printf>
	task_delay(DELAY);
  202bfc:	3e800513          	li	a0,1000
  202c00:	6e8010ef          	jal	ra,2042e8 <task_delay>
	#endif
	#ifndef MYPRINT
	print_taskkilled();
	delete_taskkilled();
	#endif
	printf("\033[31mTask 3: Killed!\033[0m\n\r");
  202c04:	00003517          	auipc	a0,0x3
  202c08:	2cc50513          	addi	a0,a0,716 # 205ed0 <BSS_END+0x1b0>
  202c0c:	c65ff0ef          	jal	ra,202870 <printf>
	task_exit();
  202c10:	430010ef          	jal	ra,204040 <task_exit>
}
  202c14:	00000013          	nop
  202c18:	01813083          	ld	ra,24(sp)
  202c1c:	01013403          	ld	s0,16(sp)
  202c20:	02010113          	addi	sp,sp,32
  202c24:	00008067          	ret

0000000000202c28 <os_main>:

/* NOTICE: DON'T LOOP INFINITELY IN main() */
void os_main(void)
{
  202c28:	ff010113          	addi	sp,sp,-16
  202c2c:	00113423          	sd	ra,8(sp)
  202c30:	00813023          	sd	s0,0(sp)
  202c34:	01010413          	addi	s0,sp,16
	task_create(user_task1, (void*)0x123456789abcdef, 2);
  202c38:	00003797          	auipc	a5,0x3
  202c3c:	2b878793          	addi	a5,a5,696 # 205ef0 <BSS_END+0x1d0>
  202c40:	0007b783          	ld	a5,0(a5)
  202c44:	00200613          	li	a2,2
  202c48:	00078593          	mv	a1,a5
  202c4c:	00000517          	auipc	a0,0x0
  202c50:	ecc50513          	addi	a0,a0,-308 # 202b18 <user_task1>
  202c54:	444010ef          	jal	ra,204098 <task_create>
	task_create(user_task2, (void*)0xfedcba9876543210, 2);
  202c58:	00003797          	auipc	a5,0x3
  202c5c:	2a078793          	addi	a5,a5,672 # 205ef8 <BSS_END+0x1d8>
  202c60:	0007b783          	ld	a5,0(a5)
  202c64:	00200613          	li	a2,2
  202c68:	00078593          	mv	a1,a5
  202c6c:	00000517          	auipc	a0,0x0
  202c70:	efc50513          	addi	a0,a0,-260 # 202b68 <user_task2>
  202c74:	424010ef          	jal	ra,204098 <task_create>
	task_create(user_task3, (void*)0xdeadbeefbeefdead, 1);
  202c78:	00003797          	auipc	a5,0x3
  202c7c:	28878793          	addi	a5,a5,648 # 205f00 <BSS_END+0x1e0>
  202c80:	0007b783          	ld	a5,0(a5)
  202c84:	00100613          	li	a2,1
  202c88:	00078593          	mv	a1,a5
  202c8c:	00000517          	auipc	a0,0x0
  202c90:	f3450513          	addi	a0,a0,-204 # 202bc0 <user_task3>
  202c94:	404010ef          	jal	ra,204098 <task_create>
}
  202c98:	00000013          	nop
  202c9c:	00813083          	ld	ra,8(sp)
  202ca0:	00013403          	ld	s0,0(sp)
  202ca4:	01010113          	addi	sp,sp,16
  202ca8:	00008067          	ret

0000000000202cac <w_mscratch>:
static void w_mscratch(reg_t x){
  202cac:	fe010113          	addi	sp,sp,-32
  202cb0:	00813c23          	sd	s0,24(sp)
  202cb4:	02010413          	addi	s0,sp,32
  202cb8:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  202cbc:	fe843783          	ld	a5,-24(s0)
  202cc0:	34079073          	csrw	mscratch,a5
}
  202cc4:	00000013          	nop
  202cc8:	01813403          	ld	s0,24(sp)
  202ccc:	02010113          	addi	sp,sp,32
  202cd0:	00008067          	ret

0000000000202cd4 <r_mscratch>:
static reg_t r_mscratch(){
  202cd4:	fe010113          	addi	sp,sp,-32
  202cd8:	00813c23          	sd	s0,24(sp)
  202cdc:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  202ce0:	340027f3          	csrr	a5,mscratch
  202ce4:	fef43423          	sd	a5,-24(s0)
	return ret;
  202ce8:	fe843783          	ld	a5,-24(s0)
}
  202cec:	00078513          	mv	a0,a5
  202cf0:	01813403          	ld	s0,24(sp)
  202cf4:	02010113          	addi	sp,sp,32
  202cf8:	00008067          	ret

0000000000202cfc <r_mtval>:
static inline reg_t r_mepc(){
	reg_t ret;
	asm volatile("csrr %0, mepc" : "=r" (ret));
	return ret;
}
static inline reg_t r_mtval(){
  202cfc:	fe010113          	addi	sp,sp,-32
  202d00:	00813c23          	sd	s0,24(sp)
  202d04:	02010413          	addi	s0,sp,32
	reg_t ret;
	asm volatile("csrr %0, mtval" : "=r" (ret));
  202d08:	343027f3          	csrr	a5,mtval
  202d0c:	fef43423          	sd	a5,-24(s0)
	return ret;
  202d10:	fe843783          	ld	a5,-24(s0)
}
  202d14:	00078513          	mv	a0,a5
  202d18:	01813403          	ld	s0,24(sp)
  202d1c:	02010113          	addi	sp,sp,32
  202d20:	00008067          	ret

0000000000202d24 <w_mtvec>:
static inline reg_t r_mtvec(){
	reg_t ret;
	asm volatile("csrr  %0, mtvec" :  "=r" (ret):);
	return ret;
}
static inline void w_mtvec(reg_t x){
  202d24:	fe010113          	addi	sp,sp,-32
  202d28:	00813c23          	sd	s0,24(sp)
  202d2c:	02010413          	addi	s0,sp,32
  202d30:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw   mtvec, %0" :  :"r" (x):);
  202d34:	fe843783          	ld	a5,-24(s0)
  202d38:	30579073          	csrw	mtvec,a5
}
  202d3c:	00000013          	nop
  202d40:	01813403          	ld	s0,24(sp)
  202d44:	02010113          	addi	sp,sp,32
  202d48:	00008067          	ret

0000000000202d4c <get_time>:
static uint64_t get_time(){
  202d4c:	ff010113          	addi	sp,sp,-16
  202d50:	00813423          	sd	s0,8(sp)
  202d54:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  202d58:	00004797          	auipc	a5,0x4
  202d5c:	72078793          	addi	a5,a5,1824 # 207478 <_tick>
  202d60:	0007b703          	ld	a4,0(a5)
  202d64:	03c00793          	li	a5,60
  202d68:	02f757b3          	divu	a5,a4,a5
}
  202d6c:	00078513          	mv	a0,a5
  202d70:	00813403          	ld	s0,8(sp)
  202d74:	01010113          	addi	sp,sp,16
  202d78:	00008067          	ret

0000000000202d7c <get_time_str>:
static void get_time_str(char* time){
  202d7c:	fc010113          	addi	sp,sp,-64
  202d80:	02813c23          	sd	s0,56(sp)
  202d84:	04010413          	addi	s0,sp,64
  202d88:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  202d8c:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  202d90:	00004797          	auipc	a5,0x4
  202d94:	6e878793          	addi	a5,a5,1768 # 207478 <_tick>
  202d98:	0007b703          	ld	a4,0(a5)
  202d9c:	03c00793          	li	a5,60
  202da0:	02f757b3          	divu	a5,a4,a5
  202da4:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  202da8:	fe043703          	ld	a4,-32(s0)
  202dac:	000017b7          	lui	a5,0x1
  202db0:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  202db4:	02f757b3          	divu	a5,a4,a5
  202db8:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  202dbc:	fdf44703          	lbu	a4,-33(s0)
  202dc0:	06400793          	li	a5,100
  202dc4:	02f777bb          	remuw	a5,a4,a5
  202dc8:	0ff7f793          	andi	a5,a5,255
  202dcc:	00078713          	mv	a4,a5
  202dd0:	00a00793          	li	a5,10
  202dd4:	02f757bb          	divuw	a5,a4,a5
  202dd8:	0ff7f793          	andi	a5,a5,255
  202ddc:	0307879b          	addiw	a5,a5,48
  202de0:	0ff7f713          	andi	a4,a5,255
  202de4:	fc843783          	ld	a5,-56(s0)
  202de8:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  202dec:	fdf44703          	lbu	a4,-33(s0)
  202df0:	00a00793          	li	a5,10
  202df4:	02f777bb          	remuw	a5,a4,a5
  202df8:	0ff7f713          	andi	a4,a5,255
  202dfc:	fc843783          	ld	a5,-56(s0)
  202e00:	00178793          	addi	a5,a5,1
  202e04:	0307071b          	addiw	a4,a4,48
  202e08:	0ff77713          	andi	a4,a4,255
  202e0c:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  202e10:	fc843783          	ld	a5,-56(s0)
  202e14:	00278793          	addi	a5,a5,2
  202e18:	03a00713          	li	a4,58
  202e1c:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  202e20:	fe043703          	ld	a4,-32(s0)
  202e24:	000017b7          	lui	a5,0x1
  202e28:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  202e2c:	02f77733          	remu	a4,a4,a5
  202e30:	03c00793          	li	a5,60
  202e34:	02f757b3          	divu	a5,a4,a5
  202e38:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  202e3c:	fdf44703          	lbu	a4,-33(s0)
  202e40:	00a00793          	li	a5,10
  202e44:	02f757bb          	divuw	a5,a4,a5
  202e48:	0ff7f713          	andi	a4,a5,255
  202e4c:	fc843783          	ld	a5,-56(s0)
  202e50:	00378793          	addi	a5,a5,3
  202e54:	0307071b          	addiw	a4,a4,48
  202e58:	0ff77713          	andi	a4,a4,255
  202e5c:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  202e60:	fdf44703          	lbu	a4,-33(s0)
  202e64:	00a00793          	li	a5,10
  202e68:	02f777bb          	remuw	a5,a4,a5
  202e6c:	0ff7f713          	andi	a4,a5,255
  202e70:	fc843783          	ld	a5,-56(s0)
  202e74:	00478793          	addi	a5,a5,4
  202e78:	0307071b          	addiw	a4,a4,48
  202e7c:	0ff77713          	andi	a4,a4,255
  202e80:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  202e84:	fc843783          	ld	a5,-56(s0)
  202e88:	00578793          	addi	a5,a5,5
  202e8c:	03a00713          	li	a4,58
  202e90:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  202e94:	fe043703          	ld	a4,-32(s0)
  202e98:	03c00793          	li	a5,60
  202e9c:	02f777b3          	remu	a5,a4,a5
  202ea0:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  202ea4:	fdf44703          	lbu	a4,-33(s0)
  202ea8:	00a00793          	li	a5,10
  202eac:	02f757bb          	divuw	a5,a4,a5
  202eb0:	0ff7f713          	andi	a4,a5,255
  202eb4:	fc843783          	ld	a5,-56(s0)
  202eb8:	00678793          	addi	a5,a5,6
  202ebc:	0307071b          	addiw	a4,a4,48
  202ec0:	0ff77713          	andi	a4,a4,255
  202ec4:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  202ec8:	fdf44703          	lbu	a4,-33(s0)
  202ecc:	00a00793          	li	a5,10
  202ed0:	02f777bb          	remuw	a5,a4,a5
  202ed4:	0ff7f713          	andi	a4,a5,255
  202ed8:	fc843783          	ld	a5,-56(s0)
  202edc:	00778793          	addi	a5,a5,7
  202ee0:	0307071b          	addiw	a4,a4,48
  202ee4:	0ff77713          	andi	a4,a4,255
  202ee8:	00e78023          	sb	a4,0(a5)
}
  202eec:	00000013          	nop
  202ef0:	03813403          	ld	s0,56(sp)
  202ef4:	04010113          	addi	sp,sp,64
  202ef8:	00008067          	ret

0000000000202efc <trap_init>:
#include "plic.h"
extern void trap_vector(void);

void trap_init()
{
  202efc:	ff010113          	addi	sp,sp,-16
  202f00:	00113423          	sd	ra,8(sp)
  202f04:	00813023          	sd	s0,0(sp)
  202f08:	01010413          	addi	s0,sp,16
	/*
	 * set the trap-vector base-address for machine-mode
	 */
	w_mtvec((reg_t)trap_vector);
  202f0c:	fffff797          	auipc	a5,0xfffff
  202f10:	15078793          	addi	a5,a5,336 # 20205c <trap_vector>
  202f14:	00078513          	mv	a0,a5
  202f18:	e0dff0ef          	jal	ra,202d24 <w_mtvec>
}
  202f1c:	00000013          	nop
  202f20:	00813083          	ld	ra,8(sp)
  202f24:	00013403          	ld	s0,0(sp)
  202f28:	01010113          	addi	sp,sp,16
  202f2c:	00008067          	ret

0000000000202f30 <external_interrupt_handler>:

void external_interrupt_handler()
{
  202f30:	fe010113          	addi	sp,sp,-32
  202f34:	00113c23          	sd	ra,24(sp)
  202f38:	00813823          	sd	s0,16(sp)
  202f3c:	02010413          	addi	s0,sp,32
	int irq = plic_claim();
  202f40:	0c5000ef          	jal	ra,203804 <plic_claim>
  202f44:	00050793          	mv	a5,a0
  202f48:	fef42623          	sw	a5,-20(s0)

	if (irq == UART0_IRQ){
  202f4c:	fec42783          	lw	a5,-20(s0)
  202f50:	0007871b          	sext.w	a4,a5
  202f54:	02400793          	li	a5,36
  202f58:	02f71063          	bne	a4,a5,202f78 <external_interrupt_handler+0x48>
		#ifdef MYPRINT
		printf("uart0 interrupt irq = %d\n\r", irq);
  202f5c:	fec42783          	lw	a5,-20(s0)
  202f60:	00078593          	mv	a1,a5
  202f64:	00003517          	auipc	a0,0x3
  202f68:	fa450513          	addi	a0,a0,-92 # 205f08 <BSS_END+0x1e8>
  202f6c:	905ff0ef          	jal	ra,202870 <printf>
		#endif
      	uart_isr();
  202f70:	40c000ef          	jal	ra,20337c <uart_isr>
  202f74:	0240006f          	j	202f98 <external_interrupt_handler+0x68>
	} else if (irq) {
  202f78:	fec42783          	lw	a5,-20(s0)
  202f7c:	0007879b          	sext.w	a5,a5
  202f80:	00078c63          	beqz	a5,202f98 <external_interrupt_handler+0x68>
		#ifdef MYPRINT
		printf("unexpected interrupt irq = %d\n\r", irq);
  202f84:	fec42783          	lw	a5,-20(s0)
  202f88:	00078593          	mv	a1,a5
  202f8c:	00003517          	auipc	a0,0x3
  202f90:	f9c50513          	addi	a0,a0,-100 # 205f28 <BSS_END+0x208>
  202f94:	8ddff0ef          	jal	ra,202870 <printf>
		#endif
	}
	
	if (irq) {
  202f98:	fec42783          	lw	a5,-20(s0)
  202f9c:	0007879b          	sext.w	a5,a5
  202fa0:	00078863          	beqz	a5,202fb0 <external_interrupt_handler+0x80>
		plic_complete(irq);
  202fa4:	fec42783          	lw	a5,-20(s0)
  202fa8:	00078513          	mv	a0,a5
  202fac:	0b5000ef          	jal	ra,203860 <plic_complete>
	}
}
  202fb0:	00000013          	nop
  202fb4:	01813083          	ld	ra,24(sp)
  202fb8:	01013403          	ld	s0,16(sp)
  202fbc:	02010113          	addi	sp,sp,32
  202fc0:	00008067          	ret

0000000000202fc4 <trap_handler>:

reg_t trap_handler(reg_t epc, reg_t cause)
{
  202fc4:	fd010113          	addi	sp,sp,-48
  202fc8:	02113423          	sd	ra,40(sp)
  202fcc:	02813023          	sd	s0,32(sp)
  202fd0:	03010413          	addi	s0,sp,48
  202fd4:	fca43c23          	sd	a0,-40(s0)
  202fd8:	fcb43823          	sd	a1,-48(s0)
	reg_t return_pc = epc;
  202fdc:	fd843783          	ld	a5,-40(s0)
  202fe0:	fef43423          	sd	a5,-24(s0)
	reg_t cause_code = cause & MCAUSE_MASK_ECODE;
  202fe4:	fd043703          	ld	a4,-48(s0)
  202fe8:	800007b7          	lui	a5,0x80000
  202fec:	fff7c793          	not	a5,a5
  202ff0:	00f777b3          	and	a5,a4,a5
  202ff4:	fef43023          	sd	a5,-32(s0)
	// #ifdef MYPRINT
	// printf("TRAP! cause:%p\n\r", cause);
	// #endif
	if (cause & MCAUSE_MASK_INTERRUPT) {
  202ff8:	fd043783          	ld	a5,-48(s0)
  202ffc:	0607d863          	bgez	a5,20306c <trap_handler+0xa8>
		/* Asynchronous trap - interrupt */
		switch (cause_code) {
  203000:	fe043703          	ld	a4,-32(s0)
  203004:	00700793          	li	a5,7
  203008:	02f70863          	beq	a4,a5,203038 <trap_handler+0x74>
  20300c:	fe043703          	ld	a4,-32(s0)
  203010:	00b00793          	li	a5,11
  203014:	02f70663          	beq	a4,a5,203040 <trap_handler+0x7c>
  203018:	fe043703          	ld	a4,-32(s0)
  20301c:	00300793          	li	a5,3
  203020:	02f71a63          	bne	a4,a5,203054 <trap_handler+0x90>
		case 3:
			#ifdef MYPRINT
			uart_puts("software interruption!\n\r");
  203024:	00003517          	auipc	a0,0x3
  203028:	f2450513          	addi	a0,a0,-220 # 205f48 <BSS_END+0x228>
  20302c:	2a8000ef          	jal	ra,2032d4 <uart_puts>
			#endif
			software_handler();
  203030:	79d010ef          	jal	ra,204fcc <software_handler>
			break;
  203034:	07c0006f          	j	2030b0 <trap_handler+0xec>
		case 7:
			timer_handler();
  203038:	6f1010ef          	jal	ra,204f28 <timer_handler>
			break;
  20303c:	0740006f          	j	2030b0 <trap_handler+0xec>
		case 11:
			#ifdef MYPRINT
			uart_puts("external interruption!\n\r");
  203040:	00003517          	auipc	a0,0x3
  203044:	f2850513          	addi	a0,a0,-216 # 205f68 <BSS_END+0x248>
  203048:	28c000ef          	jal	ra,2032d4 <uart_puts>
			#endif
			external_interrupt_handler();
  20304c:	ee5ff0ef          	jal	ra,202f30 <external_interrupt_handler>
			break;
  203050:	0600006f          	j	2030b0 <trap_handler+0xec>
		default:
			printf("Unknown async exception! Code = %ld\n\r", cause_code);
  203054:	fe043583          	ld	a1,-32(s0)
  203058:	00003517          	auipc	a0,0x3
  20305c:	f3050513          	addi	a0,a0,-208 # 205f88 <BSS_END+0x268>
  203060:	811ff0ef          	jal	ra,202870 <printf>
			break;
  203064:	00000013          	nop
  203068:	0480006f          	j	2030b0 <trap_handler+0xec>
		}
	} else {
		/* Synchronous trap - exception */
		printf("Sync exceptions! Code = %ld\n\r", cause_code);
  20306c:	fe043583          	ld	a1,-32(s0)
  203070:	00003517          	auipc	a0,0x3
  203074:	f4050513          	addi	a0,a0,-192 # 205fb0 <BSS_END+0x290>
  203078:	ff8ff0ef          	jal	ra,202870 <printf>
		printf("mtval = %p\n\r", r_mtval());
  20307c:	c81ff0ef          	jal	ra,202cfc <r_mtval>
  203080:	00050793          	mv	a5,a0
  203084:	00078593          	mv	a1,a5
  203088:	00003517          	auipc	a0,0x3
  20308c:	f4850513          	addi	a0,a0,-184 # 205fd0 <BSS_END+0x2b0>
  203090:	fe0ff0ef          	jal	ra,202870 <printf>
		printf("mepc = %p\n\r", epc);
  203094:	fd843583          	ld	a1,-40(s0)
  203098:	00003517          	auipc	a0,0x3
  20309c:	f4850513          	addi	a0,a0,-184 # 205fe0 <BSS_END+0x2c0>
  2030a0:	fd0ff0ef          	jal	ra,202870 <printf>
		panic("OOPS! What can I do!");
  2030a4:	00003517          	auipc	a0,0x3
  2030a8:	f4c50513          	addi	a0,a0,-180 # 205ff0 <BSS_END+0x2d0>
  2030ac:	835ff0ef          	jal	ra,2028e0 <panic>
		//return_pc += 4;
	}

	return return_pc;
  2030b0:	fe843783          	ld	a5,-24(s0)
}
  2030b4:	00078513          	mv	a0,a5
  2030b8:	02813083          	ld	ra,40(sp)
  2030bc:	02013403          	ld	s0,32(sp)
  2030c0:	03010113          	addi	sp,sp,48
  2030c4:	00008067          	ret

00000000002030c8 <trap_test>:

void trap_test()
{
  2030c8:	ff010113          	addi	sp,sp,-16
  2030cc:	00113423          	sd	ra,8(sp)
  2030d0:	00813023          	sd	s0,0(sp)
  2030d4:	01010413          	addi	s0,sp,16
	/*
	 * Synchronous exception code = 7
	 * Store/AMO access fault
	 */
	*(int *)0x12345678 = 100;
  2030d8:	123457b7          	lui	a5,0x12345
  2030dc:	67878793          	addi	a5,a5,1656 # 12345678 <_memory_end+0x2345679>
  2030e0:	06400713          	li	a4,100
  2030e4:	00e7a023          	sw	a4,0(a5)
	 * Synchronous exception code = 5
	 * Load access fault
	 */
	//int a = *(int *)0x00000000;

	uart_puts("Yeah! I'm return back from trap!\n\r");
  2030e8:	00003517          	auipc	a0,0x3
  2030ec:	f2050513          	addi	a0,a0,-224 # 206008 <BSS_END+0x2e8>
  2030f0:	1e4000ef          	jal	ra,2032d4 <uart_puts>
}
  2030f4:	00000013          	nop
  2030f8:	00813083          	ld	ra,8(sp)
  2030fc:	00013403          	ld	s0,0(sp)
  203100:	01010113          	addi	sp,sp,16
  203104:	00008067          	ret

0000000000203108 <get_uart_usr>:
//the last 4 bit means the type of uart interrupt

#define uart_read_reg(reg) (*(UART_REG(reg)))
#define uart_write_reg(reg, v) (*(UART_REG(reg)) = (v))

uint32_t get_uart_usr(void){
  203108:	ff010113          	addi	sp,sp,-16
  20310c:	00813423          	sd	s0,8(sp)
  203110:	01010413          	addi	s0,sp,16
	return uart_read_reg(USR);
  203114:	00003797          	auipc	a5,0x3
  203118:	f7c78793          	addi	a5,a5,-132 # 206090 <BSS_END+0x370>
  20311c:	0007b783          	ld	a5,0(a5)
  203120:	0007a783          	lw	a5,0(a5)
  203124:	0007879b          	sext.w	a5,a5
}
  203128:	00078513          	mv	a0,a5
  20312c:	00813403          	ld	s0,8(sp)
  203130:	01010113          	addi	sp,sp,16
  203134:	00008067          	ret

0000000000203138 <uart_init>:
void uart_init()
{
  203138:	fe010113          	addi	sp,sp,-32
  20313c:	00113c23          	sd	ra,24(sp)
  203140:	00813823          	sd	s0,16(sp)
  203144:	02010413          	addi	s0,sp,32
	/* disable interrupts. */
	uart_write_reg(IER, 0x00);
  203148:	00003797          	auipc	a5,0x3
  20314c:	f5078793          	addi	a5,a5,-176 # 206098 <BSS_END+0x378>
  203150:	0007b783          	ld	a5,0(a5)
  203154:	0007a023          	sw	zero,0(a5)
	 * We use 38.4K when 1.8432 MHZ crystal, so the corresponding value is 3.
	 * And due to the divisor register is two bytes (16 bits), so we need to
	 * split the value of 3(0x0003) into two bytes, DLL stores the low byte,
	 * DLM stores the high byte.
	 */
	uint8_t lcr = uart_read_reg(LCR);
  203158:	00003797          	auipc	a5,0x3
  20315c:	f4878793          	addi	a5,a5,-184 # 2060a0 <BSS_END+0x380>
  203160:	0007b783          	ld	a5,0(a5)
  203164:	0007a783          	lw	a5,0(a5)
  203168:	0007879b          	sext.w	a5,a5
  20316c:	fef407a3          	sb	a5,-17(s0)
	uart_write_reg(LCR, lcr | (1 << 7));
  203170:	fef44783          	lbu	a5,-17(s0)
  203174:	f807e793          	ori	a5,a5,-128
  203178:	0ff7f713          	andi	a4,a5,255
  20317c:	00003797          	auipc	a5,0x3
  203180:	f2478793          	addi	a5,a5,-220 # 2060a0 <BSS_END+0x380>
  203184:	0007b783          	ld	a5,0(a5)
  203188:	0007071b          	sext.w	a4,a4
  20318c:	00e7a023          	sw	a4,0(a5)
	uart_write_reg(DLL, 0x03);
  203190:	03ffa7b7          	lui	a5,0x3ffa
  203194:	c0578793          	addi	a5,a5,-1019 # 3ff9c05 <_bss_end+0x3deeb55>
  203198:	00e79793          	slli	a5,a5,0xe
  20319c:	00300713          	li	a4,3
  2031a0:	00e7a023          	sw	a4,0(a5)
	uart_write_reg(DLM, 0x00);
  2031a4:	00003797          	auipc	a5,0x3
  2031a8:	ef478793          	addi	a5,a5,-268 # 206098 <BSS_END+0x378>
  2031ac:	0007b783          	ld	a5,0(a5)
  2031b0:	0007a023          	sw	zero,0(a5)
	 * - number of stop bits1 bit when word length is 8 bits
	 * - no parity
	 * - no break control
	 * - disabled baud latch
	 */
	lcr = 0;
  2031b4:	fe0407a3          	sb	zero,-17(s0)
	uart_write_reg(LCR, lcr | (3 << 0));
  2031b8:	fef44783          	lbu	a5,-17(s0)
  2031bc:	0037e793          	ori	a5,a5,3
  2031c0:	0ff7f713          	andi	a4,a5,255
  2031c4:	00003797          	auipc	a5,0x3
  2031c8:	edc78793          	addi	a5,a5,-292 # 2060a0 <BSS_END+0x380>
  2031cc:	0007b783          	ld	a5,0(a5)
  2031d0:	0007071b          	sext.w	a4,a4
  2031d4:	00e7a023          	sw	a4,0(a5)

	/*
	 * enable receive interrupts.
	 */
	uint8_t ier = uart_read_reg(IER);
  2031d8:	00003797          	auipc	a5,0x3
  2031dc:	ec078793          	addi	a5,a5,-320 # 206098 <BSS_END+0x378>
  2031e0:	0007b783          	ld	a5,0(a5)
  2031e4:	0007a783          	lw	a5,0(a5)
  2031e8:	0007879b          	sext.w	a5,a5
  2031ec:	fef40723          	sb	a5,-18(s0)
	while (uart_read_reg(LCR) & (1 << 7));
  2031f0:	00000013          	nop
  2031f4:	00003797          	auipc	a5,0x3
  2031f8:	eac78793          	addi	a5,a5,-340 # 2060a0 <BSS_END+0x380>
  2031fc:	0007b783          	ld	a5,0(a5)
  203200:	0007a783          	lw	a5,0(a5)
  203204:	0007879b          	sext.w	a5,a5
  203208:	0807f793          	andi	a5,a5,128
  20320c:	0007879b          	sext.w	a5,a5
  203210:	fe0792e3          	bnez	a5,2031f4 <uart_init+0xbc>
	uart_write_reg(IER, ier | (1 << 0));
  203214:	fee44783          	lbu	a5,-18(s0)
  203218:	0017e793          	ori	a5,a5,1
  20321c:	0ff7f713          	andi	a4,a5,255
  203220:	00003797          	auipc	a5,0x3
  203224:	e7878793          	addi	a5,a5,-392 # 206098 <BSS_END+0x378>
  203228:	0007b783          	ld	a5,0(a5)
  20322c:	0007071b          	sext.w	a4,a4
  203230:	00e7a023          	sw	a4,0(a5)
	#ifdef MYPRINT
	printf("UART0 IER = %d\n\r", uart_read_reg(IER));
  203234:	00003797          	auipc	a5,0x3
  203238:	e6478793          	addi	a5,a5,-412 # 206098 <BSS_END+0x378>
  20323c:	0007b783          	ld	a5,0(a5)
  203240:	0007a783          	lw	a5,0(a5)
  203244:	0007879b          	sext.w	a5,a5
  203248:	00078593          	mv	a1,a5
  20324c:	00003517          	auipc	a0,0x3
  203250:	de450513          	addi	a0,a0,-540 # 206030 <BSS_END+0x310>
  203254:	e1cff0ef          	jal	ra,202870 <printf>
	#endif
}
  203258:	00000013          	nop
  20325c:	01813083          	ld	ra,24(sp)
  203260:	01013403          	ld	s0,16(sp)
  203264:	02010113          	addi	sp,sp,32
  203268:	00008067          	ret

000000000020326c <uart_putc>:

int uart_putc(char ch)
{
  20326c:	fe010113          	addi	sp,sp,-32
  203270:	00813c23          	sd	s0,24(sp)
  203274:	02010413          	addi	s0,sp,32
  203278:	00050793          	mv	a5,a0
  20327c:	fef407a3          	sb	a5,-17(s0)
	while ((uart_read_reg(LSR) & LSR_TX_IDLE) == 0);
  203280:	00000013          	nop
  203284:	00003797          	auipc	a5,0x3
  203288:	e2478793          	addi	a5,a5,-476 # 2060a8 <BSS_END+0x388>
  20328c:	0007b783          	ld	a5,0(a5)
  203290:	0007a783          	lw	a5,0(a5)
  203294:	0007879b          	sext.w	a5,a5
  203298:	0407f793          	andi	a5,a5,64
  20329c:	0007879b          	sext.w	a5,a5
  2032a0:	fe0782e3          	beqz	a5,203284 <uart_putc+0x18>
	return uart_write_reg(THR, ch);
  2032a4:	03ffa7b7          	lui	a5,0x3ffa
  2032a8:	c0578793          	addi	a5,a5,-1019 # 3ff9c05 <_bss_end+0x3deeb55>
  2032ac:	00e79713          	slli	a4,a5,0xe
  2032b0:	fef44783          	lbu	a5,-17(s0)
  2032b4:	0007879b          	sext.w	a5,a5
  2032b8:	0007879b          	sext.w	a5,a5
  2032bc:	00f72023          	sw	a5,0(a4)
  2032c0:	0007879b          	sext.w	a5,a5
}
  2032c4:	00078513          	mv	a0,a5
  2032c8:	01813403          	ld	s0,24(sp)
  2032cc:	02010113          	addi	sp,sp,32
  2032d0:	00008067          	ret

00000000002032d4 <uart_puts>:

void uart_puts(char *s)
{
  2032d4:	fe010113          	addi	sp,sp,-32
  2032d8:	00113c23          	sd	ra,24(sp)
  2032dc:	00813823          	sd	s0,16(sp)
  2032e0:	02010413          	addi	s0,sp,32
  2032e4:	fea43423          	sd	a0,-24(s0)
	while (*s) {
  2032e8:	01c0006f          	j	203304 <uart_puts+0x30>
		uart_putc(*s++);
  2032ec:	fe843783          	ld	a5,-24(s0)
  2032f0:	00178713          	addi	a4,a5,1
  2032f4:	fee43423          	sd	a4,-24(s0)
  2032f8:	0007c783          	lbu	a5,0(a5)
  2032fc:	00078513          	mv	a0,a5
  203300:	f6dff0ef          	jal	ra,20326c <uart_putc>
	while (*s) {
  203304:	fe843783          	ld	a5,-24(s0)
  203308:	0007c783          	lbu	a5,0(a5)
  20330c:	fe0790e3          	bnez	a5,2032ec <uart_puts+0x18>
	}
}
  203310:	00000013          	nop
  203314:	01813083          	ld	ra,24(sp)
  203318:	01013403          	ld	s0,16(sp)
  20331c:	02010113          	addi	sp,sp,32
  203320:	00008067          	ret

0000000000203324 <uart_getc>:

int uart_getc(void)
{
  203324:	ff010113          	addi	sp,sp,-16
  203328:	00813423          	sd	s0,8(sp)
  20332c:	01010413          	addi	s0,sp,16
	while (0 == (uart_read_reg(LSR) & LSR_RX_READY))
  203330:	00000013          	nop
  203334:	00003797          	auipc	a5,0x3
  203338:	d7478793          	addi	a5,a5,-652 # 2060a8 <BSS_END+0x388>
  20333c:	0007b783          	ld	a5,0(a5)
  203340:	0007a783          	lw	a5,0(a5)
  203344:	0007879b          	sext.w	a5,a5
  203348:	0017f793          	andi	a5,a5,1
  20334c:	0007879b          	sext.w	a5,a5
  203350:	fe0782e3          	beqz	a5,203334 <uart_getc+0x10>
		;
	return uart_read_reg(RHR);
  203354:	03ffa7b7          	lui	a5,0x3ffa
  203358:	c0578793          	addi	a5,a5,-1019 # 3ff9c05 <_bss_end+0x3deeb55>
  20335c:	00e79793          	slli	a5,a5,0xe
  203360:	0007a783          	lw	a5,0(a5)
  203364:	0007879b          	sext.w	a5,a5
  203368:	0007879b          	sext.w	a5,a5
}
  20336c:	00078513          	mv	a0,a5
  203370:	00813403          	ld	s0,8(sp)
  203374:	01010113          	addi	sp,sp,16
  203378:	00008067          	ret

000000000020337c <uart_isr>:

/*
 * handle a uart interrupt, raised because input has arrived, called from trap.c.
 */
void uart_isr(void)
{
  20337c:	fe010113          	addi	sp,sp,-32
  203380:	00113c23          	sd	ra,24(sp)
  203384:	00813823          	sd	s0,16(sp)
  203388:	02010413          	addi	s0,sp,32
	/* add a new line just to look better */
	uint32_t usr =  uart_read_reg(USR);
  20338c:	00003797          	auipc	a5,0x3
  203390:	d0478793          	addi	a5,a5,-764 # 206090 <BSS_END+0x370>
  203394:	0007b783          	ld	a5,0(a5)
  203398:	0007a783          	lw	a5,0(a5)
  20339c:	fef42623          	sw	a5,-20(s0)
	uint32_t isr = uart_read_reg(ISR);
  2033a0:	00003797          	auipc	a5,0x3
  2033a4:	d1078793          	addi	a5,a5,-752 # 2060b0 <BSS_END+0x390>
  2033a8:	0007b783          	ld	a5,0(a5)
  2033ac:	0007a783          	lw	a5,0(a5)
  2033b0:	fef42423          	sw	a5,-24(s0)
	#ifdef MYPRINT
	printf("IID = %d\n\r", isr & ISR_IID);
  2033b4:	fe842783          	lw	a5,-24(s0)
  2033b8:	00f7f793          	andi	a5,a5,15
  2033bc:	0007879b          	sext.w	a5,a5
  2033c0:	00078593          	mv	a1,a5
  2033c4:	00003517          	auipc	a0,0x3
  2033c8:	c8450513          	addi	a0,a0,-892 # 206048 <BSS_END+0x328>
  2033cc:	ca4ff0ef          	jal	ra,202870 <printf>
	printf("FAR = %d\n\r", uart_read_reg(FAR));
  2033d0:	00003797          	auipc	a5,0x3
  2033d4:	ce878793          	addi	a5,a5,-792 # 2060b8 <BSS_END+0x398>
  2033d8:	0007b783          	ld	a5,0(a5)
  2033dc:	0007a783          	lw	a5,0(a5)
  2033e0:	0007879b          	sext.w	a5,a5
  2033e4:	00078593          	mv	a1,a5
  2033e8:	00003517          	auipc	a0,0x3
  2033ec:	c7050513          	addi	a0,a0,-912 # 206058 <BSS_END+0x338>
  2033f0:	c80ff0ef          	jal	ra,202870 <printf>
	printf("USR = %d\n\r", usr);
  2033f4:	fec42783          	lw	a5,-20(s0)
  2033f8:	00078593          	mv	a1,a5
  2033fc:	00003517          	auipc	a0,0x3
  203400:	c6c50513          	addi	a0,a0,-916 # 206068 <BSS_END+0x348>
  203404:	c6cff0ef          	jal	ra,202870 <printf>
	printf("CPR = %d\n\r", uart_read_reg(CPR));
  203408:	00003797          	auipc	a5,0x3
  20340c:	cb878793          	addi	a5,a5,-840 # 2060c0 <BSS_END+0x3a0>
  203410:	0007b783          	ld	a5,0(a5)
  203414:	0007a783          	lw	a5,0(a5)
  203418:	0007879b          	sext.w	a5,a5
  20341c:	00078593          	mv	a1,a5
  203420:	00003517          	auipc	a0,0x3
  203424:	c5850513          	addi	a0,a0,-936 # 206078 <BSS_END+0x358>
  203428:	c48ff0ef          	jal	ra,202870 <printf>
	#endif
	#ifndef MYPRINT
	printf("\033[K");
	#endif
	if ((isr & ISR_IID) == 1) return;
  20342c:	fe842783          	lw	a5,-24(s0)
  203430:	00f7f793          	andi	a5,a5,15
  203434:	0007879b          	sext.w	a5,a5
  203438:	00078713          	mv	a4,a5
  20343c:	00100793          	li	a5,1
  203440:	02f70463          	beq	a4,a5,203468 <uart_isr+0xec>
	addGoishBuffer((char)uart_getc());
  203444:	ee1ff0ef          	jal	ra,203324 <uart_getc>
  203448:	00050793          	mv	a5,a0
  20344c:	0ff7f793          	andi	a5,a5,255
  203450:	00078513          	mv	a0,a5
  203454:	324010ef          	jal	ra,204778 <addGoishBuffer>
	#ifdef MYPRINT
	printf("\n");
  203458:	00003517          	auipc	a0,0x3
  20345c:	c3050513          	addi	a0,a0,-976 # 206088 <BSS_END+0x368>
  203460:	c10ff0ef          	jal	ra,202870 <printf>
  203464:	0080006f          	j	20346c <uart_isr+0xf0>
	if ((isr & ISR_IID) == 1) return;
  203468:	00000013          	nop
	#endif
}
  20346c:	01813083          	ld	ra,24(sp)
  203470:	01013403          	ld	s0,16(sp)
  203474:	02010113          	addi	sp,sp,32
  203478:	00008067          	ret

000000000020347c <w_mscratch>:
static void w_mscratch(reg_t x){
  20347c:	fe010113          	addi	sp,sp,-32
  203480:	00813c23          	sd	s0,24(sp)
  203484:	02010413          	addi	s0,sp,32
  203488:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  20348c:	fe843783          	ld	a5,-24(s0)
  203490:	34079073          	csrw	mscratch,a5
}
  203494:	00000013          	nop
  203498:	01813403          	ld	s0,24(sp)
  20349c:	02010113          	addi	sp,sp,32
  2034a0:	00008067          	ret

00000000002034a4 <r_mscratch>:
static reg_t r_mscratch(){
  2034a4:	fe010113          	addi	sp,sp,-32
  2034a8:	00813c23          	sd	s0,24(sp)
  2034ac:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  2034b0:	340027f3          	csrr	a5,mscratch
  2034b4:	fef43423          	sd	a5,-24(s0)
	return ret;
  2034b8:	fe843783          	ld	a5,-24(s0)
}
  2034bc:	00078513          	mv	a0,a5
  2034c0:	01813403          	ld	s0,24(sp)
  2034c4:	02010113          	addi	sp,sp,32
  2034c8:	00008067          	ret

00000000002034cc <r_tp>:
static inline reg_t r_tp(){
  2034cc:	fe010113          	addi	sp,sp,-32
  2034d0:	00813c23          	sd	s0,24(sp)
  2034d4:	02010413          	addi	s0,sp,32
    asm volatile("mv %0, tp" :"=r" (ret));
  2034d8:	00020793          	mv	a5,tp
  2034dc:	fef43423          	sd	a5,-24(s0)
    return ret;
  2034e0:	fe843783          	ld	a5,-24(s0)
}
  2034e4:	00078513          	mv	a0,a5
  2034e8:	01813403          	ld	s0,24(sp)
  2034ec:	02010113          	addi	sp,sp,32
  2034f0:	00008067          	ret

00000000002034f4 <r_mstatus>:
static inline reg_t r_mstatus(){
  2034f4:	fe010113          	addi	sp,sp,-32
  2034f8:	00813c23          	sd	s0,24(sp)
  2034fc:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
  203500:	300027f3          	csrr	a5,mstatus
  203504:	fef43423          	sd	a5,-24(s0)
	return x;
  203508:	fe843783          	ld	a5,-24(s0)
}
  20350c:	00078513          	mv	a0,a5
  203510:	01813403          	ld	s0,24(sp)
  203514:	02010113          	addi	sp,sp,32
  203518:	00008067          	ret

000000000020351c <w_mstatus>:
static inline void w_mstatus(reg_t x){
  20351c:	fe010113          	addi	sp,sp,-32
  203520:	00813c23          	sd	s0,24(sp)
  203524:	02010413          	addi	s0,sp,32
  203528:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
  20352c:	fe843783          	ld	a5,-24(s0)
  203530:	30079073          	csrw	mstatus,a5
}
  203534:	00000013          	nop
  203538:	01813403          	ld	s0,24(sp)
  20353c:	02010113          	addi	sp,sp,32
  203540:	00008067          	ret

0000000000203544 <r_mie>:
// set mstatus first and then mie.
#define MIE_MEIE (1 << 11) // external
#define MIE_MTIE (1 << 7)  // timer
#define MIE_MSIE (1 << 3)  // software
static inline reg_t r_mie()
{
  203544:	fe010113          	addi	sp,sp,-32
  203548:	00813c23          	sd	s0,24(sp)
  20354c:	02010413          	addi	s0,sp,32
	reg_t x;
	asm volatile("csrr %0, mie" : "=r" (x) );
  203550:	304027f3          	csrr	a5,mie
  203554:	fef43423          	sd	a5,-24(s0)
	return x;
  203558:	fe843783          	ld	a5,-24(s0)
}
  20355c:	00078513          	mv	a0,a5
  203560:	01813403          	ld	s0,24(sp)
  203564:	02010113          	addi	sp,sp,32
  203568:	00008067          	ret

000000000020356c <w_mie>:
	asm volatile("csrr %0, mip" : "=r" (x) );
	return x;
}

static inline void w_mie(reg_t x)
{
  20356c:	fe010113          	addi	sp,sp,-32
  203570:	00813c23          	sd	s0,24(sp)
  203574:	02010413          	addi	s0,sp,32
  203578:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
  20357c:	fe843783          	ld	a5,-24(s0)
  203580:	30479073          	csrw	mie,a5
}
  203584:	00000013          	nop
  203588:	01813403          	ld	s0,24(sp)
  20358c:	02010113          	addi	sp,sp,32
  203590:	00008067          	ret

0000000000203594 <get_time>:
static uint64_t get_time(){
  203594:	ff010113          	addi	sp,sp,-16
  203598:	00813423          	sd	s0,8(sp)
  20359c:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  2035a0:	00004797          	auipc	a5,0x4
  2035a4:	ef878793          	addi	a5,a5,-264 # 207498 <_tick>
  2035a8:	0007b703          	ld	a4,0(a5)
  2035ac:	03c00793          	li	a5,60
  2035b0:	02f757b3          	divu	a5,a4,a5
}
  2035b4:	00078513          	mv	a0,a5
  2035b8:	00813403          	ld	s0,8(sp)
  2035bc:	01010113          	addi	sp,sp,16
  2035c0:	00008067          	ret

00000000002035c4 <get_time_str>:
static void get_time_str(char* time){
  2035c4:	fc010113          	addi	sp,sp,-64
  2035c8:	02813c23          	sd	s0,56(sp)
  2035cc:	04010413          	addi	s0,sp,64
  2035d0:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  2035d4:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  2035d8:	00004797          	auipc	a5,0x4
  2035dc:	ec078793          	addi	a5,a5,-320 # 207498 <_tick>
  2035e0:	0007b703          	ld	a4,0(a5)
  2035e4:	03c00793          	li	a5,60
  2035e8:	02f757b3          	divu	a5,a4,a5
  2035ec:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  2035f0:	fe043703          	ld	a4,-32(s0)
  2035f4:	000017b7          	lui	a5,0x1
  2035f8:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2035fc:	02f757b3          	divu	a5,a4,a5
  203600:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  203604:	fdf44703          	lbu	a4,-33(s0)
  203608:	06400793          	li	a5,100
  20360c:	02f777bb          	remuw	a5,a4,a5
  203610:	0ff7f793          	andi	a5,a5,255
  203614:	00078713          	mv	a4,a5
  203618:	00a00793          	li	a5,10
  20361c:	02f757bb          	divuw	a5,a4,a5
  203620:	0ff7f793          	andi	a5,a5,255
  203624:	0307879b          	addiw	a5,a5,48
  203628:	0ff7f713          	andi	a4,a5,255
  20362c:	fc843783          	ld	a5,-56(s0)
  203630:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  203634:	fdf44703          	lbu	a4,-33(s0)
  203638:	00a00793          	li	a5,10
  20363c:	02f777bb          	remuw	a5,a4,a5
  203640:	0ff7f713          	andi	a4,a5,255
  203644:	fc843783          	ld	a5,-56(s0)
  203648:	00178793          	addi	a5,a5,1
  20364c:	0307071b          	addiw	a4,a4,48
  203650:	0ff77713          	andi	a4,a4,255
  203654:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  203658:	fc843783          	ld	a5,-56(s0)
  20365c:	00278793          	addi	a5,a5,2
  203660:	03a00713          	li	a4,58
  203664:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  203668:	fe043703          	ld	a4,-32(s0)
  20366c:	000017b7          	lui	a5,0x1
  203670:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  203674:	02f77733          	remu	a4,a4,a5
  203678:	03c00793          	li	a5,60
  20367c:	02f757b3          	divu	a5,a4,a5
  203680:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  203684:	fdf44703          	lbu	a4,-33(s0)
  203688:	00a00793          	li	a5,10
  20368c:	02f757bb          	divuw	a5,a4,a5
  203690:	0ff7f713          	andi	a4,a5,255
  203694:	fc843783          	ld	a5,-56(s0)
  203698:	00378793          	addi	a5,a5,3
  20369c:	0307071b          	addiw	a4,a4,48
  2036a0:	0ff77713          	andi	a4,a4,255
  2036a4:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  2036a8:	fdf44703          	lbu	a4,-33(s0)
  2036ac:	00a00793          	li	a5,10
  2036b0:	02f777bb          	remuw	a5,a4,a5
  2036b4:	0ff7f713          	andi	a4,a5,255
  2036b8:	fc843783          	ld	a5,-56(s0)
  2036bc:	00478793          	addi	a5,a5,4
  2036c0:	0307071b          	addiw	a4,a4,48
  2036c4:	0ff77713          	andi	a4,a4,255
  2036c8:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  2036cc:	fc843783          	ld	a5,-56(s0)
  2036d0:	00578793          	addi	a5,a5,5
  2036d4:	03a00713          	li	a4,58
  2036d8:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  2036dc:	fe043703          	ld	a4,-32(s0)
  2036e0:	03c00793          	li	a5,60
  2036e4:	02f777b3          	remu	a5,a4,a5
  2036e8:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  2036ec:	fdf44703          	lbu	a4,-33(s0)
  2036f0:	00a00793          	li	a5,10
  2036f4:	02f757bb          	divuw	a5,a4,a5
  2036f8:	0ff7f713          	andi	a4,a5,255
  2036fc:	fc843783          	ld	a5,-56(s0)
  203700:	00678793          	addi	a5,a5,6
  203704:	0307071b          	addiw	a4,a4,48
  203708:	0ff77713          	andi	a4,a4,255
  20370c:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  203710:	fdf44703          	lbu	a4,-33(s0)
  203714:	00a00793          	li	a5,10
  203718:	02f777bb          	remuw	a5,a4,a5
  20371c:	0ff7f713          	andi	a4,a5,255
  203720:	fc843783          	ld	a5,-56(s0)
  203724:	00778793          	addi	a5,a5,7
  203728:	0307071b          	addiw	a4,a4,48
  20372c:	0ff77713          	andi	a4,a4,255
  203730:	00e78023          	sb	a4,0(a5)
}
  203734:	00000013          	nop
  203738:	03813403          	ld	s0,56(sp)
  20373c:	04010113          	addi	sp,sp,64
  203740:	00008067          	ret

0000000000203744 <plic_init>:
#include "plic.h"

void plic_init(void)
{
  203744:	fe010113          	addi	sp,sp,-32
  203748:	00113c23          	sd	ra,24(sp)
  20374c:	00813823          	sd	s0,16(sp)
  203750:	02010413          	addi	s0,sp,32
	int hart = r_tp();
  203754:	d79ff0ef          	jal	ra,2034cc <r_tp>
  203758:	00050793          	mv	a5,a0
  20375c:	fef42623          	sw	a5,-20(s0)
	 * Priority 1 is the lowest active priority, and priority 7 is the highest. 
	 * Ties between global interrupts of the same priority are broken by 
	 * the Interrupt ID; interrupts with the lowest ID have the highest 
	 * effective priority.
	 */
	*(uint32_t*)PLIC_PRIORITY(UART0_IRQ) = 1;
  203760:	01ffb7b7          	lui	a5,0x1ffb
  203764:	00f79793          	slli	a5,a5,0xf
  203768:	09078793          	addi	a5,a5,144 # 1ffb090 <_bss_end+0x1deffe0>
  20376c:	00100713          	li	a4,1
  203770:	00e7a023          	sw	a4,0(a5)
	 * Enable UART0
	 *
	 * Each global interrupt can be enabled by setting the corresponding 
	 * bit in the enables registers.
	 */
	*(uint32_t*)PLIC_MENABLE(hart, UART0_IRQ)= (1 << (UART0_IRQ % 32));
  203774:	fec42783          	lw	a5,-20(s0)
  203778:	0087979b          	slliw	a5,a5,0x8
  20377c:	0007879b          	sext.w	a5,a5
  203780:	00078713          	mv	a4,a5
  203784:	00003797          	auipc	a5,0x3
  203788:	94478793          	addi	a5,a5,-1724 # 2060c8 <BSS_END+0x3a8>
  20378c:	0007b783          	ld	a5,0(a5)
  203790:	00f707b3          	add	a5,a4,a5
  203794:	00078713          	mv	a4,a5
  203798:	01000793          	li	a5,16
  20379c:	00f72023          	sw	a5,0(a4)
	 * Maximum threshold is 7.
	 * For example, a threshold value of zero permits all interrupts with
	 * non-zero priority, whereas a value of 7 masks all interrupts.
	 * Notice, the threshold is global for PLIC, not for each interrupt source.
	 */
	*(uint32_t*)PLIC_MTHRESHOLD(hart) = 0;
  2037a0:	fec42783          	lw	a5,-20(s0)
  2037a4:	00d7979b          	slliw	a5,a5,0xd
  2037a8:	0007879b          	sext.w	a5,a5
  2037ac:	00078713          	mv	a4,a5
  2037b0:	7fec17b7          	lui	a5,0x7fec1
  2037b4:	00979793          	slli	a5,a5,0x9
  2037b8:	00f707b3          	add	a5,a4,a5
  2037bc:	0007a023          	sw	zero,0(a5) # 7fec1000 <_memory_end+0x6fec1001>

	/* enable machine-mode external interrupts. */
	w_mie(r_mie() | MIE_MEIE);
  2037c0:	d85ff0ef          	jal	ra,203544 <r_mie>
  2037c4:	00050713          	mv	a4,a0
  2037c8:	000017b7          	lui	a5,0x1
  2037cc:	80078793          	addi	a5,a5,-2048 # 800 <STACK_SIZE+0x400>
  2037d0:	00f767b3          	or	a5,a4,a5
  2037d4:	00078513          	mv	a0,a5
  2037d8:	d95ff0ef          	jal	ra,20356c <w_mie>

                 
	/* enable machine-mode global interrupts. */
	w_mstatus(r_mstatus() | MSTATUS_MIE);
  2037dc:	d19ff0ef          	jal	ra,2034f4 <r_mstatus>
  2037e0:	00050793          	mv	a5,a0
  2037e4:	0087e793          	ori	a5,a5,8
  2037e8:	00078513          	mv	a0,a5
  2037ec:	d31ff0ef          	jal	ra,20351c <w_mstatus>
	
}
  2037f0:	00000013          	nop
  2037f4:	01813083          	ld	ra,24(sp)
  2037f8:	01013403          	ld	s0,16(sp)
  2037fc:	02010113          	addi	sp,sp,32
  203800:	00008067          	ret

0000000000203804 <plic_claim>:
 * RETURN VALUE:
 *	the ID of the highest-priority pending interrupt or zero if there 
 *	is no pending interrupt.
 */
int plic_claim(void)
{
  203804:	fe010113          	addi	sp,sp,-32
  203808:	00113c23          	sd	ra,24(sp)
  20380c:	00813823          	sd	s0,16(sp)
  203810:	02010413          	addi	s0,sp,32
	int hart = r_tp();
  203814:	cb9ff0ef          	jal	ra,2034cc <r_tp>
  203818:	00050793          	mv	a5,a0
  20381c:	fef42623          	sw	a5,-20(s0)
	int irq = *(uint32_t*)PLIC_MCLAIM(hart);
  203820:	fec42783          	lw	a5,-20(s0)
  203824:	00d7979b          	slliw	a5,a5,0xd
  203828:	0007879b          	sext.w	a5,a5
  20382c:	00078713          	mv	a4,a5
  203830:	7fec17b7          	lui	a5,0x7fec1
  203834:	00979793          	slli	a5,a5,0x9
  203838:	00478793          	addi	a5,a5,4 # 7fec1004 <_memory_end+0x6fec1005>
  20383c:	00f707b3          	add	a5,a4,a5
  203840:	0007a783          	lw	a5,0(a5)
  203844:	fef42423          	sw	a5,-24(s0)
	return irq;
  203848:	fe842783          	lw	a5,-24(s0)
}
  20384c:	00078513          	mv	a0,a5
  203850:	01813083          	ld	ra,24(sp)
  203854:	01013403          	ld	s0,16(sp)
  203858:	02010113          	addi	sp,sp,32
  20385c:	00008067          	ret

0000000000203860 <plic_complete>:
 *	interrupt source that is currently enabled for the target, the completion
 *	is silently ignored.
 * RETURN VALUE: none
 */
void plic_complete(int irq)
{
  203860:	fd010113          	addi	sp,sp,-48
  203864:	02113423          	sd	ra,40(sp)
  203868:	02813023          	sd	s0,32(sp)
  20386c:	03010413          	addi	s0,sp,48
  203870:	00050793          	mv	a5,a0
  203874:	fcf42e23          	sw	a5,-36(s0)
	int hart = r_tp();
  203878:	c55ff0ef          	jal	ra,2034cc <r_tp>
  20387c:	00050793          	mv	a5,a0
  203880:	fef42623          	sw	a5,-20(s0)
	*(uint32_t*)PLIC_MCOMPLETE(hart) = irq;
  203884:	fec42783          	lw	a5,-20(s0)
  203888:	00d7979b          	slliw	a5,a5,0xd
  20388c:	0007879b          	sext.w	a5,a5
  203890:	00078713          	mv	a4,a5
  203894:	7fec17b7          	lui	a5,0x7fec1
  203898:	00979793          	slli	a5,a5,0x9
  20389c:	00478793          	addi	a5,a5,4 # 7fec1004 <_memory_end+0x6fec1005>
  2038a0:	00f707b3          	add	a5,a4,a5
  2038a4:	00078713          	mv	a4,a5
  2038a8:	fdc42783          	lw	a5,-36(s0)
  2038ac:	00f72023          	sw	a5,0(a4)
}
  2038b0:	00000013          	nop
  2038b4:	02813083          	ld	ra,40(sp)
  2038b8:	02013403          	ld	s0,32(sp)
  2038bc:	03010113          	addi	sp,sp,48
  2038c0:	00008067          	ret

00000000002038c4 <w_mscratch>:
static void w_mscratch(reg_t x){
  2038c4:	fe010113          	addi	sp,sp,-32
  2038c8:	00813c23          	sd	s0,24(sp)
  2038cc:	02010413          	addi	s0,sp,32
  2038d0:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  2038d4:	fe843783          	ld	a5,-24(s0)
  2038d8:	34079073          	csrw	mscratch,a5
}
  2038dc:	00000013          	nop
  2038e0:	01813403          	ld	s0,24(sp)
  2038e4:	02010113          	addi	sp,sp,32
  2038e8:	00008067          	ret

00000000002038ec <r_mscratch>:
static reg_t r_mscratch(){
  2038ec:	fe010113          	addi	sp,sp,-32
  2038f0:	00813c23          	sd	s0,24(sp)
  2038f4:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  2038f8:	340027f3          	csrr	a5,mscratch
  2038fc:	fef43423          	sd	a5,-24(s0)
	return ret;
  203900:	fe843783          	ld	a5,-24(s0)
}
  203904:	00078513          	mv	a0,a5
  203908:	01813403          	ld	s0,24(sp)
  20390c:	02010113          	addi	sp,sp,32
  203910:	00008067          	ret

0000000000203914 <get_time>:
static uint64_t get_time(){
  203914:	ff010113          	addi	sp,sp,-16
  203918:	00813423          	sd	s0,8(sp)
  20391c:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  203920:	00004797          	auipc	a5,0x4
  203924:	b9878793          	addi	a5,a5,-1128 # 2074b8 <_tick>
  203928:	0007b703          	ld	a4,0(a5)
  20392c:	03c00793          	li	a5,60
  203930:	02f757b3          	divu	a5,a4,a5
}
  203934:	00078513          	mv	a0,a5
  203938:	00813403          	ld	s0,8(sp)
  20393c:	01010113          	addi	sp,sp,16
  203940:	00008067          	ret

0000000000203944 <get_time_str>:
static void get_time_str(char* time){
  203944:	fc010113          	addi	sp,sp,-64
  203948:	02813c23          	sd	s0,56(sp)
  20394c:	04010413          	addi	s0,sp,64
  203950:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  203954:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  203958:	00004797          	auipc	a5,0x4
  20395c:	b6078793          	addi	a5,a5,-1184 # 2074b8 <_tick>
  203960:	0007b703          	ld	a4,0(a5)
  203964:	03c00793          	li	a5,60
  203968:	02f757b3          	divu	a5,a4,a5
  20396c:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  203970:	fe043703          	ld	a4,-32(s0)
  203974:	000017b7          	lui	a5,0x1
  203978:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  20397c:	02f757b3          	divu	a5,a4,a5
  203980:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  203984:	fdf44703          	lbu	a4,-33(s0)
  203988:	06400793          	li	a5,100
  20398c:	02f777bb          	remuw	a5,a4,a5
  203990:	0ff7f793          	andi	a5,a5,255
  203994:	00078713          	mv	a4,a5
  203998:	00a00793          	li	a5,10
  20399c:	02f757bb          	divuw	a5,a4,a5
  2039a0:	0ff7f793          	andi	a5,a5,255
  2039a4:	0307879b          	addiw	a5,a5,48
  2039a8:	0ff7f713          	andi	a4,a5,255
  2039ac:	fc843783          	ld	a5,-56(s0)
  2039b0:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  2039b4:	fdf44703          	lbu	a4,-33(s0)
  2039b8:	00a00793          	li	a5,10
  2039bc:	02f777bb          	remuw	a5,a4,a5
  2039c0:	0ff7f713          	andi	a4,a5,255
  2039c4:	fc843783          	ld	a5,-56(s0)
  2039c8:	00178793          	addi	a5,a5,1
  2039cc:	0307071b          	addiw	a4,a4,48
  2039d0:	0ff77713          	andi	a4,a4,255
  2039d4:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  2039d8:	fc843783          	ld	a5,-56(s0)
  2039dc:	00278793          	addi	a5,a5,2
  2039e0:	03a00713          	li	a4,58
  2039e4:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  2039e8:	fe043703          	ld	a4,-32(s0)
  2039ec:	000017b7          	lui	a5,0x1
  2039f0:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  2039f4:	02f77733          	remu	a4,a4,a5
  2039f8:	03c00793          	li	a5,60
  2039fc:	02f757b3          	divu	a5,a4,a5
  203a00:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  203a04:	fdf44703          	lbu	a4,-33(s0)
  203a08:	00a00793          	li	a5,10
  203a0c:	02f757bb          	divuw	a5,a4,a5
  203a10:	0ff7f713          	andi	a4,a5,255
  203a14:	fc843783          	ld	a5,-56(s0)
  203a18:	00378793          	addi	a5,a5,3
  203a1c:	0307071b          	addiw	a4,a4,48
  203a20:	0ff77713          	andi	a4,a4,255
  203a24:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  203a28:	fdf44703          	lbu	a4,-33(s0)
  203a2c:	00a00793          	li	a5,10
  203a30:	02f777bb          	remuw	a5,a4,a5
  203a34:	0ff7f713          	andi	a4,a5,255
  203a38:	fc843783          	ld	a5,-56(s0)
  203a3c:	00478793          	addi	a5,a5,4
  203a40:	0307071b          	addiw	a4,a4,48
  203a44:	0ff77713          	andi	a4,a4,255
  203a48:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  203a4c:	fc843783          	ld	a5,-56(s0)
  203a50:	00578793          	addi	a5,a5,5
  203a54:	03a00713          	li	a4,58
  203a58:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  203a5c:	fe043703          	ld	a4,-32(s0)
  203a60:	03c00793          	li	a5,60
  203a64:	02f777b3          	remu	a5,a4,a5
  203a68:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  203a6c:	fdf44703          	lbu	a4,-33(s0)
  203a70:	00a00793          	li	a5,10
  203a74:	02f757bb          	divuw	a5,a4,a5
  203a78:	0ff7f713          	andi	a4,a5,255
  203a7c:	fc843783          	ld	a5,-56(s0)
  203a80:	00678793          	addi	a5,a5,6
  203a84:	0307071b          	addiw	a4,a4,48
  203a88:	0ff77713          	andi	a4,a4,255
  203a8c:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  203a90:	fdf44703          	lbu	a4,-33(s0)
  203a94:	00a00793          	li	a5,10
  203a98:	02f777bb          	remuw	a5,a4,a5
  203a9c:	0ff7f713          	andi	a4,a5,255
  203aa0:	fc843783          	ld	a5,-56(s0)
  203aa4:	00778793          	addi	a5,a5,7
  203aa8:	0307071b          	addiw	a4,a4,48
  203aac:	0ff77713          	andi	a4,a4,255
  203ab0:	00e78023          	sb	a4,0(a5)
}
  203ab4:	00000013          	nop
  203ab8:	03813403          	ld	s0,56(sp)
  203abc:	04010113          	addi	sp,sp,64
  203ac0:	00008067          	ret

0000000000203ac4 <print_printftest>:
#include "graphprint.h"

void print_printftest(){
  203ac4:	ff010113          	addi	sp,sp,-16
  203ac8:	00113423          	sd	ra,8(sp)
  203acc:	00813023          	sd	s0,0(sp)
  203ad0:	01010413          	addi	s0,sp,16
	printf("#########################################################\n\r");
  203ad4:	00002517          	auipc	a0,0x2
  203ad8:	5fc50513          	addi	a0,a0,1532 # 2060d0 <BSS_END+0x3b0>
  203adc:	d95fe0ef          	jal	ra,202870 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  203ae0:	00002517          	auipc	a0,0x2
  203ae4:	63050513          	addi	a0,a0,1584 # 206110 <BSS_END+0x3f0>
  203ae8:	d89fe0ef          	jal	ra,202870 <printf>
	printf("##     this is a printf test:%p        ##\n\r",0xfedcba9876543210);
  203aec:	00003797          	auipc	a5,0x3
  203af0:	94c78793          	addi	a5,a5,-1716 # 206438 <BSS_END+0x718>
  203af4:	0007b783          	ld	a5,0(a5)
  203af8:	00078593          	mv	a1,a5
  203afc:	00002517          	auipc	a0,0x2
  203b00:	65450513          	addi	a0,a0,1620 # 206150 <BSS_END+0x430>
  203b04:	d6dfe0ef          	jal	ra,202870 <printf>
	printf("##         fedcba9876543210 means right output         ##\n\r");
  203b08:	00002517          	auipc	a0,0x2
  203b0c:	67850513          	addi	a0,a0,1656 # 206180 <BSS_END+0x460>
  203b10:	d61fe0ef          	jal	ra,202870 <printf>
	printf("#########################################################\n\r");
  203b14:	00002517          	auipc	a0,0x2
  203b18:	5bc50513          	addi	a0,a0,1468 # 2060d0 <BSS_END+0x3b0>
  203b1c:	d55fe0ef          	jal	ra,202870 <printf>
}
  203b20:	00000013          	nop
  203b24:	00813083          	ld	ra,8(sp)
  203b28:	00013403          	ld	s0,0(sp)
  203b2c:	01010113          	addi	sp,sp,16
  203b30:	00008067          	ret

0000000000203b34 <print_WhoAmI>:

void print_WhoAmI(){
  203b34:	ff010113          	addi	sp,sp,-16
  203b38:	00113423          	sd	ra,8(sp)
  203b3c:	00813023          	sd	s0,0(sp)
  203b40:	01010413          	addi	s0,sp,16
	printf("\n\r");
  203b44:	00002517          	auipc	a0,0x2
  203b48:	67c50513          	addi	a0,a0,1660 # 2061c0 <BSS_END+0x4a0>
  203b4c:	d25fe0ef          	jal	ra,202870 <printf>
	printf("\033[5m#########################################################\n\r");
  203b50:	00002517          	auipc	a0,0x2
  203b54:	67850513          	addi	a0,a0,1656 # 2061c8 <BSS_END+0x4a8>
  203b58:	d19fe0ef          	jal	ra,202870 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  203b5c:	00002517          	auipc	a0,0x2
  203b60:	5b450513          	addi	a0,a0,1460 # 206110 <BSS_END+0x3f0>
  203b64:	d0dfe0ef          	jal	ra,202870 <printf>
	printf("##                   %s                         ##\n\r", GROL_OS_VERSION);
  203b68:	00002597          	auipc	a1,0x2
  203b6c:	6a058593          	addi	a1,a1,1696 # 206208 <BSS_END+0x4e8>
  203b70:	00002517          	auipc	a0,0x2
  203b74:	6a850513          	addi	a0,a0,1704 # 206218 <BSS_END+0x4f8>
  203b78:	cf9fe0ef          	jal	ra,202870 <printf>
	printf("#########################################################\033[0m\r");
  203b7c:	00002517          	auipc	a0,0x2
  203b80:	6d450513          	addi	a0,a0,1748 # 206250 <BSS_END+0x530>
  203b84:	cedfe0ef          	jal	ra,202870 <printf>
	printf("\033[1A");
	printf("\033[1A");
	printf("\033[1A");
	printf("\033[1A");
	#endif
}
  203b88:	00000013          	nop
  203b8c:	00813083          	ld	ra,8(sp)
  203b90:	00013403          	ld	s0,0(sp)
  203b94:	01010113          	addi	sp,sp,16
  203b98:	00008067          	ret

0000000000203b9c <print_heapinit>:

void print_heapinit(){
  203b9c:	ff010113          	addi	sp,sp,-16
  203ba0:	00113423          	sd	ra,8(sp)
  203ba4:	00813023          	sd	s0,0(sp)
  203ba8:	01010413          	addi	s0,sp,16
	printf("#########################################################\n\r");
  203bac:	00002517          	auipc	a0,0x2
  203bb0:	52450513          	addi	a0,a0,1316 # 2060d0 <BSS_END+0x3b0>
  203bb4:	cbdfe0ef          	jal	ra,202870 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  203bb8:	00002517          	auipc	a0,0x2
  203bbc:	55850513          	addi	a0,a0,1368 # 206110 <BSS_END+0x3f0>
  203bc0:	cb1fe0ef          	jal	ra,202870 <printf>
	printf("##                HEAP INIT SUCCESS...                 ##\n\r");
  203bc4:	00002517          	auipc	a0,0x2
  203bc8:	6cc50513          	addi	a0,a0,1740 # 206290 <BSS_END+0x570>
  203bcc:	ca5fe0ef          	jal	ra,202870 <printf>
	printf("#########################################################\n\r");
  203bd0:	00002517          	auipc	a0,0x2
  203bd4:	50050513          	addi	a0,a0,1280 # 2060d0 <BSS_END+0x3b0>
  203bd8:	c99fe0ef          	jal	ra,202870 <printf>
}
  203bdc:	00000013          	nop
  203be0:	00813083          	ld	ra,8(sp)
  203be4:	00013403          	ld	s0,0(sp)
  203be8:	01010113          	addi	sp,sp,16
  203bec:	00008067          	ret

0000000000203bf0 <print_multitasktest>:

void print_multitasktest(){
  203bf0:	ff010113          	addi	sp,sp,-16
  203bf4:	00113423          	sd	ra,8(sp)
  203bf8:	00813023          	sd	s0,0(sp)
  203bfc:	01010413          	addi	s0,sp,16
	printf("#########################################################\n\r");
  203c00:	00002517          	auipc	a0,0x2
  203c04:	4d050513          	addi	a0,a0,1232 # 2060d0 <BSS_END+0x3b0>
  203c08:	c69fe0ef          	jal	ra,202870 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  203c0c:	00002517          	auipc	a0,0x2
  203c10:	50450513          	addi	a0,a0,1284 # 206110 <BSS_END+0x3f0>
  203c14:	c5dfe0ef          	jal	ra,202870 <printf>
	printf("##              2  cooperative task test...            ##\n\r");
  203c18:	00002517          	auipc	a0,0x2
  203c1c:	6b850513          	addi	a0,a0,1720 # 2062d0 <BSS_END+0x5b0>
  203c20:	c51fe0ef          	jal	ra,202870 <printf>
	printf("#########################################################\n\r");
  203c24:	00002517          	auipc	a0,0x2
  203c28:	4ac50513          	addi	a0,a0,1196 # 2060d0 <BSS_END+0x3b0>
  203c2c:	c45fe0ef          	jal	ra,202870 <printf>
}
  203c30:	00000013          	nop
  203c34:	00813083          	ld	ra,8(sp)
  203c38:	00013403          	ld	s0,0(sp)
  203c3c:	01010113          	addi	sp,sp,16
  203c40:	00008067          	ret

0000000000203c44 <print_taskkilled>:
void print_taskkilled(){
  203c44:	ff010113          	addi	sp,sp,-16
  203c48:	00113423          	sd	ra,8(sp)
  203c4c:	00813023          	sd	s0,0(sp)
  203c50:	01010413          	addi	s0,sp,16
	printf("\033[31m#########################################################\033[0m\n\r");
  203c54:	00002517          	auipc	a0,0x2
  203c58:	6bc50513          	addi	a0,a0,1724 # 206310 <BSS_END+0x5f0>
  203c5c:	c15fe0ef          	jal	ra,202870 <printf>
	printf("\033[31m##                    GROL_OS                          ##\033[0m\n\r");
  203c60:	00002517          	auipc	a0,0x2
  203c64:	6f850513          	addi	a0,a0,1784 # 206358 <BSS_END+0x638>
  203c68:	c09fe0ef          	jal	ra,202870 <printf>
	printf("\033[31m##              AHAHAH  I AM KILLED.........           ##\033[0m\n\r");
  203c6c:	00002517          	auipc	a0,0x2
  203c70:	73450513          	addi	a0,a0,1844 # 2063a0 <BSS_END+0x680>
  203c74:	bfdfe0ef          	jal	ra,202870 <printf>
	printf("\033[31m#########################################################\033[0m\n\r");
  203c78:	00002517          	auipc	a0,0x2
  203c7c:	69850513          	addi	a0,a0,1688 # 206310 <BSS_END+0x5f0>
  203c80:	bf1fe0ef          	jal	ra,202870 <printf>
}
  203c84:	00000013          	nop
  203c88:	00813083          	ld	ra,8(sp)
  203c8c:	00013403          	ld	s0,0(sp)
  203c90:	01010113          	addi	sp,sp,16
  203c94:	00008067          	ret

0000000000203c98 <delete_taskkilled>:
void delete_taskkilled(){
  203c98:	ff010113          	addi	sp,sp,-16
  203c9c:	00113423          	sd	ra,8(sp)
  203ca0:	00813023          	sd	s0,0(sp)
  203ca4:	01010413          	addi	s0,sp,16
	printf("\033[1A");
  203ca8:	00002517          	auipc	a0,0x2
  203cac:	74050513          	addi	a0,a0,1856 # 2063e8 <BSS_END+0x6c8>
  203cb0:	bc1fe0ef          	jal	ra,202870 <printf>
	printf("\033[K");
  203cb4:	00002517          	auipc	a0,0x2
  203cb8:	73c50513          	addi	a0,a0,1852 # 2063f0 <BSS_END+0x6d0>
  203cbc:	bb5fe0ef          	jal	ra,202870 <printf>
	printf("\033[1A");
  203cc0:	00002517          	auipc	a0,0x2
  203cc4:	72850513          	addi	a0,a0,1832 # 2063e8 <BSS_END+0x6c8>
  203cc8:	ba9fe0ef          	jal	ra,202870 <printf>
	printf("\033[K");
  203ccc:	00002517          	auipc	a0,0x2
  203cd0:	72450513          	addi	a0,a0,1828 # 2063f0 <BSS_END+0x6d0>
  203cd4:	b9dfe0ef          	jal	ra,202870 <printf>
	printf("\033[1A");
  203cd8:	00002517          	auipc	a0,0x2
  203cdc:	71050513          	addi	a0,a0,1808 # 2063e8 <BSS_END+0x6c8>
  203ce0:	b91fe0ef          	jal	ra,202870 <printf>
	printf("\033[K");
  203ce4:	00002517          	auipc	a0,0x2
  203ce8:	70c50513          	addi	a0,a0,1804 # 2063f0 <BSS_END+0x6d0>
  203cec:	b85fe0ef          	jal	ra,202870 <printf>
	printf("\033[1A");
  203cf0:	00002517          	auipc	a0,0x2
  203cf4:	6f850513          	addi	a0,a0,1784 # 2063e8 <BSS_END+0x6c8>
  203cf8:	b79fe0ef          	jal	ra,202870 <printf>
	printf("\033[K");
  203cfc:	00002517          	auipc	a0,0x2
  203d00:	6f450513          	addi	a0,a0,1780 # 2063f0 <BSS_END+0x6d0>
  203d04:	b6dfe0ef          	jal	ra,202870 <printf>
}
  203d08:	00000013          	nop
  203d0c:	00813083          	ld	ra,8(sp)
  203d10:	00013403          	ld	s0,0(sp)
  203d14:	01010113          	addi	sp,sp,16
  203d18:	00008067          	ret

0000000000203d1c <print_taskcontroller_created>:
void print_taskcontroller_created(){
  203d1c:	ff010113          	addi	sp,sp,-16
  203d20:	00113423          	sd	ra,8(sp)
  203d24:	00813023          	sd	s0,0(sp)
  203d28:	01010413          	addi	s0,sp,16
	printf("#########################################################\n\r");
  203d2c:	00002517          	auipc	a0,0x2
  203d30:	3a450513          	addi	a0,a0,932 # 2060d0 <BSS_END+0x3b0>
  203d34:	b3dfe0ef          	jal	ra,202870 <printf>
	printf("##                    GROL_OS                          ##\n\r");
  203d38:	00002517          	auipc	a0,0x2
  203d3c:	3d850513          	addi	a0,a0,984 # 206110 <BSS_END+0x3f0>
  203d40:	b31fe0ef          	jal	ra,202870 <printf>
	printf("##              TASK CONTROLLER CREATED                ##\n\r");
  203d44:	00002517          	auipc	a0,0x2
  203d48:	6b450513          	addi	a0,a0,1716 # 2063f8 <BSS_END+0x6d8>
  203d4c:	b25fe0ef          	jal	ra,202870 <printf>
	printf("#########################################################\n\r");
  203d50:	00002517          	auipc	a0,0x2
  203d54:	38050513          	addi	a0,a0,896 # 2060d0 <BSS_END+0x3b0>
  203d58:	b19fe0ef          	jal	ra,202870 <printf>
  203d5c:	00000013          	nop
  203d60:	00813083          	ld	ra,8(sp)
  203d64:	00013403          	ld	s0,0(sp)
  203d68:	01010113          	addi	sp,sp,16
  203d6c:	00008067          	ret

0000000000203d70 <w_mscratch>:
static void w_mscratch(reg_t x){
  203d70:	fe010113          	addi	sp,sp,-32
  203d74:	00813c23          	sd	s0,24(sp)
  203d78:	02010413          	addi	s0,sp,32
  203d7c:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  203d80:	fe843783          	ld	a5,-24(s0)
  203d84:	34079073          	csrw	mscratch,a5
}
  203d88:	00000013          	nop
  203d8c:	01813403          	ld	s0,24(sp)
  203d90:	02010113          	addi	sp,sp,32
  203d94:	00008067          	ret

0000000000203d98 <r_mscratch>:
static reg_t r_mscratch(){
  203d98:	fe010113          	addi	sp,sp,-32
  203d9c:	00813c23          	sd	s0,24(sp)
  203da0:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  203da4:	340027f3          	csrr	a5,mscratch
  203da8:	fef43423          	sd	a5,-24(s0)
	return ret;
  203dac:	fe843783          	ld	a5,-24(s0)
}
  203db0:	00078513          	mv	a0,a5
  203db4:	01813403          	ld	s0,24(sp)
  203db8:	02010113          	addi	sp,sp,32
  203dbc:	00008067          	ret

0000000000203dc0 <r_mie>:
{
  203dc0:	fe010113          	addi	sp,sp,-32
  203dc4:	00813c23          	sd	s0,24(sp)
  203dc8:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  203dcc:	304027f3          	csrr	a5,mie
  203dd0:	fef43423          	sd	a5,-24(s0)
	return x;
  203dd4:	fe843783          	ld	a5,-24(s0)
}
  203dd8:	00078513          	mv	a0,a5
  203ddc:	01813403          	ld	s0,24(sp)
  203de0:	02010113          	addi	sp,sp,32
  203de4:	00008067          	ret

0000000000203de8 <w_mie>:
{
  203de8:	fe010113          	addi	sp,sp,-32
  203dec:	00813c23          	sd	s0,24(sp)
  203df0:	02010413          	addi	s0,sp,32
  203df4:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
  203df8:	fe843783          	ld	a5,-24(s0)
  203dfc:	30479073          	csrw	mie,a5
}
  203e00:	00000013          	nop
  203e04:	01813403          	ld	s0,24(sp)
  203e08:	02010113          	addi	sp,sp,32
  203e0c:	00008067          	ret

0000000000203e10 <get_time>:
static uint64_t get_time(){
  203e10:	ff010113          	addi	sp,sp,-16
  203e14:	00813423          	sd	s0,8(sp)
  203e18:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  203e1c:	00003797          	auipc	a5,0x3
  203e20:	6bc78793          	addi	a5,a5,1724 # 2074d8 <_tick>
  203e24:	0007b703          	ld	a4,0(a5)
  203e28:	03c00793          	li	a5,60
  203e2c:	02f757b3          	divu	a5,a4,a5
}
  203e30:	00078513          	mv	a0,a5
  203e34:	00813403          	ld	s0,8(sp)
  203e38:	01010113          	addi	sp,sp,16
  203e3c:	00008067          	ret

0000000000203e40 <get_time_str>:
static void get_time_str(char* time){
  203e40:	fc010113          	addi	sp,sp,-64
  203e44:	02813c23          	sd	s0,56(sp)
  203e48:	04010413          	addi	s0,sp,64
  203e4c:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  203e50:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  203e54:	00003797          	auipc	a5,0x3
  203e58:	68478793          	addi	a5,a5,1668 # 2074d8 <_tick>
  203e5c:	0007b703          	ld	a4,0(a5)
  203e60:	03c00793          	li	a5,60
  203e64:	02f757b3          	divu	a5,a4,a5
  203e68:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  203e6c:	fe043703          	ld	a4,-32(s0)
  203e70:	000017b7          	lui	a5,0x1
  203e74:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  203e78:	02f757b3          	divu	a5,a4,a5
  203e7c:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  203e80:	fdf44703          	lbu	a4,-33(s0)
  203e84:	06400793          	li	a5,100
  203e88:	02f777bb          	remuw	a5,a4,a5
  203e8c:	0ff7f793          	andi	a5,a5,255
  203e90:	00078713          	mv	a4,a5
  203e94:	00a00793          	li	a5,10
  203e98:	02f757bb          	divuw	a5,a4,a5
  203e9c:	0ff7f793          	andi	a5,a5,255
  203ea0:	0307879b          	addiw	a5,a5,48
  203ea4:	0ff7f713          	andi	a4,a5,255
  203ea8:	fc843783          	ld	a5,-56(s0)
  203eac:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  203eb0:	fdf44703          	lbu	a4,-33(s0)
  203eb4:	00a00793          	li	a5,10
  203eb8:	02f777bb          	remuw	a5,a4,a5
  203ebc:	0ff7f713          	andi	a4,a5,255
  203ec0:	fc843783          	ld	a5,-56(s0)
  203ec4:	00178793          	addi	a5,a5,1
  203ec8:	0307071b          	addiw	a4,a4,48
  203ecc:	0ff77713          	andi	a4,a4,255
  203ed0:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  203ed4:	fc843783          	ld	a5,-56(s0)
  203ed8:	00278793          	addi	a5,a5,2
  203edc:	03a00713          	li	a4,58
  203ee0:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  203ee4:	fe043703          	ld	a4,-32(s0)
  203ee8:	000017b7          	lui	a5,0x1
  203eec:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  203ef0:	02f77733          	remu	a4,a4,a5
  203ef4:	03c00793          	li	a5,60
  203ef8:	02f757b3          	divu	a5,a4,a5
  203efc:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  203f00:	fdf44703          	lbu	a4,-33(s0)
  203f04:	00a00793          	li	a5,10
  203f08:	02f757bb          	divuw	a5,a4,a5
  203f0c:	0ff7f713          	andi	a4,a5,255
  203f10:	fc843783          	ld	a5,-56(s0)
  203f14:	00378793          	addi	a5,a5,3
  203f18:	0307071b          	addiw	a4,a4,48
  203f1c:	0ff77713          	andi	a4,a4,255
  203f20:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  203f24:	fdf44703          	lbu	a4,-33(s0)
  203f28:	00a00793          	li	a5,10
  203f2c:	02f777bb          	remuw	a5,a4,a5
  203f30:	0ff7f713          	andi	a4,a5,255
  203f34:	fc843783          	ld	a5,-56(s0)
  203f38:	00478793          	addi	a5,a5,4
  203f3c:	0307071b          	addiw	a4,a4,48
  203f40:	0ff77713          	andi	a4,a4,255
  203f44:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  203f48:	fc843783          	ld	a5,-56(s0)
  203f4c:	00578793          	addi	a5,a5,5
  203f50:	03a00713          	li	a4,58
  203f54:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  203f58:	fe043703          	ld	a4,-32(s0)
  203f5c:	03c00793          	li	a5,60
  203f60:	02f777b3          	remu	a5,a4,a5
  203f64:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  203f68:	fdf44703          	lbu	a4,-33(s0)
  203f6c:	00a00793          	li	a5,10
  203f70:	02f757bb          	divuw	a5,a4,a5
  203f74:	0ff7f713          	andi	a4,a5,255
  203f78:	fc843783          	ld	a5,-56(s0)
  203f7c:	00678793          	addi	a5,a5,6
  203f80:	0307071b          	addiw	a4,a4,48
  203f84:	0ff77713          	andi	a4,a4,255
  203f88:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  203f8c:	fdf44703          	lbu	a4,-33(s0)
  203f90:	00a00793          	li	a5,10
  203f94:	02f777bb          	remuw	a5,a4,a5
  203f98:	0ff7f713          	andi	a4,a5,255
  203f9c:	fc843783          	ld	a5,-56(s0)
  203fa0:	00778793          	addi	a5,a5,7
  203fa4:	0307071b          	addiw	a4,a4,48
  203fa8:	0ff77713          	andi	a4,a4,255
  203fac:	00e78023          	sb	a4,0(a5)
}
  203fb0:	00000013          	nop
  203fb4:	03813403          	ld	s0,56(sp)
  203fb8:	04010113          	addi	sp,sp,64
  203fbc:	00008067          	ret

0000000000203fc0 <get_priority>:
static int _num = 0;
static int _current = -1;



uint8_t get_priority(){
  203fc0:	fe010113          	addi	sp,sp,-32
  203fc4:	00113c23          	sd	ra,24(sp)
  203fc8:	00813823          	sd	s0,16(sp)
  203fcc:	02010413          	addi	s0,sp,32
	struct context* pmycontext = r_mscratch();
  203fd0:	dc9ff0ef          	jal	ra,203d98 <r_mscratch>
  203fd4:	00050793          	mv	a5,a0
  203fd8:	fef43423          	sd	a5,-24(s0)
	return pmycontext->priority;
  203fdc:	fe843783          	ld	a5,-24(s0)
  203fe0:	1007c783          	lbu	a5,256(a5)
}
  203fe4:	00078513          	mv	a0,a5
  203fe8:	01813083          	ld	ra,24(sp)
  203fec:	01013403          	ld	s0,16(sp)
  203ff0:	02010113          	addi	sp,sp,32
  203ff4:	00008067          	ret

0000000000203ff8 <schedule>:

/*
 * implment a simple cycle FIFO schedular
 */
void schedule()
{
  203ff8:	fe010113          	addi	sp,sp,-32
  203ffc:	00113c23          	sd	ra,24(sp)
  204000:	00813823          	sd	s0,16(sp)
  204004:	02010413          	addi	s0,sp,32
	struct context *next = &(ctx_tasks[0]);
  204008:	00006797          	auipc	a5,0x6
  20400c:	65878793          	addi	a5,a5,1624 # 20a660 <ctx_tasks>
  204010:	fef43423          	sd	a5,-24(s0)
	if (next -> flags == 0) return;			//no task controller
  204014:	fe843783          	ld	a5,-24(s0)
  204018:	1017c783          	lbu	a5,257(a5)
  20401c:	00078863          	beqz	a5,20402c <schedule+0x34>
	switch_to(next);
  204020:	fe843503          	ld	a0,-24(s0)
  204024:	950fe0ef          	jal	ra,202174 <switch_to>
  204028:	0080006f          	j	204030 <schedule+0x38>
	if (next -> flags == 0) return;			//no task controller
  20402c:	00000013          	nop
}
  204030:	01813083          	ld	ra,24(sp)
  204034:	01013403          	ld	s0,16(sp)
  204038:	02010113          	addi	sp,sp,32
  20403c:	00008067          	ret

0000000000204040 <task_exit>:

void task_exit(){
  204040:	ff010113          	addi	sp,sp,-16
  204044:	00113423          	sd	ra,8(sp)
  204048:	00813023          	sd	s0,0(sp)
  20404c:	01010413          	addi	s0,sp,16
	_num--;
  204050:	00003797          	auipc	a5,0x3
  204054:	4a878793          	addi	a5,a5,1192 # 2074f8 <_num>
  204058:	0007a783          	lw	a5,0(a5)
  20405c:	fff7879b          	addiw	a5,a5,-1
  204060:	0007871b          	sext.w	a4,a5
  204064:	00003797          	auipc	a5,0x3
  204068:	49478793          	addi	a5,a5,1172 # 2074f8 <_num>
  20406c:	00e7a023          	sw	a4,0(a5)
	call_software_interrupt(SOFTWARE_USER_KILLMYSELF, (uint64_t)&ctx_tasks[0]);
  204070:	00006797          	auipc	a5,0x6
  204074:	5f078793          	addi	a5,a5,1520 # 20a660 <ctx_tasks>
  204078:	00078593          	mv	a1,a5
  20407c:	00400513          	li	a0,4
  204080:	160010ef          	jal	ra,2051e0 <call_software_interrupt>
}
  204084:	00000013          	nop
  204088:	00813083          	ld	ra,8(sp)
  20408c:	00013403          	ld	s0,0(sp)
  204090:	01010113          	addi	sp,sp,16
  204094:	00008067          	ret

0000000000204098 <task_create>:
 * RETURN VALUE
 * 	0: success
 * 	-1: if error occured
 */
int task_create(void (*start_routin)(void* ), void* param, uint8_t priority)
{
  204098:	fc010113          	addi	sp,sp,-64
  20409c:	02113c23          	sd	ra,56(sp)
  2040a0:	02813823          	sd	s0,48(sp)
  2040a4:	04010413          	addi	s0,sp,64
  2040a8:	fca43c23          	sd	a0,-40(s0)
  2040ac:	fcb43823          	sd	a1,-48(s0)
  2040b0:	00060793          	mv	a5,a2
  2040b4:	fcf407a3          	sb	a5,-49(s0)
	if (_num < MAX_TASKS) {
  2040b8:	00003797          	auipc	a5,0x3
  2040bc:	44078793          	addi	a5,a5,1088 # 2074f8 <_num>
  2040c0:	0007a783          	lw	a5,0(a5)
  2040c4:	00078713          	mv	a4,a5
  2040c8:	00900793          	li	a5,9
  2040cc:	1ce7ce63          	blt	a5,a4,2042a8 <task_create+0x210>
		int tmp = 0;
  2040d0:	fe042623          	sw	zero,-20(s0)
		while (ctx_tasks[tmp].flags == 1) tmp = (tmp + 1) % MAX_TASKS;
  2040d4:	0200006f          	j	2040f4 <task_create+0x5c>
  2040d8:	fec42783          	lw	a5,-20(s0)
  2040dc:	0017879b          	addiw	a5,a5,1
  2040e0:	0007879b          	sext.w	a5,a5
  2040e4:	00078713          	mv	a4,a5
  2040e8:	00a00793          	li	a5,10
  2040ec:	02f767bb          	remw	a5,a4,a5
  2040f0:	fef42623          	sw	a5,-20(s0)
  2040f4:	00006697          	auipc	a3,0x6
  2040f8:	56c68693          	addi	a3,a3,1388 # 20a660 <ctx_tasks>
  2040fc:	fec42703          	lw	a4,-20(s0)
  204100:	00070793          	mv	a5,a4
  204104:	00579793          	slli	a5,a5,0x5
  204108:	00e787b3          	add	a5,a5,a4
  20410c:	00379793          	slli	a5,a5,0x3
  204110:	00f687b3          	add	a5,a3,a5
  204114:	1017c783          	lbu	a5,257(a5)
  204118:	00078713          	mv	a4,a5
  20411c:	00100793          	li	a5,1
  204120:	faf70ce3          	beq	a4,a5,2040d8 <task_create+0x40>
		ctx_tasks[tmp].sp = (reg_t) &task_stack[tmp][STACK_SIZE];
  204124:	fec42783          	lw	a5,-20(s0)
  204128:	00178793          	addi	a5,a5,1
  20412c:	00a79713          	slli	a4,a5,0xa
  204130:	00004797          	auipc	a5,0x4
  204134:	d3078793          	addi	a5,a5,-720 # 207e60 <task_stack>
  204138:	00f707b3          	add	a5,a4,a5
  20413c:	00078613          	mv	a2,a5
  204140:	00006697          	auipc	a3,0x6
  204144:	52068693          	addi	a3,a3,1312 # 20a660 <ctx_tasks>
  204148:	fec42703          	lw	a4,-20(s0)
  20414c:	00070793          	mv	a5,a4
  204150:	00579793          	slli	a5,a5,0x5
  204154:	00e787b3          	add	a5,a5,a4
  204158:	00379793          	slli	a5,a5,0x3
  20415c:	00f687b3          	add	a5,a3,a5
  204160:	00c7b423          	sd	a2,8(a5)
		ctx_tasks[tmp].a0 = (reg_t) param;
  204164:	fd043683          	ld	a3,-48(s0)
  204168:	00006617          	auipc	a2,0x6
  20416c:	4f860613          	addi	a2,a2,1272 # 20a660 <ctx_tasks>
  204170:	fec42703          	lw	a4,-20(s0)
  204174:	00070793          	mv	a5,a4
  204178:	00579793          	slli	a5,a5,0x5
  20417c:	00e787b3          	add	a5,a5,a4
  204180:	00379793          	slli	a5,a5,0x3
  204184:	00f607b3          	add	a5,a2,a5
  204188:	04d7b423          	sd	a3,72(a5)
		ctx_tasks[tmp].priority = priority;
  20418c:	00006697          	auipc	a3,0x6
  204190:	4d468693          	addi	a3,a3,1236 # 20a660 <ctx_tasks>
  204194:	fec42703          	lw	a4,-20(s0)
  204198:	00070793          	mv	a5,a4
  20419c:	00579793          	slli	a5,a5,0x5
  2041a0:	00e787b3          	add	a5,a5,a4
  2041a4:	00379793          	slli	a5,a5,0x3
  2041a8:	00f687b3          	add	a5,a3,a5
  2041ac:	fcf44703          	lbu	a4,-49(s0)
  2041b0:	10e78023          	sb	a4,256(a5)
		ctx_tasks[tmp].flags = 1;
  2041b4:	00006697          	auipc	a3,0x6
  2041b8:	4ac68693          	addi	a3,a3,1196 # 20a660 <ctx_tasks>
  2041bc:	fec42703          	lw	a4,-20(s0)
  2041c0:	00070793          	mv	a5,a4
  2041c4:	00579793          	slli	a5,a5,0x5
  2041c8:	00e787b3          	add	a5,a5,a4
  2041cc:	00379793          	slli	a5,a5,0x3
  2041d0:	00f687b3          	add	a5,a3,a5
  2041d4:	00100713          	li	a4,1
  2041d8:	10e780a3          	sb	a4,257(a5)
		ctx_tasks[tmp].mepc = start_routin;
  2041dc:	fd843683          	ld	a3,-40(s0)
  2041e0:	00006617          	auipc	a2,0x6
  2041e4:	48060613          	addi	a2,a2,1152 # 20a660 <ctx_tasks>
  2041e8:	fec42703          	lw	a4,-20(s0)
  2041ec:	00070793          	mv	a5,a4
  2041f0:	00579793          	slli	a5,a5,0x5
  2041f4:	00e787b3          	add	a5,a5,a4
  2041f8:	00379793          	slli	a5,a5,0x3
  2041fc:	00f607b3          	add	a5,a2,a5
  204200:	0ed7bc23          	sd	a3,248(a5)
		#ifdef MYPRINT
		printf("my mepc is %p \n\r", ctx_tasks[tmp].mepc);
  204204:	00006697          	auipc	a3,0x6
  204208:	45c68693          	addi	a3,a3,1116 # 20a660 <ctx_tasks>
  20420c:	fec42703          	lw	a4,-20(s0)
  204210:	00070793          	mv	a5,a4
  204214:	00579793          	slli	a5,a5,0x5
  204218:	00e787b3          	add	a5,a5,a4
  20421c:	00379793          	slli	a5,a5,0x3
  204220:	00f687b3          	add	a5,a3,a5
  204224:	0f87b783          	ld	a5,248(a5)
  204228:	00078593          	mv	a1,a5
  20422c:	00002517          	auipc	a0,0x2
  204230:	21450513          	addi	a0,a0,532 # 206440 <BSS_END+0x720>
  204234:	e3cfe0ef          	jal	ra,202870 <printf>
		#endif
		_num++;
  204238:	00003797          	auipc	a5,0x3
  20423c:	2c078793          	addi	a5,a5,704 # 2074f8 <_num>
  204240:	0007a783          	lw	a5,0(a5)
  204244:	0017879b          	addiw	a5,a5,1
  204248:	0007871b          	sext.w	a4,a5
  20424c:	00003797          	auipc	a5,0x3
  204250:	2ac78793          	addi	a5,a5,684 # 2074f8 <_num>
  204254:	00e7a023          	sw	a4,0(a5)
		if (_num == 1) print_taskcontroller_created();
  204258:	00003797          	auipc	a5,0x3
  20425c:	2a078793          	addi	a5,a5,672 # 2074f8 <_num>
  204260:	0007a783          	lw	a5,0(a5)
  204264:	00078713          	mv	a4,a5
  204268:	00100793          	li	a5,1
  20426c:	00f71663          	bne	a4,a5,204278 <task_create+0x1e0>
  204270:	aadff0ef          	jal	ra,203d1c <print_taskcontroller_created>
  204274:	02c0006f          	j	2042a0 <task_create+0x208>
		else if (priority < _min_priority) _min_priority = priority;//find the best task level
  204278:	00003797          	auipc	a5,0x3
  20427c:	dd078793          	addi	a5,a5,-560 # 207048 <_min_priority>
  204280:	0007c703          	lbu	a4,0(a5)
  204284:	fcf44783          	lbu	a5,-49(s0)
  204288:	0ff7f793          	andi	a5,a5,255
  20428c:	00e7fa63          	bgeu	a5,a4,2042a0 <task_create+0x208>
  204290:	00003797          	auipc	a5,0x3
  204294:	db878793          	addi	a5,a5,-584 # 207048 <_min_priority>
  204298:	fcf44703          	lbu	a4,-49(s0)
  20429c:	00e78023          	sb	a4,0(a5)
		return 0;
  2042a0:	00000793          	li	a5,0
  2042a4:	0080006f          	j	2042ac <task_create+0x214>
	} else {
		return -1;
  2042a8:	fff00793          	li	a5,-1
	}
}
  2042ac:	00078513          	mv	a0,a5
  2042b0:	03813083          	ld	ra,56(sp)
  2042b4:	03013403          	ld	s0,48(sp)
  2042b8:	04010113          	addi	sp,sp,64
  2042bc:	00008067          	ret

00000000002042c0 <task_yield>:
 * DESCRIPTION
 * 	task_yield()  causes the calling task to relinquish the CPU and a new 
 * 	task gets to run.
 */
void task_yield()
{
  2042c0:	ff010113          	addi	sp,sp,-16
  2042c4:	00113423          	sd	ra,8(sp)
  2042c8:	00813023          	sd	s0,0(sp)
  2042cc:	01010413          	addi	s0,sp,16
	schedule();
  2042d0:	d29ff0ef          	jal	ra,203ff8 <schedule>
}
  2042d4:	00000013          	nop
  2042d8:	00813083          	ld	ra,8(sp)
  2042dc:	00013403          	ld	s0,0(sp)
  2042e0:	01010113          	addi	sp,sp,16
  2042e4:	00008067          	ret

00000000002042e8 <task_delay>:
 * a very rough implementaion, just to consume the cpu
 */

#define DELAY 1000
void task_delay(volatile int count)
{
  2042e8:	fe010113          	addi	sp,sp,-32
  2042ec:	00813c23          	sd	s0,24(sp)
  2042f0:	02010413          	addi	s0,sp,32
  2042f4:	00050793          	mv	a5,a0
  2042f8:	fef42623          	sw	a5,-20(s0)
	count *= 50000;
  2042fc:	fec42783          	lw	a5,-20(s0)
  204300:	0007871b          	sext.w	a4,a5
  204304:	0000c7b7          	lui	a5,0xc
  204308:	3507879b          	addiw	a5,a5,848
  20430c:	02f707bb          	mulw	a5,a4,a5
  204310:	0007879b          	sext.w	a5,a5
  204314:	fef42623          	sw	a5,-20(s0)
	while (count--);
  204318:	00000013          	nop
  20431c:	fec42783          	lw	a5,-20(s0)
  204320:	0007879b          	sext.w	a5,a5
  204324:	fff7871b          	addiw	a4,a5,-1
  204328:	0007071b          	sext.w	a4,a4
  20432c:	fee42623          	sw	a4,-20(s0)
  204330:	fe0796e3          	bnez	a5,20431c <task_delay+0x34>
}
  204334:	00000013          	nop
  204338:	01813403          	ld	s0,24(sp)
  20433c:	02010113          	addi	sp,sp,32
  204340:	00008067          	ret

0000000000204344 <kernel_schedule>:

//kernel use this function to switch to task controller
void kernel_schedule(){
  204344:	fe010113          	addi	sp,sp,-32
  204348:	00113c23          	sd	ra,24(sp)
  20434c:	00813823          	sd	s0,16(sp)
  204350:	02010413          	addi	s0,sp,32
	struct context * tmpcontext = &ctx_tasks[0];
  204354:	00006797          	auipc	a5,0x6
  204358:	30c78793          	addi	a5,a5,780 # 20a660 <ctx_tasks>
  20435c:	fef43423          	sd	a5,-24(s0)
	call_software_interrupt(SOFTWARE_KERNEL_SWITCH, (uint64_t)tmpcontext);
  204360:	fe843783          	ld	a5,-24(s0)
  204364:	00078593          	mv	a1,a5
  204368:	00100513          	li	a0,1
  20436c:	675000ef          	jal	ra,2051e0 <call_software_interrupt>
}
  204370:	00000013          	nop
  204374:	01813083          	ld	ra,24(sp)
  204378:	01013403          	ld	s0,16(sp)
  20437c:	02010113          	addi	sp,sp,32
  204380:	00008067          	ret

0000000000204384 <task_controller>:

static void task_controller(void* param){
  204384:	fd010113          	addi	sp,sp,-48
  204388:	02113423          	sd	ra,40(sp)
  20438c:	02813023          	sd	s0,32(sp)
  204390:	03010413          	addi	s0,sp,48
  204394:	fca43c23          	sd	a0,-40(s0)
	static int next_task = 0;
	while (1){
	if (_num <= 1) {
  204398:	00003797          	auipc	a5,0x3
  20439c:	16078793          	addi	a5,a5,352 # 2074f8 <_num>
  2043a0:	0007a783          	lw	a5,0(a5)
  2043a4:	00078713          	mv	a4,a5
  2043a8:	00100793          	li	a5,1
  2043ac:	00e7ca63          	blt	a5,a4,2043c0 <task_controller+0x3c>
		panic("Num of task should be greater than zero!");
  2043b0:	00002517          	auipc	a0,0x2
  2043b4:	0a850513          	addi	a0,a0,168 # 206458 <BSS_END+0x738>
  2043b8:	d28fe0ef          	jal	ra,2028e0 <panic>
		return;
  2043bc:	1780006f          	j	204534 <task_controller+0x1b0>
	}else{
		printf("\033[33mI am task controller!\n\r");
  2043c0:	00002517          	auipc	a0,0x2
  2043c4:	0c850513          	addi	a0,a0,200 # 206488 <BSS_END+0x768>
  2043c8:	ca8fe0ef          	jal	ra,202870 <printf>
		next_task  = next_task % MAX_TASKS + 1;
  2043cc:	00003797          	auipc	a5,0x3
  2043d0:	13078793          	addi	a5,a5,304 # 2074fc <next_task.1200>
  2043d4:	0007a783          	lw	a5,0(a5)
  2043d8:	00078713          	mv	a4,a5
  2043dc:	00a00793          	li	a5,10
  2043e0:	02f767bb          	remw	a5,a4,a5
  2043e4:	0007879b          	sext.w	a5,a5
  2043e8:	0017879b          	addiw	a5,a5,1
  2043ec:	0007871b          	sext.w	a4,a5
  2043f0:	00003797          	auipc	a5,0x3
  2043f4:	10c78793          	addi	a5,a5,268 # 2074fc <next_task.1200>
  2043f8:	00e7a023          	sw	a4,0(a5)
		while ((ctx_tasks[next_task].flags == 0) || (ctx_tasks[next_task].priority != _min_priority)) next_task  = next_task % MAX_TASKS + 1;
  2043fc:	0340006f          	j	204430 <task_controller+0xac>
  204400:	00003797          	auipc	a5,0x3
  204404:	0fc78793          	addi	a5,a5,252 # 2074fc <next_task.1200>
  204408:	0007a783          	lw	a5,0(a5)
  20440c:	00078713          	mv	a4,a5
  204410:	00a00793          	li	a5,10
  204414:	02f767bb          	remw	a5,a4,a5
  204418:	0007879b          	sext.w	a5,a5
  20441c:	0017879b          	addiw	a5,a5,1
  204420:	0007871b          	sext.w	a4,a5
  204424:	00003797          	auipc	a5,0x3
  204428:	0d878793          	addi	a5,a5,216 # 2074fc <next_task.1200>
  20442c:	00e7a023          	sw	a4,0(a5)
  204430:	00003797          	auipc	a5,0x3
  204434:	0cc78793          	addi	a5,a5,204 # 2074fc <next_task.1200>
  204438:	0007a703          	lw	a4,0(a5)
  20443c:	00006697          	auipc	a3,0x6
  204440:	22468693          	addi	a3,a3,548 # 20a660 <ctx_tasks>
  204444:	00070793          	mv	a5,a4
  204448:	00579793          	slli	a5,a5,0x5
  20444c:	00e787b3          	add	a5,a5,a4
  204450:	00379793          	slli	a5,a5,0x3
  204454:	00f687b3          	add	a5,a3,a5
  204458:	1017c783          	lbu	a5,257(a5)
  20445c:	fa0782e3          	beqz	a5,204400 <task_controller+0x7c>
  204460:	00003797          	auipc	a5,0x3
  204464:	09c78793          	addi	a5,a5,156 # 2074fc <next_task.1200>
  204468:	0007a703          	lw	a4,0(a5)
  20446c:	00006697          	auipc	a3,0x6
  204470:	1f468693          	addi	a3,a3,500 # 20a660 <ctx_tasks>
  204474:	00070793          	mv	a5,a4
  204478:	00579793          	slli	a5,a5,0x5
  20447c:	00e787b3          	add	a5,a5,a4
  204480:	00379793          	slli	a5,a5,0x3
  204484:	00f687b3          	add	a5,a3,a5
  204488:	1007c703          	lbu	a4,256(a5)
  20448c:	00003797          	auipc	a5,0x3
  204490:	bbc78793          	addi	a5,a5,-1092 # 207048 <_min_priority>
  204494:	0007c783          	lbu	a5,0(a5)
  204498:	f6f714e3          	bne	a4,a5,204400 <task_controller+0x7c>
		printf("I am goint to switch to %dth task\033[0m\n\r", next_task);
  20449c:	00003797          	auipc	a5,0x3
  2044a0:	06078793          	addi	a5,a5,96 # 2074fc <next_task.1200>
  2044a4:	0007a783          	lw	a5,0(a5)
  2044a8:	00078593          	mv	a1,a5
  2044ac:	00002517          	auipc	a0,0x2
  2044b0:	ffc50513          	addi	a0,a0,-4 # 2064a8 <BSS_END+0x788>
  2044b4:	bbcfe0ef          	jal	ra,202870 <printf>
		#ifdef MYPRINT
		printf("the mepc of next task is %p\n\r", ctx_tasks[next_task].mepc);
  2044b8:	00003797          	auipc	a5,0x3
  2044bc:	04478793          	addi	a5,a5,68 # 2074fc <next_task.1200>
  2044c0:	0007a703          	lw	a4,0(a5)
  2044c4:	00006697          	auipc	a3,0x6
  2044c8:	19c68693          	addi	a3,a3,412 # 20a660 <ctx_tasks>
  2044cc:	00070793          	mv	a5,a4
  2044d0:	00579793          	slli	a5,a5,0x5
  2044d4:	00e787b3          	add	a5,a5,a4
  2044d8:	00379793          	slli	a5,a5,0x3
  2044dc:	00f687b3          	add	a5,a3,a5
  2044e0:	0f87b783          	ld	a5,248(a5)
  2044e4:	00078593          	mv	a1,a5
  2044e8:	00002517          	auipc	a0,0x2
  2044ec:	fe850513          	addi	a0,a0,-24 # 2064d0 <BSS_END+0x7b0>
  2044f0:	b80fe0ef          	jal	ra,202870 <printf>
		#endif
		struct context * tmpcontext = &ctx_tasks[next_task];
  2044f4:	00003797          	auipc	a5,0x3
  2044f8:	00878793          	addi	a5,a5,8 # 2074fc <next_task.1200>
  2044fc:	0007a703          	lw	a4,0(a5)
  204500:	00070793          	mv	a5,a4
  204504:	00579793          	slli	a5,a5,0x5
  204508:	00e787b3          	add	a5,a5,a4
  20450c:	00379793          	slli	a5,a5,0x3
  204510:	00006717          	auipc	a4,0x6
  204514:	15070713          	addi	a4,a4,336 # 20a660 <ctx_tasks>
  204518:	00e787b3          	add	a5,a5,a4
  20451c:	fef43423          	sd	a5,-24(s0)
		printf("\033[1A");
		printf("\033[K");
		printf("\033[1A");
		printf("\033[K");
		#endif
		call_software_interrupt(SOFTWARE_TASK_CONTROLLER_FLAG, (uint64_t)tmpcontext);
  204520:	fe843783          	ld	a5,-24(s0)
  204524:	00078593          	mv	a1,a5
  204528:	00200513          	li	a0,2
  20452c:	4b5000ef          	jal	ra,2051e0 <call_software_interrupt>
	if (_num <= 1) {
  204530:	e69ff06f          	j	204398 <task_controller+0x14>
	}
	}
}
  204534:	02813083          	ld	ra,40(sp)
  204538:	02013403          	ld	s0,32(sp)
  20453c:	03010113          	addi	sp,sp,48
  204540:	00008067          	ret

0000000000204544 <sched_init>:


void sched_init(int slice)
{
  204544:	fd010113          	addi	sp,sp,-48
  204548:	02113423          	sd	ra,40(sp)
  20454c:	02813023          	sd	s0,32(sp)
  204550:	03010413          	addi	s0,sp,48
  204554:	00050793          	mv	a5,a0
  204558:	fcf42e23          	sw	a5,-36(s0)
	TICKS_PER_SLICE = slice;
  20455c:	fdc42703          	lw	a4,-36(s0)
  204560:	00003797          	auipc	a5,0x3
  204564:	ae078793          	addi	a5,a5,-1312 # 207040 <TICKS_PER_SLICE>
  204568:	00e7b023          	sd	a4,0(a5)
	w_mscratch(0);
  20456c:	00000513          	li	a0,0
  204570:	801ff0ef          	jal	ra,203d70 <w_mscratch>
	for (int i=0; i < MAX_TASKS; i++){
  204574:	fe042623          	sw	zero,-20(s0)
  204578:	0340006f          	j	2045ac <sched_init+0x68>
		ctx_tasks[i].flags = 0;
  20457c:	00006697          	auipc	a3,0x6
  204580:	0e468693          	addi	a3,a3,228 # 20a660 <ctx_tasks>
  204584:	fec42703          	lw	a4,-20(s0)
  204588:	00070793          	mv	a5,a4
  20458c:	00579793          	slli	a5,a5,0x5
  204590:	00e787b3          	add	a5,a5,a4
  204594:	00379793          	slli	a5,a5,0x3
  204598:	00f687b3          	add	a5,a3,a5
  20459c:	100780a3          	sb	zero,257(a5)
	for (int i=0; i < MAX_TASKS; i++){
  2045a0:	fec42783          	lw	a5,-20(s0)
  2045a4:	0017879b          	addiw	a5,a5,1
  2045a8:	fef42623          	sw	a5,-20(s0)
  2045ac:	fec42783          	lw	a5,-20(s0)
  2045b0:	0007871b          	sext.w	a4,a5
  2045b4:	00900793          	li	a5,9
  2045b8:	fce7d2e3          	bge	a5,a4,20457c <sched_init+0x38>
	}
	task_create(task_controller, 0, 255);
  2045bc:	0ff00613          	li	a2,255
  2045c0:	00000593          	li	a1,0
  2045c4:	00000517          	auipc	a0,0x0
  2045c8:	dc050513          	addi	a0,a0,-576 # 204384 <task_controller>
  2045cc:	acdff0ef          	jal	ra,204098 <task_create>
	
	/* enable machine-mode software interrupts. */
	w_mie(r_mie() | MIE_MSIE);
  2045d0:	ff0ff0ef          	jal	ra,203dc0 <r_mie>
  2045d4:	00050793          	mv	a5,a0
  2045d8:	0087e793          	ori	a5,a5,8
  2045dc:	00078513          	mv	a0,a5
  2045e0:	809ff0ef          	jal	ra,203de8 <w_mie>

}
  2045e4:	00000013          	nop
  2045e8:	02813083          	ld	ra,40(sp)
  2045ec:	02013403          	ld	s0,32(sp)
  2045f0:	03010113          	addi	sp,sp,48
  2045f4:	00008067          	ret

00000000002045f8 <isChar>:
#include "goish.h"
static char inputbuffer[256];
char goishbuffer[2048] = "";
static uint8_t ibuffer = 0;
static inline uint8_t isChar(char c){
  2045f8:	fe010113          	addi	sp,sp,-32
  2045fc:	00813c23          	sd	s0,24(sp)
  204600:	02010413          	addi	s0,sp,32
  204604:	00050793          	mv	a5,a0
  204608:	fef407a3          	sb	a5,-17(s0)
    if ((c >= 32) && (c <= 126)) return 1;
  20460c:	fef44783          	lbu	a5,-17(s0)
  204610:	0ff7f713          	andi	a4,a5,255
  204614:	01f00793          	li	a5,31
  204618:	00e7fe63          	bgeu	a5,a4,204634 <isChar+0x3c>
  20461c:	fef44783          	lbu	a5,-17(s0)
  204620:	0ff7f713          	andi	a4,a5,255
  204624:	07e00793          	li	a5,126
  204628:	00e7e663          	bltu	a5,a4,204634 <isChar+0x3c>
  20462c:	00100793          	li	a5,1
  204630:	0080006f          	j	204638 <isChar+0x40>
    return 0;
  204634:	00000793          	li	a5,0
}
  204638:	00078513          	mv	a0,a5
  20463c:	01813403          	ld	s0,24(sp)
  204640:	02010113          	addi	sp,sp,32
  204644:	00008067          	ret

0000000000204648 <strcmp>:
static uint8_t strcmp(char* c1, char* c2){
  204648:	fd010113          	addi	sp,sp,-48
  20464c:	02813423          	sd	s0,40(sp)
  204650:	03010413          	addi	s0,sp,48
  204654:	fca43c23          	sd	a0,-40(s0)
  204658:	fcb43823          	sd	a1,-48(s0)
    int i = 0;
  20465c:	fe042623          	sw	zero,-20(s0)
    while (c1[i] * c2[i]){
  204660:	0400006f          	j	2046a0 <strcmp+0x58>
        if (c1[i] != c2[i]) return 0;
  204664:	fec42783          	lw	a5,-20(s0)
  204668:	fd843703          	ld	a4,-40(s0)
  20466c:	00f707b3          	add	a5,a4,a5
  204670:	0007c683          	lbu	a3,0(a5)
  204674:	fec42783          	lw	a5,-20(s0)
  204678:	fd043703          	ld	a4,-48(s0)
  20467c:	00f707b3          	add	a5,a4,a5
  204680:	0007c783          	lbu	a5,0(a5)
  204684:	00068713          	mv	a4,a3
  204688:	00f70663          	beq	a4,a5,204694 <strcmp+0x4c>
  20468c:	00000793          	li	a5,0
  204690:	0780006f          	j	204708 <strcmp+0xc0>
        i ++;
  204694:	fec42783          	lw	a5,-20(s0)
  204698:	0017879b          	addiw	a5,a5,1
  20469c:	fef42623          	sw	a5,-20(s0)
    while (c1[i] * c2[i]){
  2046a0:	fec42783          	lw	a5,-20(s0)
  2046a4:	fd843703          	ld	a4,-40(s0)
  2046a8:	00f707b3          	add	a5,a4,a5
  2046ac:	0007c783          	lbu	a5,0(a5)
  2046b0:	0007871b          	sext.w	a4,a5
  2046b4:	fec42783          	lw	a5,-20(s0)
  2046b8:	fd043683          	ld	a3,-48(s0)
  2046bc:	00f687b3          	add	a5,a3,a5
  2046c0:	0007c783          	lbu	a5,0(a5)
  2046c4:	0007879b          	sext.w	a5,a5
  2046c8:	02f707bb          	mulw	a5,a4,a5
  2046cc:	0007879b          	sext.w	a5,a5
  2046d0:	f8079ae3          	bnez	a5,204664 <strcmp+0x1c>
    }
    if (c1[i] != c2[i]) return 0;
  2046d4:	fec42783          	lw	a5,-20(s0)
  2046d8:	fd843703          	ld	a4,-40(s0)
  2046dc:	00f707b3          	add	a5,a4,a5
  2046e0:	0007c683          	lbu	a3,0(a5)
  2046e4:	fec42783          	lw	a5,-20(s0)
  2046e8:	fd043703          	ld	a4,-48(s0)
  2046ec:	00f707b3          	add	a5,a4,a5
  2046f0:	0007c783          	lbu	a5,0(a5)
  2046f4:	00068713          	mv	a4,a3
  2046f8:	00f70663          	beq	a4,a5,204704 <strcmp+0xbc>
  2046fc:	00000793          	li	a5,0
  204700:	0080006f          	j	204708 <strcmp+0xc0>
    return 1;
  204704:	00100793          	li	a5,1
}
  204708:	00078513          	mv	a0,a5
  20470c:	02813403          	ld	s0,40(sp)
  204710:	03010113          	addi	sp,sp,48
  204714:	00008067          	ret

0000000000204718 <goishfunction>:

static goishfunction(char* str){
  204718:	fe010113          	addi	sp,sp,-32
  20471c:	00113c23          	sd	ra,24(sp)
  204720:	00813823          	sd	s0,16(sp)
  204724:	02010413          	addi	s0,sp,32
  204728:	fea43423          	sd	a0,-24(s0)
    printf("\n\r");
  20472c:	00002517          	auipc	a0,0x2
  204730:	dc450513          	addi	a0,a0,-572 # 2064f0 <BSS_END+0x7d0>
  204734:	93cfe0ef          	jal	ra,202870 <printf>
    if (strcmp(str, "WhoAmI")) print_WhoAmI();
  204738:	00002597          	auipc	a1,0x2
  20473c:	dc058593          	addi	a1,a1,-576 # 2064f8 <BSS_END+0x7d8>
  204740:	fe843503          	ld	a0,-24(s0)
  204744:	f05ff0ef          	jal	ra,204648 <strcmp>
  204748:	00050793          	mv	a5,a0
  20474c:	00078663          	beqz	a5,204758 <goishfunction+0x40>
  204750:	be4ff0ef          	jal	ra,203b34 <print_WhoAmI>
  204754:	00c0006f          	j	204760 <goishfunction+0x48>
    else printf(str);
  204758:	fe843503          	ld	a0,-24(s0)
  20475c:	914fe0ef          	jal	ra,202870 <printf>
    #ifndef MYPRINT
	printf("\033[1A");
    #endif
}
  204760:	00000013          	nop
  204764:	00078513          	mv	a0,a5
  204768:	01813083          	ld	ra,24(sp)
  20476c:	01013403          	ld	s0,16(sp)
  204770:	02010113          	addi	sp,sp,32
  204774:	00008067          	ret

0000000000204778 <addGoishBuffer>:
void addGoishBuffer(char c){
  204778:	fe010113          	addi	sp,sp,-32
  20477c:	00113c23          	sd	ra,24(sp)
  204780:	00813823          	sd	s0,16(sp)
  204784:	02010413          	addi	s0,sp,32
  204788:	00050793          	mv	a5,a0
  20478c:	fef407a3          	sb	a5,-17(s0)
    if (isChar(c)) {
  204790:	fef44783          	lbu	a5,-17(s0)
  204794:	00078513          	mv	a0,a5
  204798:	e61ff0ef          	jal	ra,2045f8 <isChar>
  20479c:	00050793          	mv	a5,a0
  2047a0:	06078663          	beqz	a5,20480c <addGoishBuffer+0x94>
        inputbuffer[ibuffer] = c;
  2047a4:	00003797          	auipc	a5,0x3
  2047a8:	65c78793          	addi	a5,a5,1628 # 207e00 <ibuffer>
  2047ac:	0007c783          	lbu	a5,0(a5)
  2047b0:	0007879b          	sext.w	a5,a5
  2047b4:	00003717          	auipc	a4,0x3
  2047b8:	54c70713          	addi	a4,a4,1356 # 207d00 <inputbuffer>
  2047bc:	00f707b3          	add	a5,a4,a5
  2047c0:	fef44703          	lbu	a4,-17(s0)
  2047c4:	00e78023          	sb	a4,0(a5)
        ibuffer ++;
  2047c8:	00003797          	auipc	a5,0x3
  2047cc:	63878793          	addi	a5,a5,1592 # 207e00 <ibuffer>
  2047d0:	0007c783          	lbu	a5,0(a5)
  2047d4:	0017879b          	addiw	a5,a5,1
  2047d8:	0ff7f713          	andi	a4,a5,255
  2047dc:	00003797          	auipc	a5,0x3
  2047e0:	62478793          	addi	a5,a5,1572 # 207e00 <ibuffer>
  2047e4:	00e78023          	sb	a4,0(a5)
        inputbuffer[ibuffer] = 0;
  2047e8:	00003797          	auipc	a5,0x3
  2047ec:	61878793          	addi	a5,a5,1560 # 207e00 <ibuffer>
  2047f0:	0007c783          	lbu	a5,0(a5)
  2047f4:	0007879b          	sext.w	a5,a5
  2047f8:	00003717          	auipc	a4,0x3
  2047fc:	50870713          	addi	a4,a4,1288 # 207d00 <inputbuffer>
  204800:	00f707b3          	add	a5,a4,a5
  204804:	00078023          	sb	zero,0(a5)
  204808:	2700006f          	j	204a78 <addGoishBuffer+0x300>
    } else {
        switch (c){
  20480c:	fef44783          	lbu	a5,-17(s0)
  204810:	0007879b          	sext.w	a5,a5
  204814:	00078693          	mv	a3,a5
  204818:	00900713          	li	a4,9
  20481c:	24e68863          	beq	a3,a4,204a6c <addGoishBuffer+0x2f4>
  204820:	00078693          	mv	a3,a5
  204824:	00d00713          	li	a4,13
  204828:	06e68263          	beq	a3,a4,20488c <addGoishBuffer+0x114>
  20482c:	00078713          	mv	a4,a5
  204830:	00800793          	li	a5,8
  204834:	08f71a63          	bne	a4,a5,2048c8 <addGoishBuffer+0x150>
            case GOISH_BACKSPACE:
                if (ibuffer > 0){
  204838:	00003797          	auipc	a5,0x3
  20483c:	5c878793          	addi	a5,a5,1480 # 207e00 <ibuffer>
  204840:	0007c783          	lbu	a5,0(a5)
  204844:	22078863          	beqz	a5,204a74 <addGoishBuffer+0x2fc>
                    ibuffer --;
  204848:	00003797          	auipc	a5,0x3
  20484c:	5b878793          	addi	a5,a5,1464 # 207e00 <ibuffer>
  204850:	0007c783          	lbu	a5,0(a5)
  204854:	fff7879b          	addiw	a5,a5,-1
  204858:	0ff7f713          	andi	a4,a5,255
  20485c:	00003797          	auipc	a5,0x3
  204860:	5a478793          	addi	a5,a5,1444 # 207e00 <ibuffer>
  204864:	00e78023          	sb	a4,0(a5)
                    inputbuffer[ibuffer] = 0;
  204868:	00003797          	auipc	a5,0x3
  20486c:	59878793          	addi	a5,a5,1432 # 207e00 <ibuffer>
  204870:	0007c783          	lbu	a5,0(a5)
  204874:	0007879b          	sext.w	a5,a5
  204878:	00003717          	auipc	a4,0x3
  20487c:	48870713          	addi	a4,a4,1160 # 207d00 <inputbuffer>
  204880:	00f707b3          	add	a5,a4,a5
  204884:	00078023          	sb	zero,0(a5)
                }
                break;
  204888:	1ec0006f          	j	204a74 <addGoishBuffer+0x2fc>
            case GOISH_TAB:
                //do something                
                break;
            case GOISH_ENTER:
                goishfunction(inputbuffer);
  20488c:	00003517          	auipc	a0,0x3
  204890:	47450513          	addi	a0,a0,1140 # 207d00 <inputbuffer>
  204894:	e85ff0ef          	jal	ra,204718 <goishfunction>
                //do something
                ibuffer = 0;
  204898:	00003797          	auipc	a5,0x3
  20489c:	56878793          	addi	a5,a5,1384 # 207e00 <ibuffer>
  2048a0:	00078023          	sb	zero,0(a5)
                inputbuffer[ibuffer] = 0;
  2048a4:	00003797          	auipc	a5,0x3
  2048a8:	55c78793          	addi	a5,a5,1372 # 207e00 <ibuffer>
  2048ac:	0007c783          	lbu	a5,0(a5)
  2048b0:	0007879b          	sext.w	a5,a5
  2048b4:	00003717          	auipc	a4,0x3
  2048b8:	44c70713          	addi	a4,a4,1100 # 207d00 <inputbuffer>
  2048bc:	00f707b3          	add	a5,a4,a5
  2048c0:	00078023          	sb	zero,0(a5)
                break;
  2048c4:	1b40006f          	j	204a78 <addGoishBuffer+0x300>
            default:
                inputbuffer[ibuffer] = '^';
  2048c8:	00003797          	auipc	a5,0x3
  2048cc:	53878793          	addi	a5,a5,1336 # 207e00 <ibuffer>
  2048d0:	0007c783          	lbu	a5,0(a5)
  2048d4:	0007879b          	sext.w	a5,a5
  2048d8:	00003717          	auipc	a4,0x3
  2048dc:	42870713          	addi	a4,a4,1064 # 207d00 <inputbuffer>
  2048e0:	00f707b3          	add	a5,a4,a5
  2048e4:	05e00713          	li	a4,94
  2048e8:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  2048ec:	00003797          	auipc	a5,0x3
  2048f0:	51478793          	addi	a5,a5,1300 # 207e00 <ibuffer>
  2048f4:	0007c783          	lbu	a5,0(a5)
  2048f8:	0017879b          	addiw	a5,a5,1
  2048fc:	0ff7f713          	andi	a4,a5,255
  204900:	00003797          	auipc	a5,0x3
  204904:	50078793          	addi	a5,a5,1280 # 207e00 <ibuffer>
  204908:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = (c / 100) + '0';
  20490c:	fef44703          	lbu	a4,-17(s0)
  204910:	06400793          	li	a5,100
  204914:	02f757bb          	divuw	a5,a4,a5
  204918:	0ff7f713          	andi	a4,a5,255
  20491c:	00003797          	auipc	a5,0x3
  204920:	4e478793          	addi	a5,a5,1252 # 207e00 <ibuffer>
  204924:	0007c783          	lbu	a5,0(a5)
  204928:	0007879b          	sext.w	a5,a5
  20492c:	0307071b          	addiw	a4,a4,48
  204930:	0ff77713          	andi	a4,a4,255
  204934:	00003697          	auipc	a3,0x3
  204938:	3cc68693          	addi	a3,a3,972 # 207d00 <inputbuffer>
  20493c:	00f687b3          	add	a5,a3,a5
  204940:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  204944:	00003797          	auipc	a5,0x3
  204948:	4bc78793          	addi	a5,a5,1212 # 207e00 <ibuffer>
  20494c:	0007c783          	lbu	a5,0(a5)
  204950:	0017879b          	addiw	a5,a5,1
  204954:	0ff7f713          	andi	a4,a5,255
  204958:	00003797          	auipc	a5,0x3
  20495c:	4a878793          	addi	a5,a5,1192 # 207e00 <ibuffer>
  204960:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = ((c % 100) / 10) + '0';
  204964:	fef44703          	lbu	a4,-17(s0)
  204968:	06400793          	li	a5,100
  20496c:	02f777bb          	remuw	a5,a4,a5
  204970:	0ff7f793          	andi	a5,a5,255
  204974:	00078713          	mv	a4,a5
  204978:	00a00793          	li	a5,10
  20497c:	02f757bb          	divuw	a5,a4,a5
  204980:	0ff7f713          	andi	a4,a5,255
  204984:	00003797          	auipc	a5,0x3
  204988:	47c78793          	addi	a5,a5,1148 # 207e00 <ibuffer>
  20498c:	0007c783          	lbu	a5,0(a5)
  204990:	0007879b          	sext.w	a5,a5
  204994:	0307071b          	addiw	a4,a4,48
  204998:	0ff77713          	andi	a4,a4,255
  20499c:	00003697          	auipc	a3,0x3
  2049a0:	36468693          	addi	a3,a3,868 # 207d00 <inputbuffer>
  2049a4:	00f687b3          	add	a5,a3,a5
  2049a8:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  2049ac:	00003797          	auipc	a5,0x3
  2049b0:	45478793          	addi	a5,a5,1108 # 207e00 <ibuffer>
  2049b4:	0007c783          	lbu	a5,0(a5)
  2049b8:	0017879b          	addiw	a5,a5,1
  2049bc:	0ff7f713          	andi	a4,a5,255
  2049c0:	00003797          	auipc	a5,0x3
  2049c4:	44078793          	addi	a5,a5,1088 # 207e00 <ibuffer>
  2049c8:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = ((c % 10)) + '0';
  2049cc:	fef44703          	lbu	a4,-17(s0)
  2049d0:	00a00793          	li	a5,10
  2049d4:	02f777bb          	remuw	a5,a4,a5
  2049d8:	0ff7f713          	andi	a4,a5,255
  2049dc:	00003797          	auipc	a5,0x3
  2049e0:	42478793          	addi	a5,a5,1060 # 207e00 <ibuffer>
  2049e4:	0007c783          	lbu	a5,0(a5)
  2049e8:	0007879b          	sext.w	a5,a5
  2049ec:	0307071b          	addiw	a4,a4,48
  2049f0:	0ff77713          	andi	a4,a4,255
  2049f4:	00003697          	auipc	a3,0x3
  2049f8:	30c68693          	addi	a3,a3,780 # 207d00 <inputbuffer>
  2049fc:	00f687b3          	add	a5,a3,a5
  204a00:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  204a04:	00003797          	auipc	a5,0x3
  204a08:	3fc78793          	addi	a5,a5,1020 # 207e00 <ibuffer>
  204a0c:	0007c783          	lbu	a5,0(a5)
  204a10:	0017879b          	addiw	a5,a5,1
  204a14:	0ff7f713          	andi	a4,a5,255
  204a18:	00003797          	auipc	a5,0x3
  204a1c:	3e878793          	addi	a5,a5,1000 # 207e00 <ibuffer>
  204a20:	00e78023          	sb	a4,0(a5)
                inputbuffer[ibuffer] = '^';
  204a24:	00003797          	auipc	a5,0x3
  204a28:	3dc78793          	addi	a5,a5,988 # 207e00 <ibuffer>
  204a2c:	0007c783          	lbu	a5,0(a5)
  204a30:	0007879b          	sext.w	a5,a5
  204a34:	00003717          	auipc	a4,0x3
  204a38:	2cc70713          	addi	a4,a4,716 # 207d00 <inputbuffer>
  204a3c:	00f707b3          	add	a5,a4,a5
  204a40:	05e00713          	li	a4,94
  204a44:	00e78023          	sb	a4,0(a5)
                ibuffer ++;
  204a48:	00003797          	auipc	a5,0x3
  204a4c:	3b878793          	addi	a5,a5,952 # 207e00 <ibuffer>
  204a50:	0007c783          	lbu	a5,0(a5)
  204a54:	0017879b          	addiw	a5,a5,1
  204a58:	0ff7f713          	andi	a4,a5,255
  204a5c:	00003797          	auipc	a5,0x3
  204a60:	3a478793          	addi	a5,a5,932 # 207e00 <ibuffer>
  204a64:	00e78023          	sb	a4,0(a5)
  204a68:	0100006f          	j	204a78 <addGoishBuffer+0x300>
                break;
  204a6c:	00000013          	nop
  204a70:	0080006f          	j	204a78 <addGoishBuffer+0x300>
                break;
  204a74:	00000013          	nop
        }
        
    }
    printf("\033[33m\rgoish>>$\033[0m%s\r", inputbuffer);
  204a78:	00003597          	auipc	a1,0x3
  204a7c:	28858593          	addi	a1,a1,648 # 207d00 <inputbuffer>
  204a80:	00002517          	auipc	a0,0x2
  204a84:	a8050513          	addi	a0,a0,-1408 # 206500 <BSS_END+0x7e0>
  204a88:	de9fd0ef          	jal	ra,202870 <printf>

}
  204a8c:	00000013          	nop
  204a90:	01813083          	ld	ra,24(sp)
  204a94:	01013403          	ld	s0,16(sp)
  204a98:	02010113          	addi	sp,sp,32
  204a9c:	00008067          	ret

0000000000204aa0 <w_mscratch>:
static void w_mscratch(reg_t x){
  204aa0:	fe010113          	addi	sp,sp,-32
  204aa4:	00813c23          	sd	s0,24(sp)
  204aa8:	02010413          	addi	s0,sp,32
  204aac:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  204ab0:	fe843783          	ld	a5,-24(s0)
  204ab4:	34079073          	csrw	mscratch,a5
}
  204ab8:	00000013          	nop
  204abc:	01813403          	ld	s0,24(sp)
  204ac0:	02010113          	addi	sp,sp,32
  204ac4:	00008067          	ret

0000000000204ac8 <r_mscratch>:
static reg_t r_mscratch(){
  204ac8:	fe010113          	addi	sp,sp,-32
  204acc:	00813c23          	sd	s0,24(sp)
  204ad0:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  204ad4:	340027f3          	csrr	a5,mscratch
  204ad8:	fef43423          	sd	a5,-24(s0)
	return ret;
  204adc:	fe843783          	ld	a5,-24(s0)
}
  204ae0:	00078513          	mv	a0,a5
  204ae4:	01813403          	ld	s0,24(sp)
  204ae8:	02010113          	addi	sp,sp,32
  204aec:	00008067          	ret

0000000000204af0 <r_mhartid>:
static inline reg_t r_mhartid(){
  204af0:	fe010113          	addi	sp,sp,-32
  204af4:	00813c23          	sd	s0,24(sp)
  204af8:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mhartid" : "=r" (x) );
  204afc:	f14027f3          	csrr	a5,mhartid
  204b00:	fef43423          	sd	a5,-24(s0)
	return x;
  204b04:	fe843783          	ld	a5,-24(s0)
}
  204b08:	00078513          	mv	a0,a5
  204b0c:	01813403          	ld	s0,24(sp)
  204b10:	02010113          	addi	sp,sp,32
  204b14:	00008067          	ret

0000000000204b18 <r_mstatus>:
static inline reg_t r_mstatus(){
  204b18:	fe010113          	addi	sp,sp,-32
  204b1c:	00813c23          	sd	s0,24(sp)
  204b20:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
  204b24:	300027f3          	csrr	a5,mstatus
  204b28:	fef43423          	sd	a5,-24(s0)
	return x;
  204b2c:	fe843783          	ld	a5,-24(s0)
}
  204b30:	00078513          	mv	a0,a5
  204b34:	01813403          	ld	s0,24(sp)
  204b38:	02010113          	addi	sp,sp,32
  204b3c:	00008067          	ret

0000000000204b40 <w_mstatus>:
static inline void w_mstatus(reg_t x){
  204b40:	fe010113          	addi	sp,sp,-32
  204b44:	00813c23          	sd	s0,24(sp)
  204b48:	02010413          	addi	s0,sp,32
  204b4c:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mstatus, %0" : : "r" (x));
  204b50:	fe843783          	ld	a5,-24(s0)
  204b54:	30079073          	csrw	mstatus,a5
}
  204b58:	00000013          	nop
  204b5c:	01813403          	ld	s0,24(sp)
  204b60:	02010113          	addi	sp,sp,32
  204b64:	00008067          	ret

0000000000204b68 <r_mie>:
{
  204b68:	fe010113          	addi	sp,sp,-32
  204b6c:	00813c23          	sd	s0,24(sp)
  204b70:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  204b74:	304027f3          	csrr	a5,mie
  204b78:	fef43423          	sd	a5,-24(s0)
	return x;
  204b7c:	fe843783          	ld	a5,-24(s0)
}
  204b80:	00078513          	mv	a0,a5
  204b84:	01813403          	ld	s0,24(sp)
  204b88:	02010113          	addi	sp,sp,32
  204b8c:	00008067          	ret

0000000000204b90 <w_mie>:
{
  204b90:	fe010113          	addi	sp,sp,-32
  204b94:	00813c23          	sd	s0,24(sp)
  204b98:	02010413          	addi	s0,sp,32
  204b9c:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mie, %0" : : "r" (x));
  204ba0:	fe843783          	ld	a5,-24(s0)
  204ba4:	30479073          	csrw	mie,a5
}
  204ba8:	00000013          	nop
  204bac:	01813403          	ld	s0,24(sp)
  204bb0:	02010113          	addi	sp,sp,32
  204bb4:	00008067          	ret

0000000000204bb8 <r_time>:
{
	reg_t x;
	asm volatile("csrr %0, mcause" : "=r" (x) );
	return x;
}
static inline reg_t r_time(){
  204bb8:	fe010113          	addi	sp,sp,-32
  204bbc:	00813c23          	sd	s0,24(sp)
  204bc0:	02010413          	addi	s0,sp,32
	reg_t ret;
	asm volatile("csrr %0, time" : "=r" (ret)); 
  204bc4:	c01027f3          	rdtime	a5
  204bc8:	fef43423          	sd	a5,-24(s0)
	return ret;
  204bcc:	fe843783          	ld	a5,-24(s0)
}
  204bd0:	00078513          	mv	a0,a5
  204bd4:	01813403          	ld	s0,24(sp)
  204bd8:	02010113          	addi	sp,sp,32
  204bdc:	00008067          	ret

0000000000204be0 <w_msip>:
static inline void w_msip(int hartid, int x){
  204be0:	fe010113          	addi	sp,sp,-32
  204be4:	00813c23          	sd	s0,24(sp)
  204be8:	02010413          	addi	s0,sp,32
  204bec:	00050793          	mv	a5,a0
  204bf0:	00058713          	mv	a4,a1
  204bf4:	fef42623          	sw	a5,-20(s0)
  204bf8:	00070793          	mv	a5,a4
  204bfc:	fef42423          	sw	a5,-24(s0)
	*(uint32_t*)CLINT_MSIP(hartid) = x;
  204c00:	fec42783          	lw	a5,-20(s0)
  204c04:	0027979b          	slliw	a5,a5,0x2
  204c08:	0007879b          	sext.w	a5,a5
  204c0c:	00078713          	mv	a4,a5
  204c10:	03ff77b7          	lui	a5,0x3ff7
  204c14:	00e79793          	slli	a5,a5,0xe
  204c18:	00f707b3          	add	a5,a4,a5
  204c1c:	00078713          	mv	a4,a5
  204c20:	fe842783          	lw	a5,-24(s0)
  204c24:	00f72023          	sw	a5,0(a4)
}
  204c28:	00000013          	nop
  204c2c:	01813403          	ld	s0,24(sp)
  204c30:	02010113          	addi	sp,sp,32
  204c34:	00008067          	ret

0000000000204c38 <w_mtimecmp>:

static inline reg_t r_mtimecmp(){
	reg_t hartid = r_mhartid();
	return (((uint64_t)*(uint32_t*)CLINT_MTIMECMPH(hartid)) << 32) + ((uint64_t)*(uint32_t*)CLINT_MTIMECMPL(hartid));
}
static inline void w_mtimecmp(reg_t timecmp){
  204c38:	fd010113          	addi	sp,sp,-48
  204c3c:	02113423          	sd	ra,40(sp)
  204c40:	02813023          	sd	s0,32(sp)
  204c44:	03010413          	addi	s0,sp,48
  204c48:	fca43c23          	sd	a0,-40(s0)
	reg_t hartid = r_mhartid();
  204c4c:	ea5ff0ef          	jal	ra,204af0 <r_mhartid>
  204c50:	fea43423          	sd	a0,-24(s0)
	*(uint32_t*)CLINT_MTIMECMPH(hartid) = ((timecmp >> 32) & 0xffffffff);
  204c54:	fd843783          	ld	a5,-40(s0)
  204c58:	0207d693          	srli	a3,a5,0x20
  204c5c:	fe843703          	ld	a4,-24(s0)
  204c60:	03ff77b7          	lui	a5,0x3ff7
  204c64:	00178793          	addi	a5,a5,1 # 3ff7001 <_bss_end+0x3debf51>
  204c68:	00b79793          	slli	a5,a5,0xb
  204c6c:	00f707b3          	add	a5,a4,a5
  204c70:	00379793          	slli	a5,a5,0x3
  204c74:	00478793          	addi	a5,a5,4
  204c78:	00078713          	mv	a4,a5
  204c7c:	0006879b          	sext.w	a5,a3
  204c80:	00f72023          	sw	a5,0(a4)
	*(uint32_t*)CLINT_MTIMECMPL(hartid) = (timecmp & 0xffffffff);
  204c84:	fe843703          	ld	a4,-24(s0)
  204c88:	03ff77b7          	lui	a5,0x3ff7
  204c8c:	00178793          	addi	a5,a5,1 # 3ff7001 <_bss_end+0x3debf51>
  204c90:	00b79793          	slli	a5,a5,0xb
  204c94:	00f707b3          	add	a5,a4,a5
  204c98:	00379793          	slli	a5,a5,0x3
  204c9c:	00078713          	mv	a4,a5
  204ca0:	fd843783          	ld	a5,-40(s0)
  204ca4:	0007879b          	sext.w	a5,a5
  204ca8:	00f72023          	sw	a5,0(a4)
}
  204cac:	00000013          	nop
  204cb0:	02813083          	ld	ra,40(sp)
  204cb4:	02013403          	ld	s0,32(sp)
  204cb8:	03010113          	addi	sp,sp,48
  204cbc:	00008067          	ret

0000000000204cc0 <get_time>:
static uint64_t get_time(){
  204cc0:	ff010113          	addi	sp,sp,-16
  204cc4:	00813423          	sd	s0,8(sp)
  204cc8:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  204ccc:	00003797          	auipc	a5,0x3
  204cd0:	13c78793          	addi	a5,a5,316 # 207e08 <_tick>
  204cd4:	0007b703          	ld	a4,0(a5)
  204cd8:	03c00793          	li	a5,60
  204cdc:	02f757b3          	divu	a5,a4,a5
}
  204ce0:	00078513          	mv	a0,a5
  204ce4:	00813403          	ld	s0,8(sp)
  204ce8:	01010113          	addi	sp,sp,16
  204cec:	00008067          	ret

0000000000204cf0 <get_time_str>:
static void get_time_str(char* time){
  204cf0:	fc010113          	addi	sp,sp,-64
  204cf4:	02813c23          	sd	s0,56(sp)
  204cf8:	04010413          	addi	s0,sp,64
  204cfc:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  204d00:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  204d04:	00003797          	auipc	a5,0x3
  204d08:	10478793          	addi	a5,a5,260 # 207e08 <_tick>
  204d0c:	0007b703          	ld	a4,0(a5)
  204d10:	03c00793          	li	a5,60
  204d14:	02f757b3          	divu	a5,a4,a5
  204d18:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  204d1c:	fe043703          	ld	a4,-32(s0)
  204d20:	000017b7          	lui	a5,0x1
  204d24:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  204d28:	02f757b3          	divu	a5,a4,a5
  204d2c:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  204d30:	fdf44703          	lbu	a4,-33(s0)
  204d34:	06400793          	li	a5,100
  204d38:	02f777bb          	remuw	a5,a4,a5
  204d3c:	0ff7f793          	andi	a5,a5,255
  204d40:	00078713          	mv	a4,a5
  204d44:	00a00793          	li	a5,10
  204d48:	02f757bb          	divuw	a5,a4,a5
  204d4c:	0ff7f793          	andi	a5,a5,255
  204d50:	0307879b          	addiw	a5,a5,48
  204d54:	0ff7f713          	andi	a4,a5,255
  204d58:	fc843783          	ld	a5,-56(s0)
  204d5c:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  204d60:	fdf44703          	lbu	a4,-33(s0)
  204d64:	00a00793          	li	a5,10
  204d68:	02f777bb          	remuw	a5,a4,a5
  204d6c:	0ff7f713          	andi	a4,a5,255
  204d70:	fc843783          	ld	a5,-56(s0)
  204d74:	00178793          	addi	a5,a5,1
  204d78:	0307071b          	addiw	a4,a4,48
  204d7c:	0ff77713          	andi	a4,a4,255
  204d80:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  204d84:	fc843783          	ld	a5,-56(s0)
  204d88:	00278793          	addi	a5,a5,2
  204d8c:	03a00713          	li	a4,58
  204d90:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  204d94:	fe043703          	ld	a4,-32(s0)
  204d98:	000017b7          	lui	a5,0x1
  204d9c:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  204da0:	02f77733          	remu	a4,a4,a5
  204da4:	03c00793          	li	a5,60
  204da8:	02f757b3          	divu	a5,a4,a5
  204dac:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  204db0:	fdf44703          	lbu	a4,-33(s0)
  204db4:	00a00793          	li	a5,10
  204db8:	02f757bb          	divuw	a5,a4,a5
  204dbc:	0ff7f713          	andi	a4,a5,255
  204dc0:	fc843783          	ld	a5,-56(s0)
  204dc4:	00378793          	addi	a5,a5,3
  204dc8:	0307071b          	addiw	a4,a4,48
  204dcc:	0ff77713          	andi	a4,a4,255
  204dd0:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  204dd4:	fdf44703          	lbu	a4,-33(s0)
  204dd8:	00a00793          	li	a5,10
  204ddc:	02f777bb          	remuw	a5,a4,a5
  204de0:	0ff7f713          	andi	a4,a5,255
  204de4:	fc843783          	ld	a5,-56(s0)
  204de8:	00478793          	addi	a5,a5,4
  204dec:	0307071b          	addiw	a4,a4,48
  204df0:	0ff77713          	andi	a4,a4,255
  204df4:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  204df8:	fc843783          	ld	a5,-56(s0)
  204dfc:	00578793          	addi	a5,a5,5
  204e00:	03a00713          	li	a4,58
  204e04:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  204e08:	fe043703          	ld	a4,-32(s0)
  204e0c:	03c00793          	li	a5,60
  204e10:	02f777b3          	remu	a5,a4,a5
  204e14:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  204e18:	fdf44703          	lbu	a4,-33(s0)
  204e1c:	00a00793          	li	a5,10
  204e20:	02f757bb          	divuw	a5,a4,a5
  204e24:	0ff7f713          	andi	a4,a5,255
  204e28:	fc843783          	ld	a5,-56(s0)
  204e2c:	00678793          	addi	a5,a5,6
  204e30:	0307071b          	addiw	a4,a4,48
  204e34:	0ff77713          	andi	a4,a4,255
  204e38:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  204e3c:	fdf44703          	lbu	a4,-33(s0)
  204e40:	00a00793          	li	a5,10
  204e44:	02f777bb          	remuw	a5,a4,a5
  204e48:	0ff7f713          	andi	a4,a5,255
  204e4c:	fc843783          	ld	a5,-56(s0)
  204e50:	00778793          	addi	a5,a5,7
  204e54:	0307071b          	addiw	a4,a4,48
  204e58:	0ff77713          	andi	a4,a4,255
  204e5c:	00e78023          	sb	a4,0(a5)
}
  204e60:	00000013          	nop
  204e64:	03813403          	ld	s0,56(sp)
  204e68:	04010113          	addi	sp,sp,64
  204e6c:	00008067          	ret

0000000000204e70 <timer_load>:
#include "timer.h"

extern void switch_to(struct context *next);
/* load timer interval(in ticks) for next timer interrupt.*/
void timer_load(int interval)
{
  204e70:	fd010113          	addi	sp,sp,-48
  204e74:	02113423          	sd	ra,40(sp)
  204e78:	02813023          	sd	s0,32(sp)
  204e7c:	03010413          	addi	s0,sp,48
  204e80:	00050793          	mv	a5,a0
  204e84:	fcf42e23          	sw	a5,-36(s0)
	/* each CPU has a separate source of timer interrupts. */
	int id = r_mhartid();
  204e88:	c69ff0ef          	jal	ra,204af0 <r_mhartid>
  204e8c:	00050793          	mv	a5,a0
  204e90:	fef42623          	sw	a5,-20(s0)
    reg_t MTIME = r_time();
  204e94:	d25ff0ef          	jal	ra,204bb8 <r_time>
  204e98:	fea43023          	sd	a0,-32(s0)
	w_mtimecmp(MTIME + interval);
  204e9c:	fdc42703          	lw	a4,-36(s0)
  204ea0:	fe043783          	ld	a5,-32(s0)
  204ea4:	00f707b3          	add	a5,a4,a5
  204ea8:	00078513          	mv	a0,a5
  204eac:	d8dff0ef          	jal	ra,204c38 <w_mtimecmp>
	}
  204eb0:	00000013          	nop
  204eb4:	02813083          	ld	ra,40(sp)
  204eb8:	02013403          	ld	s0,32(sp)
  204ebc:	03010113          	addi	sp,sp,48
  204ec0:	00008067          	ret

0000000000204ec4 <timer_init>:

void timer_init()
{
  204ec4:	ff010113          	addi	sp,sp,-16
  204ec8:	00113423          	sd	ra,8(sp)
  204ecc:	00813023          	sd	s0,0(sp)
  204ed0:	01010413          	addi	s0,sp,16
	/*
	 * On reset, mtime is cleared to zero, but the mtimecmp registers 
	 * are not reset. So we have to init the mtimecmp manually.
	 */
	timer_load(TIMER_INTERVAL);
  204ed4:	0000c7b7          	lui	a5,0xc
  204ed8:	35078513          	addi	a0,a5,848 # c350 <STACK_SIZE+0xbf50>
  204edc:	f95ff0ef          	jal	ra,204e70 <timer_load>

	/* enable machine-mode timer interrupts. */
	w_mie(r_mie() | MIE_MTIE);
  204ee0:	c89ff0ef          	jal	ra,204b68 <r_mie>
  204ee4:	00050793          	mv	a5,a0
  204ee8:	0807e793          	ori	a5,a5,128
  204eec:	00078513          	mv	a0,a5
  204ef0:	ca1ff0ef          	jal	ra,204b90 <w_mie>

	/* enable machine-mode global interrupts. */
	w_mstatus(r_mstatus() | MSTATUS_MIE);
  204ef4:	c25ff0ef          	jal	ra,204b18 <r_mstatus>
  204ef8:	00050793          	mv	a5,a0
  204efc:	0087e793          	ori	a5,a5,8
  204f00:	00078513          	mv	a0,a5
  204f04:	c3dff0ef          	jal	ra,204b40 <w_mstatus>
	printf("timer init!!\n\r");
  204f08:	00001517          	auipc	a0,0x1
  204f0c:	61050513          	addi	a0,a0,1552 # 206518 <BSS_END+0x7f8>
  204f10:	961fd0ef          	jal	ra,202870 <printf>
}
  204f14:	00000013          	nop
  204f18:	00813083          	ld	ra,8(sp)
  204f1c:	00013403          	ld	s0,0(sp)
  204f20:	01010113          	addi	sp,sp,16
  204f24:	00008067          	ret

0000000000204f28 <timer_handler>:

void timer_handler() 
{
  204f28:	fe010113          	addi	sp,sp,-32
  204f2c:	00113c23          	sd	ra,24(sp)
  204f30:	00813823          	sd	s0,16(sp)
  204f34:	02010413          	addi	s0,sp,32
	_tick++;
  204f38:	00003797          	auipc	a5,0x3
  204f3c:	ed078793          	addi	a5,a5,-304 # 207e08 <_tick>
  204f40:	0007b783          	ld	a5,0(a5)
  204f44:	00178713          	addi	a4,a5,1
  204f48:	00003797          	auipc	a5,0x3
  204f4c:	ec078793          	addi	a5,a5,-320 # 207e08 <_tick>
  204f50:	00e7b023          	sd	a4,0(a5)
	_slice++;
  204f54:	00003797          	auipc	a5,0x3
  204f58:	ebc78793          	addi	a5,a5,-324 # 207e10 <_slice>
  204f5c:	0007b783          	ld	a5,0(a5)
  204f60:	00178713          	addi	a4,a5,1
  204f64:	00003797          	auipc	a5,0x3
  204f68:	eac78793          	addi	a5,a5,-340 # 207e10 <_slice>
  204f6c:	00e7b023          	sd	a4,0(a5)
    // #ifdef MYPRINT
	// printf("tick: %d\n\r", _tick);
    // #endif

	timer_load(TIMER_INTERVAL);
  204f70:	0000c7b7          	lui	a5,0xc
  204f74:	35078513          	addi	a0,a5,848 # c350 <STACK_SIZE+0xbf50>
  204f78:	ef9ff0ef          	jal	ra,204e70 <timer_load>
	char timestr[9];
	get_time_str(timestr);
  204f7c:	fe040793          	addi	a5,s0,-32
  204f80:	00078513          	mv	a0,a5
  204f84:	d6dff0ef          	jal	ra,204cf0 <get_time_str>
	timestr[8] = 0;
  204f88:	fe040423          	sb	zero,-24(s0)
    #ifdef MYPRINT
	//printf("%s\n\r", timestr);
    #endif
	if (_slice == TICKS_PER_SLICE){
  204f8c:	00003797          	auipc	a5,0x3
  204f90:	e8478793          	addi	a5,a5,-380 # 207e10 <_slice>
  204f94:	0007b703          	ld	a4,0(a5)
  204f98:	00002797          	auipc	a5,0x2
  204f9c:	0c078793          	addi	a5,a5,192 # 207058 <TICKS_PER_SLICE>
  204fa0:	0007b783          	ld	a5,0(a5)
  204fa4:	00f71a63          	bne	a4,a5,204fb8 <timer_handler+0x90>
		_slice = 0;
  204fa8:	00003797          	auipc	a5,0x3
  204fac:	e6878793          	addi	a5,a5,-408 # 207e10 <_slice>
  204fb0:	0007b023          	sd	zero,0(a5)
		schedule();
  204fb4:	844ff0ef          	jal	ra,203ff8 <schedule>
	}
}
  204fb8:	00000013          	nop
  204fbc:	01813083          	ld	ra,24(sp)
  204fc0:	01013403          	ld	s0,16(sp)
  204fc4:	02010113          	addi	sp,sp,32
  204fc8:	00008067          	ret

0000000000204fcc <software_handler>:


void software_handler(){
  204fcc:	fd010113          	addi	sp,sp,-48
  204fd0:	02113423          	sd	ra,40(sp)
  204fd4:	02813023          	sd	s0,32(sp)
  204fd8:	03010413          	addi	s0,sp,48
	uint8_t flag = software_interrupt_flag;
  204fdc:	00003797          	auipc	a5,0x3
  204fe0:	e3c78793          	addi	a5,a5,-452 # 207e18 <software_interrupt_flag>
  204fe4:	0007c783          	lbu	a5,0(a5)
  204fe8:	fef405a3          	sb	a5,-21(s0)
	uint64_t arg = software_interrupt_arg;
  204fec:	00003797          	auipc	a5,0x3
  204ff0:	e3478793          	addi	a5,a5,-460 # 207e20 <software_interrupt_arg>
  204ff4:	0007b783          	ld	a5,0(a5)
  204ff8:	fef43023          	sd	a5,-32(s0)
	reset_software_interrupt();
  204ffc:	250000ef          	jal	ra,20524c <reset_software_interrupt>
	struct context* pmycontext = r_mscratch();
  205000:	ac9ff0ef          	jal	ra,204ac8 <r_mscratch>
  205004:	00050793          	mv	a5,a0
  205008:	fcf43c23          	sd	a5,-40(s0)
	switch(flag){
  20500c:	feb44783          	lbu	a5,-21(s0)
  205010:	0007879b          	sext.w	a5,a5
  205014:	00078693          	mv	a3,a5
  205018:	00400713          	li	a4,4
  20501c:	1ad76063          	bltu	a4,a3,2051bc <software_handler+0x1f0>
  205020:	00279713          	slli	a4,a5,0x2
  205024:	00001797          	auipc	a5,0x1
  205028:	59c78793          	addi	a5,a5,1436 # 2065c0 <BSS_END+0x8a0>
  20502c:	00f707b3          	add	a5,a4,a5
  205030:	0007a783          	lw	a5,0(a5)
  205034:	0007871b          	sext.w	a4,a5
  205038:	00001797          	auipc	a5,0x1
  20503c:	58878793          	addi	a5,a5,1416 # 2065c0 <BSS_END+0x8a0>
  205040:	00f707b3          	add	a5,a4,a5
  205044:	00078067          	jr	a5
		case SOFTWARE_NOTHING:
			printf("nothing happend\n\r");
  205048:	00001517          	auipc	a0,0x1
  20504c:	4e050513          	addi	a0,a0,1248 # 206528 <BSS_END+0x808>
  205050:	821fd0ef          	jal	ra,202870 <printf>
			break;
  205054:	1780006f          	j	2051cc <software_handler+0x200>
		case SOFTWARE_KERNEL_SWITCH:
			#ifdef MYPRINT
			printf("kernel switch to task controller\n\r");
  205058:	00001517          	auipc	a0,0x1
  20505c:	4e850513          	addi	a0,a0,1256 # 206540 <BSS_END+0x820>
  205060:	811fd0ef          	jal	ra,202870 <printf>
			printf("arg%p\n\r", arg);
  205064:	fe043583          	ld	a1,-32(s0)
  205068:	00001517          	auipc	a0,0x1
  20506c:	50050513          	addi	a0,a0,1280 # 206568 <BSS_END+0x848>
  205070:	801fd0ef          	jal	ra,202870 <printf>
			#endif
			_slice = 0;
  205074:	00003797          	auipc	a5,0x3
  205078:	d9c78793          	addi	a5,a5,-612 # 207e10 <_slice>
  20507c:	0007b023          	sd	zero,0(a5)
			schedule();
  205080:	f79fe0ef          	jal	ra,203ff8 <schedule>
			break;
  205084:	1480006f          	j	2051cc <software_handler+0x200>
		case SOFTWARE_TASK_CONTROLLER_FLAG:
			//printf("task controller calling\n\r");
			switch_to((uint64_t) arg);
  205088:	fe043783          	ld	a5,-32(s0)
  20508c:	00078513          	mv	a0,a5
  205090:	8e4fd0ef          	jal	ra,202174 <switch_to>
			break;
  205094:	1380006f          	j	2051cc <software_handler+0x200>
		case SOFTWARE_USER_SWITCH_FLAG:
			printf("user want to switch\n\r");
  205098:	00001517          	auipc	a0,0x1
  20509c:	4d850513          	addi	a0,a0,1240 # 206570 <BSS_END+0x850>
  2050a0:	fd0fd0ef          	jal	ra,202870 <printf>
			_slice = 0;
  2050a4:	00003797          	auipc	a5,0x3
  2050a8:	d6c78793          	addi	a5,a5,-660 # 207e10 <_slice>
  2050ac:	0007b023          	sd	zero,0(a5)
			schedule();
  2050b0:	f49fe0ef          	jal	ra,203ff8 <schedule>
			break;
  2050b4:	1180006f          	j	2051cc <software_handler+0x200>
		case SOFTWARE_USER_KILLMYSELF:
			pmycontext->flags = 0;
  2050b8:	fd843783          	ld	a5,-40(s0)
  2050bc:	100780a3          	sb	zero,257(a5)
			_min_priority = 255;
  2050c0:	00002797          	auipc	a5,0x2
  2050c4:	f9078793          	addi	a5,a5,-112 # 207050 <_min_priority>
  2050c8:	fff00713          	li	a4,-1
  2050cc:	00e78023          	sb	a4,0(a5)
			for (int i=0; i < MAX_TASKS; i++){
  2050d0:	fe042623          	sw	zero,-20(s0)
  2050d4:	0a40006f          	j	205178 <software_handler+0x1ac>
				if ((ctx_tasks[i].flags == 1) && (ctx_tasks[i].priority < _min_priority))	_min_priority = ctx_tasks[i].priority;
  2050d8:	00005697          	auipc	a3,0x5
  2050dc:	58868693          	addi	a3,a3,1416 # 20a660 <ctx_tasks>
  2050e0:	fec42703          	lw	a4,-20(s0)
  2050e4:	00070793          	mv	a5,a4
  2050e8:	00579793          	slli	a5,a5,0x5
  2050ec:	00e787b3          	add	a5,a5,a4
  2050f0:	00379793          	slli	a5,a5,0x3
  2050f4:	00f687b3          	add	a5,a3,a5
  2050f8:	1017c783          	lbu	a5,257(a5)
  2050fc:	00078713          	mv	a4,a5
  205100:	00100793          	li	a5,1
  205104:	06f71463          	bne	a4,a5,20516c <software_handler+0x1a0>
  205108:	00005697          	auipc	a3,0x5
  20510c:	55868693          	addi	a3,a3,1368 # 20a660 <ctx_tasks>
  205110:	fec42703          	lw	a4,-20(s0)
  205114:	00070793          	mv	a5,a4
  205118:	00579793          	slli	a5,a5,0x5
  20511c:	00e787b3          	add	a5,a5,a4
  205120:	00379793          	slli	a5,a5,0x3
  205124:	00f687b3          	add	a5,a3,a5
  205128:	1007c703          	lbu	a4,256(a5)
  20512c:	00002797          	auipc	a5,0x2
  205130:	f2478793          	addi	a5,a5,-220 # 207050 <_min_priority>
  205134:	0007c783          	lbu	a5,0(a5)
  205138:	02f77a63          	bgeu	a4,a5,20516c <software_handler+0x1a0>
  20513c:	00005697          	auipc	a3,0x5
  205140:	52468693          	addi	a3,a3,1316 # 20a660 <ctx_tasks>
  205144:	fec42703          	lw	a4,-20(s0)
  205148:	00070793          	mv	a5,a4
  20514c:	00579793          	slli	a5,a5,0x5
  205150:	00e787b3          	add	a5,a5,a4
  205154:	00379793          	slli	a5,a5,0x3
  205158:	00f687b3          	add	a5,a3,a5
  20515c:	1007c703          	lbu	a4,256(a5)
  205160:	00002797          	auipc	a5,0x2
  205164:	ef078793          	addi	a5,a5,-272 # 207050 <_min_priority>
  205168:	00e78023          	sb	a4,0(a5)
			for (int i=0; i < MAX_TASKS; i++){
  20516c:	fec42783          	lw	a5,-20(s0)
  205170:	0017879b          	addiw	a5,a5,1
  205174:	fef42623          	sw	a5,-20(s0)
  205178:	fec42783          	lw	a5,-20(s0)
  20517c:	0007871b          	sext.w	a4,a5
  205180:	00900793          	li	a5,9
  205184:	f4e7dae3          	bge	a5,a4,2050d8 <software_handler+0x10c>
			}
			#ifdef MYPRINT
			printf("new priority:%d\n\r", _min_priority);
  205188:	00002797          	auipc	a5,0x2
  20518c:	ec878793          	addi	a5,a5,-312 # 207050 <_min_priority>
  205190:	0007c783          	lbu	a5,0(a5)
  205194:	0007879b          	sext.w	a5,a5
  205198:	00078593          	mv	a1,a5
  20519c:	00001517          	auipc	a0,0x1
  2051a0:	3ec50513          	addi	a0,a0,1004 # 206588 <BSS_END+0x868>
  2051a4:	eccfd0ef          	jal	ra,202870 <printf>
			#endif
			_slice = 0;
  2051a8:	00003797          	auipc	a5,0x3
  2051ac:	c6878793          	addi	a5,a5,-920 # 207e10 <_slice>
  2051b0:	0007b023          	sd	zero,0(a5)
			schedule();
  2051b4:	e45fe0ef          	jal	ra,203ff8 <schedule>
			break;
  2051b8:	0140006f          	j	2051cc <software_handler+0x200>
		default:
			printf("UNKNOWN SOFTWARE INTERRUPT!!\n\r");
  2051bc:	00001517          	auipc	a0,0x1
  2051c0:	3e450513          	addi	a0,a0,996 # 2065a0 <BSS_END+0x880>
  2051c4:	eacfd0ef          	jal	ra,202870 <printf>
			break;
  2051c8:	00000013          	nop
	}
}
  2051cc:	00000013          	nop
  2051d0:	02813083          	ld	ra,40(sp)
  2051d4:	02013403          	ld	s0,32(sp)
  2051d8:	03010113          	addi	sp,sp,48
  2051dc:	00008067          	ret

00000000002051e0 <call_software_interrupt>:


void call_software_interrupt(uint8_t flag, uint64_t arg){
  2051e0:	fd010113          	addi	sp,sp,-48
  2051e4:	02113423          	sd	ra,40(sp)
  2051e8:	02813023          	sd	s0,32(sp)
  2051ec:	03010413          	addi	s0,sp,48
  2051f0:	00050793          	mv	a5,a0
  2051f4:	fcb43823          	sd	a1,-48(s0)
  2051f8:	fcf40fa3          	sb	a5,-33(s0)
	software_interrupt_flag = flag;
  2051fc:	00003797          	auipc	a5,0x3
  205200:	c1c78793          	addi	a5,a5,-996 # 207e18 <software_interrupt_flag>
  205204:	fdf44703          	lbu	a4,-33(s0)
  205208:	00e78023          	sb	a4,0(a5)
	software_interrupt_arg = arg;
  20520c:	00003797          	auipc	a5,0x3
  205210:	c1478793          	addi	a5,a5,-1004 # 207e20 <software_interrupt_arg>
  205214:	fd043703          	ld	a4,-48(s0)
  205218:	00e7b023          	sd	a4,0(a5)
	reg_t hartid = r_mhartid();
  20521c:	8d5ff0ef          	jal	ra,204af0 <r_mhartid>
  205220:	fea43423          	sd	a0,-24(s0)
	w_msip(hartid, 1);
  205224:	fe843783          	ld	a5,-24(s0)
  205228:	0007879b          	sext.w	a5,a5
  20522c:	00100593          	li	a1,1
  205230:	00078513          	mv	a0,a5
  205234:	9adff0ef          	jal	ra,204be0 <w_msip>
}
  205238:	00000013          	nop
  20523c:	02813083          	ld	ra,40(sp)
  205240:	02013403          	ld	s0,32(sp)
  205244:	03010113          	addi	sp,sp,48
  205248:	00008067          	ret

000000000020524c <reset_software_interrupt>:
void reset_software_interrupt(){
  20524c:	fe010113          	addi	sp,sp,-32
  205250:	00113c23          	sd	ra,24(sp)
  205254:	00813823          	sd	s0,16(sp)
  205258:	02010413          	addi	s0,sp,32
	software_interrupt_flag = 0;
  20525c:	00003797          	auipc	a5,0x3
  205260:	bbc78793          	addi	a5,a5,-1092 # 207e18 <software_interrupt_flag>
  205264:	00078023          	sb	zero,0(a5)
	software_interrupt_arg = 0;
  205268:	00003797          	auipc	a5,0x3
  20526c:	bb878793          	addi	a5,a5,-1096 # 207e20 <software_interrupt_arg>
  205270:	0007b023          	sd	zero,0(a5)
	reg_t hartid = r_mhartid();
  205274:	87dff0ef          	jal	ra,204af0 <r_mhartid>
  205278:	fea43423          	sd	a0,-24(s0)
	w_msip(hartid, 0);
  20527c:	fe843783          	ld	a5,-24(s0)
  205280:	0007879b          	sext.w	a5,a5
  205284:	00000593          	li	a1,0
  205288:	00078513          	mv	a0,a5
  20528c:	955ff0ef          	jal	ra,204be0 <w_msip>
}
  205290:	00000013          	nop
  205294:	01813083          	ld	ra,24(sp)
  205298:	01013403          	ld	s0,16(sp)
  20529c:	02010113          	addi	sp,sp,32
  2052a0:	00008067          	ret

00000000002052a4 <_clear>:
struct Page {
	uint8_t flags;
};

static inline void _clear(struct Page *page)
{
  2052a4:	fe010113          	addi	sp,sp,-32
  2052a8:	00813c23          	sd	s0,24(sp)
  2052ac:	02010413          	addi	s0,sp,32
  2052b0:	fea43423          	sd	a0,-24(s0)
	page->flags = 0;
  2052b4:	fe843783          	ld	a5,-24(s0)
  2052b8:	00078023          	sb	zero,0(a5)
}
  2052bc:	00000013          	nop
  2052c0:	01813403          	ld	s0,24(sp)
  2052c4:	02010113          	addi	sp,sp,32
  2052c8:	00008067          	ret

00000000002052cc <_is_free>:

static inline int _is_free(struct Page *page)
{
  2052cc:	fe010113          	addi	sp,sp,-32
  2052d0:	00813c23          	sd	s0,24(sp)
  2052d4:	02010413          	addi	s0,sp,32
  2052d8:	fea43423          	sd	a0,-24(s0)
	if (page->flags & PAGE_TAKEN) {
  2052dc:	fe843783          	ld	a5,-24(s0)
  2052e0:	0007c783          	lbu	a5,0(a5)
  2052e4:	0007879b          	sext.w	a5,a5
  2052e8:	0017f793          	andi	a5,a5,1
  2052ec:	0007879b          	sext.w	a5,a5
  2052f0:	00078663          	beqz	a5,2052fc <_is_free+0x30>
		return 0;
  2052f4:	00000793          	li	a5,0
  2052f8:	0080006f          	j	205300 <_is_free+0x34>
	} else {
		return 1;
  2052fc:	00100793          	li	a5,1
	}
}
  205300:	00078513          	mv	a0,a5
  205304:	01813403          	ld	s0,24(sp)
  205308:	02010113          	addi	sp,sp,32
  20530c:	00008067          	ret

0000000000205310 <_set_flag>:

static inline void _set_flag(struct Page *page, uint8_t flags)
{
  205310:	fe010113          	addi	sp,sp,-32
  205314:	00813c23          	sd	s0,24(sp)
  205318:	02010413          	addi	s0,sp,32
  20531c:	fea43423          	sd	a0,-24(s0)
  205320:	00058793          	mv	a5,a1
  205324:	fef403a3          	sb	a5,-25(s0)
	page->flags |= flags;
  205328:	fe843783          	ld	a5,-24(s0)
  20532c:	0007c703          	lbu	a4,0(a5)
  205330:	fe744783          	lbu	a5,-25(s0)
  205334:	00f767b3          	or	a5,a4,a5
  205338:	0ff7f713          	andi	a4,a5,255
  20533c:	fe843783          	ld	a5,-24(s0)
  205340:	00e78023          	sb	a4,0(a5)
}
  205344:	00000013          	nop
  205348:	01813403          	ld	s0,24(sp)
  20534c:	02010113          	addi	sp,sp,32
  205350:	00008067          	ret

0000000000205354 <_is_last>:

static inline int _is_last(struct Page *page)
{
  205354:	fe010113          	addi	sp,sp,-32
  205358:	00813c23          	sd	s0,24(sp)
  20535c:	02010413          	addi	s0,sp,32
  205360:	fea43423          	sd	a0,-24(s0)
	if (page->flags & PAGE_LAST) {
  205364:	fe843783          	ld	a5,-24(s0)
  205368:	0007c783          	lbu	a5,0(a5)
  20536c:	0007879b          	sext.w	a5,a5
  205370:	0027f793          	andi	a5,a5,2
  205374:	0007879b          	sext.w	a5,a5
  205378:	00078663          	beqz	a5,205384 <_is_last+0x30>
		return 1;
  20537c:	00100793          	li	a5,1
  205380:	0080006f          	j	205388 <_is_last+0x34>
	} else {
		return 0;
  205384:	00000793          	li	a5,0
	}
}
  205388:	00078513          	mv	a0,a5
  20538c:	01813403          	ld	s0,24(sp)
  205390:	02010113          	addi	sp,sp,32
  205394:	00008067          	ret

0000000000205398 <_align_page>:
/*
 * align the address to the border of page(4K)
 * the up boundage of a 4k size page
 */
static inline ptr_t _align_page(ptr_t address)
{
  205398:	fd010113          	addi	sp,sp,-48
  20539c:	02813423          	sd	s0,40(sp)
  2053a0:	03010413          	addi	s0,sp,48
  2053a4:	fca43c23          	sd	a0,-40(s0)
	ptr_t order = (1 << PAGE_ORDER) - 1;
  2053a8:	000017b7          	lui	a5,0x1
  2053ac:	fff78793          	addi	a5,a5,-1 # fff <STACK_SIZE+0xbff>
  2053b0:	fef43423          	sd	a5,-24(s0)
	return (address + order) & (~order);
  2053b4:	fd843703          	ld	a4,-40(s0)
  2053b8:	fe843783          	ld	a5,-24(s0)
  2053bc:	00f70733          	add	a4,a4,a5
  2053c0:	fe843783          	ld	a5,-24(s0)
  2053c4:	fff7c793          	not	a5,a5
  2053c8:	00f777b3          	and	a5,a4,a5
}
  2053cc:	00078513          	mv	a0,a5
  2053d0:	02813403          	ld	s0,40(sp)
  2053d4:	03010113          	addi	sp,sp,48
  2053d8:	00008067          	ret

00000000002053dc <page_init>:
 *  HEAP_START(BSS_END)
 *
 *  Note: _alloc_end may equal to _memory_end.
 */
void page_init()
{
  2053dc:	fd010113          	addi	sp,sp,-48
  2053e0:	02113423          	sd	ra,40(sp)
  2053e4:	02813023          	sd	s0,32(sp)
  2053e8:	03010413          	addi	s0,sp,48
	ptr_t _heap_start_aligned = _align_page(HEAP_START);
  2053ec:	00001797          	auipc	a5,0x1
  2053f0:	8ec78793          	addi	a5,a5,-1812 # 205cd8 <HEAP_START>
  2053f4:	0007b783          	ld	a5,0(a5)
  2053f8:	00078513          	mv	a0,a5
  2053fc:	f9dff0ef          	jal	ra,205398 <_align_page>
  205400:	fca43c23          	sd	a0,-40(s0)
	 * For simplicity, the space we reserve here is just an approximation,
	 * assuming that it can accommodate the maximum LENGTH_RAM.
	 * We assume LENGTH_RAM should not be too small, ideally no less
	 * than 16M (i.e. PAGE_SIZE * PAGE_SIZE).
	 */
	uint32_t num_reserved_pages = LENGTH_RAM / (PAGE_SIZE * PAGE_SIZE);
  205404:	00f00793          	li	a5,15
  205408:	fcf42a23          	sw	a5,-44(s0)

	_num_pages = (HEAP_SIZE - (_heap_start_aligned - HEAP_START))/ PAGE_SIZE - num_reserved_pages;
  20540c:	00001797          	auipc	a5,0x1
  205410:	8cc78793          	addi	a5,a5,-1844 # 205cd8 <HEAP_START>
  205414:	0007b703          	ld	a4,0(a5)
  205418:	fd843783          	ld	a5,-40(s0)
  20541c:	40f70733          	sub	a4,a4,a5
  205420:	00001797          	auipc	a5,0x1
  205424:	8c078793          	addi	a5,a5,-1856 # 205ce0 <HEAP_SIZE>
  205428:	0007b783          	ld	a5,0(a5)
  20542c:	00f707b3          	add	a5,a4,a5
  205430:	00c7d793          	srli	a5,a5,0xc
  205434:	0007871b          	sext.w	a4,a5
  205438:	fd442783          	lw	a5,-44(s0)
  20543c:	40f707bb          	subw	a5,a4,a5
  205440:	0007871b          	sext.w	a4,a5
  205444:	00003797          	auipc	a5,0x3
  205448:	9f478793          	addi	a5,a5,-1548 # 207e38 <_num_pages>
  20544c:	00e7a023          	sw	a4,0(a5)
	printf("HEAP_START = %p(aligned to %p), HEAP_SIZE = 0x%lx,\n\r"
  205450:	00001797          	auipc	a5,0x1
  205454:	88878793          	addi	a5,a5,-1912 # 205cd8 <HEAP_START>
  205458:	0007b583          	ld	a1,0(a5)
  20545c:	00001797          	auipc	a5,0x1
  205460:	88478793          	addi	a5,a5,-1916 # 205ce0 <HEAP_SIZE>
  205464:	0007b683          	ld	a3,0(a5)
  205468:	00003797          	auipc	a5,0x3
  20546c:	9d078793          	addi	a5,a5,-1584 # 207e38 <_num_pages>
  205470:	0007a783          	lw	a5,0(a5)
  205474:	fd442703          	lw	a4,-44(s0)
  205478:	fd843603          	ld	a2,-40(s0)
  20547c:	00001517          	auipc	a0,0x1
  205480:	15c50513          	addi	a0,a0,348 # 2065d8 <BSS_END+0x8b8>
  205484:	becfd0ef          	jal	ra,202870 <printf>
	/*
	 * We use HEAP_START, not _heap_start_aligned as begin address for
	 * allocating struct Page, because we have no requirement of alignment
	 * for position of struct Page.
	 */
	struct Page *page = (struct Page *)HEAP_START;
  205488:	00001797          	auipc	a5,0x1
  20548c:	85078793          	addi	a5,a5,-1968 # 205cd8 <HEAP_START>
  205490:	0007b783          	ld	a5,0(a5)
  205494:	fef43423          	sd	a5,-24(s0)
	for (int i = 0; i < _num_pages; i++) {
  205498:	fe042223          	sw	zero,-28(s0)
  20549c:	0240006f          	j	2054c0 <page_init+0xe4>
		_clear(page);
  2054a0:	fe843503          	ld	a0,-24(s0)
  2054a4:	e01ff0ef          	jal	ra,2052a4 <_clear>
		page++;	
  2054a8:	fe843783          	ld	a5,-24(s0)
  2054ac:	00178793          	addi	a5,a5,1
  2054b0:	fef43423          	sd	a5,-24(s0)
	for (int i = 0; i < _num_pages; i++) {
  2054b4:	fe442783          	lw	a5,-28(s0)
  2054b8:	0017879b          	addiw	a5,a5,1
  2054bc:	fef42223          	sw	a5,-28(s0)
  2054c0:	fe442703          	lw	a4,-28(s0)
  2054c4:	00003797          	auipc	a5,0x3
  2054c8:	97478793          	addi	a5,a5,-1676 # 207e38 <_num_pages>
  2054cc:	0007a783          	lw	a5,0(a5)
  2054d0:	fcf768e3          	bltu	a4,a5,2054a0 <page_init+0xc4>
	}

	_alloc_start = _heap_start_aligned + num_reserved_pages * PAGE_SIZE;
  2054d4:	fd442783          	lw	a5,-44(s0)
  2054d8:	00c7979b          	slliw	a5,a5,0xc
  2054dc:	0007879b          	sext.w	a5,a5
  2054e0:	02079713          	slli	a4,a5,0x20
  2054e4:	02075713          	srli	a4,a4,0x20
  2054e8:	fd843783          	ld	a5,-40(s0)
  2054ec:	00f70733          	add	a4,a4,a5
  2054f0:	00003797          	auipc	a5,0x3
  2054f4:	93878793          	addi	a5,a5,-1736 # 207e28 <_alloc_start>
  2054f8:	00e7b023          	sd	a4,0(a5)
	_alloc_end = _alloc_start + (PAGE_SIZE * _num_pages);
  2054fc:	00003797          	auipc	a5,0x3
  205500:	93c78793          	addi	a5,a5,-1732 # 207e38 <_num_pages>
  205504:	0007a783          	lw	a5,0(a5)
  205508:	00c7979b          	slliw	a5,a5,0xc
  20550c:	0007879b          	sext.w	a5,a5
  205510:	02079713          	slli	a4,a5,0x20
  205514:	02075713          	srli	a4,a4,0x20
  205518:	00003797          	auipc	a5,0x3
  20551c:	91078793          	addi	a5,a5,-1776 # 207e28 <_alloc_start>
  205520:	0007b783          	ld	a5,0(a5)
  205524:	00f70733          	add	a4,a4,a5
  205528:	00003797          	auipc	a5,0x3
  20552c:	90878793          	addi	a5,a5,-1784 # 207e30 <_alloc_end>
  205530:	00e7b023          	sd	a4,0(a5)
	#ifdef MYPRINT
	printf("TEXT:   %p -> %p\n\r", TEXT_START, TEXT_END);
  205534:	00000797          	auipc	a5,0x0
  205538:	7b478793          	addi	a5,a5,1972 # 205ce8 <TEXT_START>
  20553c:	0007b703          	ld	a4,0(a5)
  205540:	00000797          	auipc	a5,0x0
  205544:	7b078793          	addi	a5,a5,1968 # 205cf0 <TEXT_END>
  205548:	0007b783          	ld	a5,0(a5)
  20554c:	00078613          	mv	a2,a5
  205550:	00070593          	mv	a1,a4
  205554:	00001517          	auipc	a0,0x1
  205558:	10450513          	addi	a0,a0,260 # 206658 <BSS_END+0x938>
  20555c:	b14fd0ef          	jal	ra,202870 <printf>
	printf("RODATA: %p -> %p\n\r", RODATA_START, RODATA_END);
  205560:	00000797          	auipc	a5,0x0
  205564:	7a878793          	addi	a5,a5,1960 # 205d08 <RODATA_START>
  205568:	0007b703          	ld	a4,0(a5)
  20556c:	00000797          	auipc	a5,0x0
  205570:	7a478793          	addi	a5,a5,1956 # 205d10 <RODATA_END>
  205574:	0007b783          	ld	a5,0(a5)
  205578:	00078613          	mv	a2,a5
  20557c:	00070593          	mv	a1,a4
  205580:	00001517          	auipc	a0,0x1
  205584:	0f050513          	addi	a0,a0,240 # 206670 <BSS_END+0x950>
  205588:	ae8fd0ef          	jal	ra,202870 <printf>
	printf("DATA:   %p -> %p\n\r", DATA_START, DATA_END);
  20558c:	00000797          	auipc	a5,0x0
  205590:	76c78793          	addi	a5,a5,1900 # 205cf8 <DATA_START>
  205594:	0007b703          	ld	a4,0(a5)
  205598:	00000797          	auipc	a5,0x0
  20559c:	76878793          	addi	a5,a5,1896 # 205d00 <DATA_END>
  2055a0:	0007b783          	ld	a5,0(a5)
  2055a4:	00078613          	mv	a2,a5
  2055a8:	00070593          	mv	a1,a4
  2055ac:	00001517          	auipc	a0,0x1
  2055b0:	0dc50513          	addi	a0,a0,220 # 206688 <BSS_END+0x968>
  2055b4:	abcfd0ef          	jal	ra,202870 <printf>
	printf("BSS:    %p -> %p\n\r", BSS_START, BSS_END);
  2055b8:	00000797          	auipc	a5,0x0
  2055bc:	76078793          	addi	a5,a5,1888 # 205d18 <BSS_START>
  2055c0:	0007b703          	ld	a4,0(a5)
  2055c4:	00000797          	auipc	a5,0x0
  2055c8:	75c78793          	addi	a5,a5,1884 # 205d20 <BSS_END>
  2055cc:	0007b783          	ld	a5,0(a5)
  2055d0:	00078613          	mv	a2,a5
  2055d4:	00070593          	mv	a1,a4
  2055d8:	00001517          	auipc	a0,0x1
  2055dc:	0c850513          	addi	a0,a0,200 # 2066a0 <BSS_END+0x980>
  2055e0:	a90fd0ef          	jal	ra,202870 <printf>
	printf("HEAP:   %p -> %p\n\r", _alloc_start, _alloc_end);
  2055e4:	00003797          	auipc	a5,0x3
  2055e8:	84478793          	addi	a5,a5,-1980 # 207e28 <_alloc_start>
  2055ec:	0007b703          	ld	a4,0(a5)
  2055f0:	00003797          	auipc	a5,0x3
  2055f4:	84078793          	addi	a5,a5,-1984 # 207e30 <_alloc_end>
  2055f8:	0007b783          	ld	a5,0(a5)
  2055fc:	00078613          	mv	a2,a5
  205600:	00070593          	mv	a1,a4
  205604:	00001517          	auipc	a0,0x1
  205608:	0b450513          	addi	a0,a0,180 # 2066b8 <BSS_END+0x998>
  20560c:	a64fd0ef          	jal	ra,202870 <printf>
	printf("size of struct page:%dbyte\n\r", sizeof(struct Page));
  205610:	00100593          	li	a1,1
  205614:	00001517          	auipc	a0,0x1
  205618:	0bc50513          	addi	a0,a0,188 # 2066d0 <BSS_END+0x9b0>
  20561c:	a54fd0ef          	jal	ra,202870 <printf>
	printf("first page position:%p\n\r", HEAP_START);
  205620:	00000797          	auipc	a5,0x0
  205624:	6b878793          	addi	a5,a5,1720 # 205cd8 <HEAP_START>
  205628:	0007b783          	ld	a5,0(a5)
  20562c:	00078593          	mv	a1,a5
  205630:	00001517          	auipc	a0,0x1
  205634:	0c050513          	addi	a0,a0,192 # 2066f0 <BSS_END+0x9d0>
  205638:	a38fd0ef          	jal	ra,202870 <printf>
	printf("last page position:%p\n\r", page);
  20563c:	fe843583          	ld	a1,-24(s0)
  205640:	00001517          	auipc	a0,0x1
  205644:	0d050513          	addi	a0,a0,208 # 206710 <BSS_END+0x9f0>
  205648:	a28fd0ef          	jal	ra,202870 <printf>
	#endif
}
  20564c:	00000013          	nop
  205650:	02813083          	ld	ra,40(sp)
  205654:	02013403          	ld	s0,32(sp)
  205658:	03010113          	addi	sp,sp,48
  20565c:	00008067          	ret

0000000000205660 <page_alloc>:
/*
 * Allocate a memory block which is composed of contiguous physical pages
 * - npages: the number of PAGE_SIZE pages to allocate
 */
void *page_alloc(int npages)
{
  205660:	fa010113          	addi	sp,sp,-96
  205664:	04113c23          	sd	ra,88(sp)
  205668:	04813823          	sd	s0,80(sp)
  20566c:	06010413          	addi	s0,sp,96
  205670:	00050793          	mv	a5,a0
  205674:	faf42623          	sw	a5,-84(s0)
	/* Note we are searching the page descriptor bitmaps. */
	int found = 0;
  205678:	fe042623          	sw	zero,-20(s0)
	struct Page *page_i = (struct Page *)HEAP_START;
  20567c:	00000797          	auipc	a5,0x0
  205680:	65c78793          	addi	a5,a5,1628 # 205cd8 <HEAP_START>
  205684:	0007b783          	ld	a5,0(a5)
  205688:	fef43023          	sd	a5,-32(s0)
	for (int i = 0; i <= (_num_pages - npages); i++) {
  20568c:	fc042e23          	sw	zero,-36(s0)
  205690:	14c0006f          	j	2057dc <page_alloc+0x17c>
		if (_is_free(page_i)) {
  205694:	fe043503          	ld	a0,-32(s0)
  205698:	c35ff0ef          	jal	ra,2052cc <_is_free>
  20569c:	00050793          	mv	a5,a0
  2056a0:	12078263          	beqz	a5,2057c4 <page_alloc+0x164>
			found = 1;
  2056a4:	00100793          	li	a5,1
  2056a8:	fef42623          	sw	a5,-20(s0)
			/* 
			 * meet a free page, continue to check if following
			 * (npages - 1) pages are also unallocated.
			 */
			struct Page *page_j = page_i + 1;
  2056ac:	fe043783          	ld	a5,-32(s0)
  2056b0:	00178793          	addi	a5,a5,1
  2056b4:	fcf43823          	sd	a5,-48(s0)
			for (int j = i + 1; j < (i + npages); j++) {
  2056b8:	fdc42783          	lw	a5,-36(s0)
  2056bc:	0017879b          	addiw	a5,a5,1
  2056c0:	fcf42623          	sw	a5,-52(s0)
  2056c4:	0340006f          	j	2056f8 <page_alloc+0x98>
				if (!_is_free(page_j)) {
  2056c8:	fd043503          	ld	a0,-48(s0)
  2056cc:	c01ff0ef          	jal	ra,2052cc <_is_free>
  2056d0:	00050793          	mv	a5,a0
  2056d4:	00079663          	bnez	a5,2056e0 <page_alloc+0x80>
					found = 0;
  2056d8:	fe042623          	sw	zero,-20(s0)
					break;
  2056dc:	0380006f          	j	205714 <page_alloc+0xb4>
				}
				page_j++;
  2056e0:	fd043783          	ld	a5,-48(s0)
  2056e4:	00178793          	addi	a5,a5,1
  2056e8:	fcf43823          	sd	a5,-48(s0)
			for (int j = i + 1; j < (i + npages); j++) {
  2056ec:	fcc42783          	lw	a5,-52(s0)
  2056f0:	0017879b          	addiw	a5,a5,1
  2056f4:	fcf42623          	sw	a5,-52(s0)
  2056f8:	fdc42703          	lw	a4,-36(s0)
  2056fc:	fac42783          	lw	a5,-84(s0)
  205700:	00f707bb          	addw	a5,a4,a5
  205704:	0007871b          	sext.w	a4,a5
  205708:	fcc42783          	lw	a5,-52(s0)
  20570c:	0007879b          	sext.w	a5,a5
  205710:	fae7cce3          	blt	a5,a4,2056c8 <page_alloc+0x68>
			/*
			 * get a memory block which is good enough for us,
			 * take housekeeping, then return the actual start
			 * address of the first page of this memory block
			 */
			if (found) {
  205714:	fec42783          	lw	a5,-20(s0)
  205718:	0007879b          	sext.w	a5,a5
  20571c:	08078a63          	beqz	a5,2057b0 <page_alloc+0x150>
				struct Page *page_k = page_i;
  205720:	fe043783          	ld	a5,-32(s0)
  205724:	fcf43023          	sd	a5,-64(s0)
				for (int k = i; k < (i + npages); k++) {
  205728:	fdc42783          	lw	a5,-36(s0)
  20572c:	faf42e23          	sw	a5,-68(s0)
  205730:	0280006f          	j	205758 <page_alloc+0xf8>
					_set_flag(page_k, PAGE_TAKEN);
  205734:	00100593          	li	a1,1
  205738:	fc043503          	ld	a0,-64(s0)
  20573c:	bd5ff0ef          	jal	ra,205310 <_set_flag>
					page_k++;
  205740:	fc043783          	ld	a5,-64(s0)
  205744:	00178793          	addi	a5,a5,1
  205748:	fcf43023          	sd	a5,-64(s0)
				for (int k = i; k < (i + npages); k++) {
  20574c:	fbc42783          	lw	a5,-68(s0)
  205750:	0017879b          	addiw	a5,a5,1
  205754:	faf42e23          	sw	a5,-68(s0)
  205758:	fdc42703          	lw	a4,-36(s0)
  20575c:	fac42783          	lw	a5,-84(s0)
  205760:	00f707bb          	addw	a5,a4,a5
  205764:	0007871b          	sext.w	a4,a5
  205768:	fbc42783          	lw	a5,-68(s0)
  20576c:	0007879b          	sext.w	a5,a5
  205770:	fce7c2e3          	blt	a5,a4,205734 <page_alloc+0xd4>
				}
				page_k--;
  205774:	fc043783          	ld	a5,-64(s0)
  205778:	fff78793          	addi	a5,a5,-1
  20577c:	fcf43023          	sd	a5,-64(s0)
				_set_flag(page_k, PAGE_LAST);
  205780:	00200593          	li	a1,2
  205784:	fc043503          	ld	a0,-64(s0)
  205788:	b89ff0ef          	jal	ra,205310 <_set_flag>
				return (void *)(_alloc_start + i * PAGE_SIZE);
  20578c:	fdc42783          	lw	a5,-36(s0)
  205790:	00c7979b          	slliw	a5,a5,0xc
  205794:	0007879b          	sext.w	a5,a5
  205798:	00078713          	mv	a4,a5
  20579c:	00002797          	auipc	a5,0x2
  2057a0:	68c78793          	addi	a5,a5,1676 # 207e28 <_alloc_start>
  2057a4:	0007b783          	ld	a5,0(a5)
  2057a8:	00f707b3          	add	a5,a4,a5
  2057ac:	0540006f          	j	205800 <page_alloc+0x1a0>
			}else{
				printf("warning:no suitable pages founded!\n\r");
  2057b0:	00001517          	auipc	a0,0x1
  2057b4:	f7850513          	addi	a0,a0,-136 # 206728 <BSS_END+0xa08>
  2057b8:	8b8fd0ef          	jal	ra,202870 <printf>
				return NULL;
  2057bc:	00000793          	li	a5,0
  2057c0:	0400006f          	j	205800 <page_alloc+0x1a0>
			}
		}
		page_i++;
  2057c4:	fe043783          	ld	a5,-32(s0)
  2057c8:	00178793          	addi	a5,a5,1
  2057cc:	fef43023          	sd	a5,-32(s0)
	for (int i = 0; i <= (_num_pages - npages); i++) {
  2057d0:	fdc42783          	lw	a5,-36(s0)
  2057d4:	0017879b          	addiw	a5,a5,1
  2057d8:	fcf42e23          	sw	a5,-36(s0)
  2057dc:	00002797          	auipc	a5,0x2
  2057e0:	65c78793          	addi	a5,a5,1628 # 207e38 <_num_pages>
  2057e4:	0007a703          	lw	a4,0(a5)
  2057e8:	fac42783          	lw	a5,-84(s0)
  2057ec:	40f707bb          	subw	a5,a4,a5
  2057f0:	0007871b          	sext.w	a4,a5
  2057f4:	fdc42783          	lw	a5,-36(s0)
  2057f8:	e8f77ee3          	bgeu	a4,a5,205694 <page_alloc+0x34>
	}
	return NULL;
  2057fc:	00000793          	li	a5,0
}
  205800:	00078513          	mv	a0,a5
  205804:	05813083          	ld	ra,88(sp)
  205808:	05013403          	ld	s0,80(sp)
  20580c:	06010113          	addi	sp,sp,96
  205810:	00008067          	ret

0000000000205814 <page_free>:
/*
 * Free the memory block
 * - p: start address of the memory block
 */
void page_free(void *p)
{
  205814:	fd010113          	addi	sp,sp,-48
  205818:	02113423          	sd	ra,40(sp)
  20581c:	02813023          	sd	s0,32(sp)
  205820:	03010413          	addi	s0,sp,48
  205824:	fca43c23          	sd	a0,-40(s0)
	/*
	 * Assert (TBD) if p is invalid
	 */
	if (!p || (ptr_t)p >= _alloc_end) {
  205828:	fd843783          	ld	a5,-40(s0)
  20582c:	08078a63          	beqz	a5,2058c0 <page_free+0xac>
  205830:	fd843703          	ld	a4,-40(s0)
  205834:	00002797          	auipc	a5,0x2
  205838:	5fc78793          	addi	a5,a5,1532 # 207e30 <_alloc_end>
  20583c:	0007b783          	ld	a5,0(a5)
  205840:	08f77063          	bgeu	a4,a5,2058c0 <page_free+0xac>
		return;
	}
	/* get the first page descriptor of this memory block */
	struct Page *page = (struct Page *)HEAP_START;
  205844:	00000797          	auipc	a5,0x0
  205848:	49478793          	addi	a5,a5,1172 # 205cd8 <HEAP_START>
  20584c:	0007b783          	ld	a5,0(a5)
  205850:	fef43423          	sd	a5,-24(s0)
	page += ((ptr_t)p - _alloc_start)/ PAGE_SIZE;
  205854:	fd843703          	ld	a4,-40(s0)
  205858:	00002797          	auipc	a5,0x2
  20585c:	5d078793          	addi	a5,a5,1488 # 207e28 <_alloc_start>
  205860:	0007b783          	ld	a5,0(a5)
  205864:	40f707b3          	sub	a5,a4,a5
  205868:	00c7d793          	srli	a5,a5,0xc
  20586c:	fe843703          	ld	a4,-24(s0)
  205870:	00f707b3          	add	a5,a4,a5
  205874:	fef43423          	sd	a5,-24(s0)
	/* loop and clear all the page descriptors of the memory block */
	while (!_is_free(page)) {
  205878:	0340006f          	j	2058ac <page_free+0x98>
		if (_is_last(page)) {
  20587c:	fe843503          	ld	a0,-24(s0)
  205880:	ad5ff0ef          	jal	ra,205354 <_is_last>
  205884:	00050793          	mv	a5,a0
  205888:	00078863          	beqz	a5,205898 <page_free+0x84>
			_clear(page);
  20588c:	fe843503          	ld	a0,-24(s0)
  205890:	a15ff0ef          	jal	ra,2052a4 <_clear>
			break;
  205894:	0300006f          	j	2058c4 <page_free+0xb0>
		} else {
			_clear(page);
  205898:	fe843503          	ld	a0,-24(s0)
  20589c:	a09ff0ef          	jal	ra,2052a4 <_clear>
			page++;;
  2058a0:	fe843783          	ld	a5,-24(s0)
  2058a4:	00178793          	addi	a5,a5,1
  2058a8:	fef43423          	sd	a5,-24(s0)
	while (!_is_free(page)) {
  2058ac:	fe843503          	ld	a0,-24(s0)
  2058b0:	a1dff0ef          	jal	ra,2052cc <_is_free>
  2058b4:	00050793          	mv	a5,a0
  2058b8:	fc0782e3          	beqz	a5,20587c <page_free+0x68>
  2058bc:	0080006f          	j	2058c4 <page_free+0xb0>
		return;
  2058c0:	00000013          	nop
		}
	}
}
  2058c4:	02813083          	ld	ra,40(sp)
  2058c8:	02013403          	ld	s0,32(sp)
  2058cc:	03010113          	addi	sp,sp,48
  2058d0:	00008067          	ret

00000000002058d4 <page_test>:

void page_test()
{
  2058d4:	fd010113          	addi	sp,sp,-48
  2058d8:	02113423          	sd	ra,40(sp)
  2058dc:	02813023          	sd	s0,32(sp)
  2058e0:	03010413          	addi	s0,sp,48
	void *p = page_alloc(2);
  2058e4:	00200513          	li	a0,2
  2058e8:	d79ff0ef          	jal	ra,205660 <page_alloc>
  2058ec:	fea43423          	sd	a0,-24(s0)
	printf("p = %p\n\r", p);
  2058f0:	fe843583          	ld	a1,-24(s0)
  2058f4:	00001517          	auipc	a0,0x1
  2058f8:	e5c50513          	addi	a0,a0,-420 # 206750 <BSS_END+0xa30>
  2058fc:	f75fc0ef          	jal	ra,202870 <printf>
	//page_free(p);

	void *p2 = page_alloc(7);
  205900:	00700513          	li	a0,7
  205904:	d5dff0ef          	jal	ra,205660 <page_alloc>
  205908:	fea43023          	sd	a0,-32(s0)
	printf("p2 = %p\n\r", p2);
  20590c:	fe043583          	ld	a1,-32(s0)
  205910:	00001517          	auipc	a0,0x1
  205914:	e5050513          	addi	a0,a0,-432 # 206760 <BSS_END+0xa40>
  205918:	f59fc0ef          	jal	ra,202870 <printf>
	page_free(p);
  20591c:	fe843503          	ld	a0,-24(s0)
  205920:	ef5ff0ef          	jal	ra,205814 <page_free>

	void *p3 = page_alloc(1);
  205924:	00100513          	li	a0,1
  205928:	d39ff0ef          	jal	ra,205660 <page_alloc>
  20592c:	fca43c23          	sd	a0,-40(s0)
	printf("p3 = %p\n\r", p3);
  205930:	fd843583          	ld	a1,-40(s0)
  205934:	00001517          	auipc	a0,0x1
  205938:	e3c50513          	addi	a0,a0,-452 # 206770 <BSS_END+0xa50>
  20593c:	f35fc0ef          	jal	ra,202870 <printf>
}
  205940:	00000013          	nop
  205944:	02813083          	ld	ra,40(sp)
  205948:	02013403          	ld	s0,32(sp)
  20594c:	03010113          	addi	sp,sp,48
  205950:	00008067          	ret

0000000000205954 <w_mscratch>:
static void w_mscratch(reg_t x){
  205954:	fe010113          	addi	sp,sp,-32
  205958:	00813c23          	sd	s0,24(sp)
  20595c:	02010413          	addi	s0,sp,32
  205960:	fea43423          	sd	a0,-24(s0)
	asm volatile("csrw mscratch, %0" : : "r" (x));
  205964:	fe843783          	ld	a5,-24(s0)
  205968:	34079073          	csrw	mscratch,a5
}
  20596c:	00000013          	nop
  205970:	01813403          	ld	s0,24(sp)
  205974:	02010113          	addi	sp,sp,32
  205978:	00008067          	ret

000000000020597c <r_mscratch>:
static reg_t r_mscratch(){
  20597c:	fe010113          	addi	sp,sp,-32
  205980:	00813c23          	sd	s0,24(sp)
  205984:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mscratch" :  "=r" (ret):);
  205988:	340027f3          	csrr	a5,mscratch
  20598c:	fef43423          	sd	a5,-24(s0)
	return ret;
  205990:	fe843783          	ld	a5,-24(s0)
}
  205994:	00078513          	mv	a0,a5
  205998:	01813403          	ld	s0,24(sp)
  20599c:	02010113          	addi	sp,sp,32
  2059a0:	00008067          	ret

00000000002059a4 <r_mstatus>:
static inline reg_t r_mstatus(){
  2059a4:	fe010113          	addi	sp,sp,-32
  2059a8:	00813c23          	sd	s0,24(sp)
  2059ac:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mstatus" : "=r" (x) );
  2059b0:	300027f3          	csrr	a5,mstatus
  2059b4:	fef43423          	sd	a5,-24(s0)
	return x;
  2059b8:	fe843783          	ld	a5,-24(s0)
}
  2059bc:	00078513          	mv	a0,a5
  2059c0:	01813403          	ld	s0,24(sp)
  2059c4:	02010113          	addi	sp,sp,32
  2059c8:	00008067          	ret

00000000002059cc <r_mtvec>:
static inline reg_t r_mtvec(){
  2059cc:	fe010113          	addi	sp,sp,-32
  2059d0:	00813c23          	sd	s0,24(sp)
  2059d4:	02010413          	addi	s0,sp,32
	asm volatile("csrr  %0, mtvec" :  "=r" (ret):);
  2059d8:	305027f3          	csrr	a5,mtvec
  2059dc:	fef43423          	sd	a5,-24(s0)
	return ret;
  2059e0:	fe843783          	ld	a5,-24(s0)
}
  2059e4:	00078513          	mv	a0,a5
  2059e8:	01813403          	ld	s0,24(sp)
  2059ec:	02010113          	addi	sp,sp,32
  2059f0:	00008067          	ret

00000000002059f4 <r_mie>:
{
  2059f4:	fe010113          	addi	sp,sp,-32
  2059f8:	00813c23          	sd	s0,24(sp)
  2059fc:	02010413          	addi	s0,sp,32
	asm volatile("csrr %0, mie" : "=r" (x) );
  205a00:	304027f3          	csrr	a5,mie
  205a04:	fef43423          	sd	a5,-24(s0)
	return x;
  205a08:	fe843783          	ld	a5,-24(s0)
}
  205a0c:	00078513          	mv	a0,a5
  205a10:	01813403          	ld	s0,24(sp)
  205a14:	02010113          	addi	sp,sp,32
  205a18:	00008067          	ret

0000000000205a1c <get_time>:
static uint64_t get_time(){
  205a1c:	ff010113          	addi	sp,sp,-16
  205a20:	00813423          	sd	s0,8(sp)
  205a24:	01010413          	addi	s0,sp,16
    return _tick / CLINT_SLICE_PER_SEC;
  205a28:	00002797          	auipc	a5,0x2
  205a2c:	41878793          	addi	a5,a5,1048 # 207e40 <_tick>
  205a30:	0007b703          	ld	a4,0(a5)
  205a34:	03c00793          	li	a5,60
  205a38:	02f757b3          	divu	a5,a4,a5
}
  205a3c:	00078513          	mv	a0,a5
  205a40:	00813403          	ld	s0,8(sp)
  205a44:	01010113          	addi	sp,sp,16
  205a48:	00008067          	ret

0000000000205a4c <get_time_str>:
static void get_time_str(char* time){
  205a4c:	fc010113          	addi	sp,sp,-64
  205a50:	02813c23          	sd	s0,56(sp)
  205a54:	04010413          	addi	s0,sp,64
  205a58:	fca43423          	sd	a0,-56(s0)
    int index = 0;
  205a5c:	fe042623          	sw	zero,-20(s0)
    uint64_t tick_sec = _tick / CLINT_SLICE_PER_SEC;
  205a60:	00002797          	auipc	a5,0x2
  205a64:	3e078793          	addi	a5,a5,992 # 207e40 <_tick>
  205a68:	0007b703          	ld	a4,0(a5)
  205a6c:	03c00793          	li	a5,60
  205a70:	02f757b3          	divu	a5,a4,a5
  205a74:	fef43023          	sd	a5,-32(s0)
    uint8_t tmp = (tick_sec / 3600);
  205a78:	fe043703          	ld	a4,-32(s0)
  205a7c:	000017b7          	lui	a5,0x1
  205a80:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  205a84:	02f757b3          	divu	a5,a4,a5
  205a88:	fcf40fa3          	sb	a5,-33(s0)
    time[0] = (tmp % 100)/ 10 + '0'; 
  205a8c:	fdf44703          	lbu	a4,-33(s0)
  205a90:	06400793          	li	a5,100
  205a94:	02f777bb          	remuw	a5,a4,a5
  205a98:	0ff7f793          	andi	a5,a5,255
  205a9c:	00078713          	mv	a4,a5
  205aa0:	00a00793          	li	a5,10
  205aa4:	02f757bb          	divuw	a5,a4,a5
  205aa8:	0ff7f793          	andi	a5,a5,255
  205aac:	0307879b          	addiw	a5,a5,48
  205ab0:	0ff7f713          	andi	a4,a5,255
  205ab4:	fc843783          	ld	a5,-56(s0)
  205ab8:	00e78023          	sb	a4,0(a5)
    time[1] = tmp % 10 + '0'; 
  205abc:	fdf44703          	lbu	a4,-33(s0)
  205ac0:	00a00793          	li	a5,10
  205ac4:	02f777bb          	remuw	a5,a4,a5
  205ac8:	0ff7f713          	andi	a4,a5,255
  205acc:	fc843783          	ld	a5,-56(s0)
  205ad0:	00178793          	addi	a5,a5,1
  205ad4:	0307071b          	addiw	a4,a4,48
  205ad8:	0ff77713          	andi	a4,a4,255
  205adc:	00e78023          	sb	a4,0(a5)
    time[2] = ':';
  205ae0:	fc843783          	ld	a5,-56(s0)
  205ae4:	00278793          	addi	a5,a5,2
  205ae8:	03a00713          	li	a4,58
  205aec:	00e78023          	sb	a4,0(a5)
    tmp = (tick_sec % 3600)/60;
  205af0:	fe043703          	ld	a4,-32(s0)
  205af4:	000017b7          	lui	a5,0x1
  205af8:	e1078793          	addi	a5,a5,-496 # e10 <STACK_SIZE+0xa10>
  205afc:	02f77733          	remu	a4,a4,a5
  205b00:	03c00793          	li	a5,60
  205b04:	02f757b3          	divu	a5,a4,a5
  205b08:	fcf40fa3          	sb	a5,-33(s0)
    time[3] = tmp / 10 + '0'; 
  205b0c:	fdf44703          	lbu	a4,-33(s0)
  205b10:	00a00793          	li	a5,10
  205b14:	02f757bb          	divuw	a5,a4,a5
  205b18:	0ff7f713          	andi	a4,a5,255
  205b1c:	fc843783          	ld	a5,-56(s0)
  205b20:	00378793          	addi	a5,a5,3
  205b24:	0307071b          	addiw	a4,a4,48
  205b28:	0ff77713          	andi	a4,a4,255
  205b2c:	00e78023          	sb	a4,0(a5)
    time[4] = tmp % 10 + '0'; 
  205b30:	fdf44703          	lbu	a4,-33(s0)
  205b34:	00a00793          	li	a5,10
  205b38:	02f777bb          	remuw	a5,a4,a5
  205b3c:	0ff7f713          	andi	a4,a5,255
  205b40:	fc843783          	ld	a5,-56(s0)
  205b44:	00478793          	addi	a5,a5,4
  205b48:	0307071b          	addiw	a4,a4,48
  205b4c:	0ff77713          	andi	a4,a4,255
  205b50:	00e78023          	sb	a4,0(a5)
    time[5] = ':';
  205b54:	fc843783          	ld	a5,-56(s0)
  205b58:	00578793          	addi	a5,a5,5
  205b5c:	03a00713          	li	a4,58
  205b60:	00e78023          	sb	a4,0(a5)
    tmp = tick_sec % 60;
  205b64:	fe043703          	ld	a4,-32(s0)
  205b68:	03c00793          	li	a5,60
  205b6c:	02f777b3          	remu	a5,a4,a5
  205b70:	fcf40fa3          	sb	a5,-33(s0)
    time[6] = tmp / 10 + '0'; 
  205b74:	fdf44703          	lbu	a4,-33(s0)
  205b78:	00a00793          	li	a5,10
  205b7c:	02f757bb          	divuw	a5,a4,a5
  205b80:	0ff7f713          	andi	a4,a5,255
  205b84:	fc843783          	ld	a5,-56(s0)
  205b88:	00678793          	addi	a5,a5,6
  205b8c:	0307071b          	addiw	a4,a4,48
  205b90:	0ff77713          	andi	a4,a4,255
  205b94:	00e78023          	sb	a4,0(a5)
    time[7] = tmp % 10 + '0'; 
  205b98:	fdf44703          	lbu	a4,-33(s0)
  205b9c:	00a00793          	li	a5,10
  205ba0:	02f777bb          	remuw	a5,a4,a5
  205ba4:	0ff7f713          	andi	a4,a5,255
  205ba8:	fc843783          	ld	a5,-56(s0)
  205bac:	00778793          	addi	a5,a5,7
  205bb0:	0307071b          	addiw	a4,a4,48
  205bb4:	0ff77713          	andi	a4,a4,255
  205bb8:	00e78023          	sb	a4,0(a5)
}
  205bbc:	00000013          	nop
  205bc0:	03813403          	ld	s0,56(sp)
  205bc4:	04010113          	addi	sp,sp,64
  205bc8:	00008067          	ret

0000000000205bcc <start_kernel>:
 * so just declared here ONCE and NOT included in file os.h.
 */


void start_kernel(void)
{
  205bcc:	ff010113          	addi	sp,sp,-16
  205bd0:	00113423          	sd	ra,8(sp)
  205bd4:	00813023          	sd	s0,0(sp)
  205bd8:	01010413          	addi	s0,sp,16
	uart_init();
  205bdc:	d5cfd0ef          	jal	ra,203138 <uart_init>
	uart_puts("Hello, GROL_OS!\n\r");//this should be replaced with graph later
  205be0:	00001517          	auipc	a0,0x1
  205be4:	ba050513          	addi	a0,a0,-1120 # 206780 <BSS_END+0xa60>
  205be8:	eecfd0ef          	jal	ra,2032d4 <uart_puts>
	#ifdef MYPRINT
	printf("mtvec:%p\n\r", r_mtvec());
  205bec:	de1ff0ef          	jal	ra,2059cc <r_mtvec>
  205bf0:	00050793          	mv	a5,a0
  205bf4:	00078593          	mv	a1,a5
  205bf8:	00001517          	auipc	a0,0x1
  205bfc:	ba050513          	addi	a0,a0,-1120 # 206798 <BSS_END+0xa78>
  205c00:	c71fc0ef          	jal	ra,202870 <printf>
	printf("mstatus:%p\n\r", r_mstatus());
  205c04:	da1ff0ef          	jal	ra,2059a4 <r_mstatus>
  205c08:	00050793          	mv	a5,a0
  205c0c:	00078593          	mv	a1,a5
  205c10:	00001517          	auipc	a0,0x1
  205c14:	b9850513          	addi	a0,a0,-1128 # 2067a8 <BSS_END+0xa88>
  205c18:	c59fc0ef          	jal	ra,202870 <printf>
	print_printftest();
  205c1c:	ea9fd0ef          	jal	ra,203ac4 <print_printftest>
	#endif
	trap_init();
  205c20:	adcfd0ef          	jal	ra,202efc <trap_init>
	#ifdef MYPRINT
	printf("mtvec:%p\n\r", r_mtvec());
  205c24:	da9ff0ef          	jal	ra,2059cc <r_mtvec>
  205c28:	00050793          	mv	a5,a0
  205c2c:	00078593          	mv	a1,a5
  205c30:	00001517          	auipc	a0,0x1
  205c34:	b6850513          	addi	a0,a0,-1176 # 206798 <BSS_END+0xa78>
  205c38:	c39fc0ef          	jal	ra,202870 <printf>
	printf("mstatus:%p\n\r", r_mstatus());
  205c3c:	d69ff0ef          	jal	ra,2059a4 <r_mstatus>
  205c40:	00050793          	mv	a5,a0
  205c44:	00078593          	mv	a1,a5
  205c48:	00001517          	auipc	a0,0x1
  205c4c:	b6050513          	addi	a0,a0,-1184 # 2067a8 <BSS_END+0xa88>
  205c50:	c21fc0ef          	jal	ra,202870 <printf>
	//trap_test();
	#endif
	sched_init(60);
  205c54:	03c00513          	li	a0,60
  205c58:	8edfe0ef          	jal	ra,204544 <sched_init>
	plic_init();
  205c5c:	ae9fd0ef          	jal	ra,203744 <plic_init>
	timer_init();
  205c60:	a64ff0ef          	jal	ra,204ec4 <timer_init>
	#ifdef MYPRINT
	printf("mtvec:%p\n\r", r_mtvec());
  205c64:	d69ff0ef          	jal	ra,2059cc <r_mtvec>
  205c68:	00050793          	mv	a5,a0
  205c6c:	00078593          	mv	a1,a5
  205c70:	00001517          	auipc	a0,0x1
  205c74:	b2850513          	addi	a0,a0,-1240 # 206798 <BSS_END+0xa78>
  205c78:	bf9fc0ef          	jal	ra,202870 <printf>
	printf("mstatus:%p\n\r", r_mstatus());
  205c7c:	d29ff0ef          	jal	ra,2059a4 <r_mstatus>
  205c80:	00050793          	mv	a5,a0
  205c84:	00078593          	mv	a1,a5
  205c88:	00001517          	auipc	a0,0x1
  205c8c:	b2050513          	addi	a0,a0,-1248 # 2067a8 <BSS_END+0xa88>
  205c90:	be1fc0ef          	jal	ra,202870 <printf>
	printf("mie:%p\n\r", r_mie());
  205c94:	d61ff0ef          	jal	ra,2059f4 <r_mie>
  205c98:	00050793          	mv	a5,a0
  205c9c:	00078593          	mv	a1,a5
  205ca0:	00001517          	auipc	a0,0x1
  205ca4:	b1850513          	addi	a0,a0,-1256 # 2067b8 <BSS_END+0xa98>
  205ca8:	bc9fc0ef          	jal	ra,202870 <printf>
	#endif

	page_init();
  205cac:	f30ff0ef          	jal	ra,2053dc <page_init>
	print_heapinit();
  205cb0:	eedfd0ef          	jal	ra,203b9c <print_heapinit>
	#ifdef MYPRINT
	page_test();
  205cb4:	c21ff0ef          	jal	ra,2058d4 <page_test>
	#endif
	print_multitasktest();
  205cb8:	f39fd0ef          	jal	ra,203bf0 <print_multitasktest>

	os_main();
  205cbc:	f6dfc0ef          	jal	ra,202c28 <os_main>

	kernel_schedule();
  205cc0:	e84fe0ef          	jal	ra,204344 <kernel_schedule>

	uart_puts("Would not go here!\n\r");
  205cc4:	00001517          	auipc	a0,0x1
  205cc8:	b0450513          	addi	a0,a0,-1276 # 2067c8 <BSS_END+0xaa8>
  205ccc:	e08fd0ef          	jal	ra,2032d4 <uart_puts>

	while (1) {}; // stop here!
  205cd0:	0000006f          	j	205cd0 <start_kernel+0x104>
